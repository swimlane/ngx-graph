/*! For license information please see 570.14cbe168.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkngx_graph=self.webpackChunkngx_graph||[]).push([[570],{"../../../.yarn/berry/cache/linked-list-typescript-npm-1.0.15-58f04136fb-10c0.zip/node_modules/linked-list-typescript/lib/src/index.js":function(__unused_webpack_module,exports){Object.defineProperty(exports,"__esModule",{value:!0});class LinkedList{constructor(...values){this._head=this._tail=null,this._length=0,values.length>0&&values.forEach((value=>{this.append(value)}))}*iterator(){let currentItem=this._head;for(;currentItem;)yield currentItem.value,currentItem=currentItem.next}[Symbol.iterator](){return this.iterator()}get head(){return this._head?this._head.value:null}get tail(){return this._tail?this._tail.value:null}get length(){return this._length}insert(val,previousItem,checkDuplicates=!1){if(checkDuplicates&&this.isDuplicate(val))return!1;let newItem=new LinkedListItem(val),currentItem=this._head;if(!currentItem)return!1;for(;;){if(currentItem.value===previousItem)return newItem.next=currentItem.next,newItem.prev=currentItem,currentItem.next=newItem,newItem.next?newItem.next.prev=newItem:this._tail=newItem,this._length++,!0;if(!currentItem.next)return!1;currentItem=currentItem.next}}append(val,checkDuplicates=!1){if(checkDuplicates&&this.isDuplicate(val))return!1;let newItem=new LinkedListItem(val);return this._tail?(this._tail.next=newItem,newItem.prev=this._tail,this._tail=newItem):this._head=this._tail=newItem,this._length++,!0}prepend(val,checkDuplicates=!1){if(checkDuplicates&&this.isDuplicate(val))return!1;let newItem=new LinkedListItem(val);return this._head?(newItem.next=this._head,this._head.prev=newItem,this._head=newItem):this._head=this._tail=newItem,this._length++,!0}remove(val){let currentItem=this._head;if(currentItem){if(currentItem.value===val)return this._head=currentItem.next,this._head.prev=null,currentItem.next=currentItem.prev=null,this._length--,currentItem.value;for(;;){if(currentItem.value===val)return currentItem.next?(currentItem.prev.next=currentItem.next,currentItem.next.prev=currentItem.prev,currentItem.next=currentItem.prev=null):(currentItem.prev.next=null,this._tail=currentItem.prev,currentItem.next=currentItem.prev=null),this._length--,currentItem.value;if(!currentItem.next)return;currentItem=currentItem.next}}}removeHead(){let currentItem=this._head;if(currentItem)return this._head.next?(this._head.next.prev=null,this._head=this._head.next,currentItem.next=currentItem.prev=null):(this._head=null,this._tail=null),this._length--,currentItem.value}removeTail(){let currentItem=this._tail;if(currentItem)return this._tail.prev?(this._tail.prev.next=null,this._tail=this._tail.prev,currentItem.next=currentItem.prev=null):(this._head=null,this._tail=null),this._length--,currentItem.value}first(num){let iter=this.iterator(),result=[],n=Math.min(num,this.length);for(let i=0;i<n;i++){let val=iter.next();result.push(val.value)}return result}toArray(){return[...this]}isDuplicate(val){return new Set(this.toArray()).has(val)}}exports.LinkedList=LinkedList;class LinkedListItem{constructor(val){this.value=val,this.next=null,this.prev=null}}exports.LinkedListItem=LinkedListItem},"../../../.yarn/berry/cache/msagl-js-npm-0.0.51-102fca0990-10c0.zip/node_modules/msagl-js/dist/index.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{KJ:function(){return curveFactory_CurveFactory},Ci:function(){return GeomEdge},t$:function(){return GeomGraph},DR:function(){return GeomNode},yn:function(){return LayerDirectionEnum},bP:function(){return Node},bR:function(){return point_Point},M_:function(){return Rectangle},or:function(){return Size},cc:function(){return SugiyamaLayoutSettings_SugiyamaLayoutSettings},WL:function(){return interpolateICurve},Zq:function(){return layoutGraphWithSugiayma}});var point_TriangleOrientation,VertexId,PointLocation,Direction,src=__webpack_require__("../../../.yarn/berry/cache/queue-typescript-npm-1.0.1-b291feb596-10c0.zip/node_modules/queue-typescript/lib/src/index.js");class AttrContainer{constructor(){this.attrs=[]}get length(){return this.attrs.length}clearAttr(){this.attrs=[]}setAttr(position,val){this.attrs[position]=val}getAttr(position){return this.attrs[position]}}class Entity extends AttrContainer{constructor(){super(...arguments),this._parent=null}get parent(){return this._parent}set parent(value){this._parent=value}*getAncestors(){let p=this.parent;for(;null!=p;)yield p,p=p.parent}isDescendantOf(graph){for(const p of this.getAncestors())if(p==graph)return!0;return!1}}class Edge extends Entity{constructor(s,t){super(),this.source=s,this.target=t,s!=t?(s.outEdges.add(this),t.inEdges.add(this)):s.selfEdges.add(this)}add(){this.source!=this.target?(this.source.outEdges.add(this),this.target.inEdges.add(this)):this.source.selfEdges.add(this)}remove(){this.source!=this.target?(this.source.outEdges.delete(this),this.target.inEdges.delete(this)):this.source.selfEdges.delete(this)}toString(){return"("+this.source.toString()+"->"+this.target.toString()+")"}isInterGraphEdge(){return this.source.parent!=this.target.parent}}class Node extends Entity{constructor(id){super(),this.inEdges=new Set,this.outEdges=new Set,this.selfEdges=new Set,this.id=id}get id(){return this._id}set id(value){this._id=value}toString(){return this.id}get isGraph(){return!1}*graphs(){if(this.isGraph){const nc=this.nodeCollection;for(const g of nc.graphs)yield g}}*_edges(){for(const e of this.inEdges)yield e;for(const e of this.outEdges)yield e;for(const e of this.selfEdges)yield e}addInEdge(edge){this.inEdges.add(edge)}addOutEdge(edge){this.outEdges.add(edge)}addSelfEdge(edge){this.selfEdges.add(edge)}addEdde(e){if(this==e.source)e.target==this?this.addSelfEdge(e):this.addOutEdge(e);else{if(this!=e.target)throw new Error("attaching an edge to non adjacent node");this.addInEdge(e)}return e}get edges(){return this._edges()}get outDegree(){return this.outEdges.size}get inDegree(){return this.inEdges.size}get selfDegree(){return this.selfEdges.size}get degree(){return this.outDegree+this.inDegree+this.selfDegree}*getAncestors(){let g=this.parent;for(;null!=g;)yield g,g=g.parent}isUnderCollapsedGraph(){return null!=this.parent&&this.parent.isCollapsed}}class NodeCollection{constructor(){this.nodeMap=new Map}*nodes_(){for(const p of this.nodeMap.values())yield p}*graphs_(){for(const n of this.nodes_())n.isGraph&&(yield n)}find(id){return this.nodeMap.get(id)}get nodesShallow(){return this.nodes_()}*nodesDeep(){for(const n of this.nodes_())if(yield n,n.isGraph)for(const nn of n.nodeCollection.nodesDeep())yield nn}get graphs(){return this.graphs_()}*_edges(){for(const node of this.nodeMap.values()){for(const e of node.outEdges)yield e;for(const e of node.selfEdges)yield e}}interGraphEdges(){throw new Error("not implemented")}hasNode(id){if(this.nodeMap.has(id))return!0;for(const p of this.nodeMap)if(p[1].isGraph&&p[1].nodeCollection.hasNode(id))return!0;return!1}getNode(id){let r=this.nodeMap.get(id);if(null!=r)return r;for(const p of this.nodeMap)if(p[1].isGraph&&(r=p[1].nodeCollection.getNode(id),null!=r))return r}get nodeShallowCount(){return this.nodeMap.size}get nodeDeepCount(){let count=this.nodeMap.size;for(const p of this.nodeMap.values())p.isGraph&&(count+=p.nodeCollection.nodeDeepCount);return count}get edgeCount(){let count=0;for(const p of this.nodeMap.values())count+=p.outDegree+p.selfDegree;return count}get edges(){return this._edges()}addNode(node){null==this.getNode(node.id)&&this.nodeMap.set(node.id,node)}addEdge(edge){this.addNode(edge.source),this.addNode(edge.target),edge.source!=edge.target?(edge.source.outEdges.add(edge),edge.target.inEdges.add(edge)):edge.source.selfEdges.add(edge)}removeNode(node){for(const e of node.outEdges)e.target.inEdges.delete(e);for(const e of node.inEdges)e.source.outEdges.delete(e);this.nodeMap.delete(node.id);for(const p of this.nodeMap.values())if(p.isGraph){p.nodeCollection.nodeMap.delete(node.id)}}nodeIsConsistent(n){for(const e of n.outEdges){if(e.source!=n)return!1;if(e.source==e.target)return!1;if(!this.nodeMap.has(e.target.id))return!1}for(const e of n.inEdges)return e.target==n&&(e.source!=e.target&&!!this.nodeMap.has(e.source.id));for(const e of n.selfEdges){if(e.target!=e.source)return!1;if(e.source==n)return!1}return!0}isConsistent(){for(const pair of this.nodeMap)if(!this.nodeIsConsistent(pair[1]))return!1;return!0}}class Graph extends Node{constructor(id="__graph__"){super(id),this.isCollapsed=!1,this.nodeCollection=new NodeCollection}noEmptySubgraphs(){for(const g of this.subgraphs())if(0==g.shallowNodeCount)return!1;return!0}hasSubgraphs(){for(const n of this.shallowNodes)if(n.isGraph)return!0;return!1}*subgraphs(){for(const n of this.deepNodes)n instanceof Graph&&(yield n)}get isGraph(){return!0}isEmpty(){return 0==this.shallowNodeCount}setEdge(sourceId,targetId){const s=this.nodeCollection.find(sourceId);if(null==s)return;const t=this.nodeCollection.find(targetId);if(null==t)return;const e=new Edge(s,t);return this.addEdge(e),e}get shallowNodes(){return this.nodeCollection.nodesShallow}get deepNodes(){return this.nodeCollection.nodesDeep()}findNode(id){return this.nodeCollection.find(id)}get edges(){return this.nodeCollection.edges}*deepEdges(){for(const node of this.deepNodes){for(const e of node.outEdges)yield e;for(const e of node.selfEdges)yield e}}isConsistent(){return this.nodeCollection.isConsistent()}nodeIsConsistent(n){return this.nodeCollection.nodeIsConsistent(n)}removeNode(n){this.nodeCollection.removeNode(n)}addNode(n){return n.parent=this,this.nodeCollection.addNode(n),n}addEdge(n){this.nodeCollection.addEdge(n)}get shallowNodeCount(){return this.nodeCollection.nodeShallowCount}get nodeCountDeep(){return this.nodeCollection.nodeDeepCount}get edgeCount(){return this.nodeCollection.edgeCount}liftNode(n){for(;null!=n&&n.parent!=this;)n=n.parent;return n}}class LinearSystem2{static solve(a00,a01,b0,a10,a11,b1){const d=a00*a11-a10*a01;if(!(Math.abs(d)<LinearSystem2.eps))return{x:(b0*a11-b1*a01)/d,y:(a00*b1-a10*b0)/d}}}LinearSystem2.eps=1e-8;class GeomConstants{static RoundPoint(point){return new point_Point(GeomConstants.RoundDouble(point.x),GeomConstants.RoundDouble(point.y))}static RoundDouble(num){return Math.round(num*GeomConstants.mult)/GeomConstants.mult}}function compareNumbers(a,b){const t=a-b;return t<0?-1:0==t?0:1}function comparePointsYFirst(a,b){const cmp=compareNumbers(a.y,b.y);return cmp||compareNumbers(a.x,b.x)}function closeDistEps(a,b){const d=a-b;return-GeomConstants.distanceEpsilon<=d&&d<=GeomConstants.distanceEpsilon}function greaterDistEps(a,b){return compareNumbersDistEps(a,b)>0}function compareNumbersDistEps(a,b){const c=a-b;return c<=-GeomConstants.distanceEpsilon?-1:c>=GeomConstants.distanceEpsilon?1:0}function distPP(a,b){return a.sub(b).length}GeomConstants.distanceEpsilonPrecision=6,GeomConstants.mult=Math.pow(10,6),GeomConstants.defaultLeafBoxesOffset=.5,GeomConstants.lineSegmentThreshold=.05,GeomConstants.intersectionEpsilon=1e-4,GeomConstants.distanceEpsilon=Math.pow(10,-GeomConstants.distanceEpsilonPrecision),GeomConstants.squareOfDistanceEpsilon=Math.pow(10,2*-GeomConstants.distanceEpsilonPrecision),GeomConstants.tolerance=1e-8,function(TriangleOrientation){TriangleOrientation[TriangleOrientation.Clockwise=0]="Clockwise",TriangleOrientation[TriangleOrientation.Counterclockwise=1]="Counterclockwise",TriangleOrientation[TriangleOrientation.Collinear=2]="Collinear"}(point_TriangleOrientation||(point_TriangleOrientation={}));class point_Point{constructor(x,y){this.x_=x,this.y_=y}static ProjectionToLine(a,b,c){let d=b.sub(a);const dLen=d.length;if(dLen<GeomConstants.distanceEpsilon)return a;d=d.div(dLen);const pr=c.sub(a).dot(d);return a.add(d.mul(pr))}static RayIntersectsRayInteriors(aOrig,aDirection,bOrig,bDirection){const x=point_Point.lineLineIntersection(aOrig,aOrig.add(aDirection),bOrig,bOrig.add(bDirection));if(x)return x.sub(aOrig).dot(aDirection.div(aDirection.l1))>GeomConstants.distanceEpsilon&&x.sub(bOrig).dot(bDirection.div(bDirection.l1))>GeomConstants.distanceEpsilon?x:void 0}static IntervalIntersectsRay(segStart,segEnd,rayOrigin,rayDirection){const x=point_Point.lineLineIntersection(segStart,segEnd,rayOrigin,rayOrigin.add(rayDirection));if(!x)return;const ds=segStart.sub(x),de=x.sub(segEnd);return ds.dot(de)<=0||x.sub(rayOrigin).dot(rayDirection)<0?void 0:ds.dot(ds)>GeomConstants.squareOfDistanceEpsilon&&de.dot(de)>=GeomConstants.squareOfDistanceEpsilon?x:void 0}static PointToTheLeftOfLineOrOnLine(point,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(point,linePoint0,linePoint1)>=0}static PointToTheLeftOfLine(point,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(point,linePoint0,linePoint1)>0}static PointIsInsideCone(p,apex,leftSideConePoint,rightSideConePoint){return point_Point.PointToTheRightOfLineOrOnLine(p,apex,leftSideConePoint)&&point_Point.PointToTheLeftOfLineOrOnLine(p,apex,rightSideConePoint)}static PointToTheRightOfLineOrOnLine(point,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(linePoint0,linePoint1,point)<=0}static PointToTheRightOfLine(point,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(linePoint0,linePoint1,point)<0}static closeIntersections(a,b){return point_Point.close(a,b,GeomConstants.intersectionEpsilon)}get l1(){return Math.abs(this.x_)+Math.abs(this.y_)}dot(a){return this.x*a.x+this.y*a.y}get x(){return this.x_}get y(){return this.y_}compareTo(other){const r=compareNumbers(this.x,other.x);return 0!=r?r:compareNumbers(this.y,other.y)}toString(){return"("+this.x+","+this.y+")"}static close(a,b,tol){return a.sub(b).length<=tol}static closeSquare(a,b,tol){const d=b.sub(a);return d.dot(d)<=tol}static closeDistEps(a,b,eps=GeomConstants.distanceEpsilon){return a.sub(b).length<=eps}normalize(){const l=this.length;return new point_Point(this.x/l,this.y/l)}get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}get lengthSquared(){return this.x*this.x+this.y*this.y}static middle(a,b){return a.add(b).div(2)}scale(sx,sy){return new point_Point(this.x*sx,this.y*sy)}add(a){return new point_Point(this.x+a.x,this.y+a.y)}sub(a){return new point_Point(this.x-a.x,this.y-a.y)}mul(c){return new point_Point(this.x*c,this.y*c)}div(c){return new point_Point(this.x/c,this.y/c)}equal(a){return a.x==this.x&&a.y==this.y}neg(){return new point_Point(-this.x,-this.y)}static lineLineIntersection(a,b,c,d){const ba=b.sub(a),cd=c.sub(d),ca=c.sub(a),ret=LinearSystem2.solve(ba.x,cd.x,ca.x,ba.y,cd.y,ca.y);return null!=ret?a.add(ba.mul(ret.x)):void 0}static segSegIntersection(a,b,c,d){const ba=b.sub(a),cd=c.sub(d),ca=c.sub(a),eps=GeomConstants.tolerance,ret=LinearSystem2.solve(ba.x,cd.x,ca.x,ba.y,cd.y,ca.y);return null!=ret&&ret.x>-eps&&ret.x<1+eps&&ret.y>-eps&&ret.y<1+eps?a.add(ba.mul(ret.x)):void 0}static parallelWithinEpsilon(a,b,eps){const alength=a.length,blength=b.length;return alength<eps||blength<eps||(a=a.div(alength),b=b.div(blength),Math.abs(-a.x*b.y+a.y*b.x)<eps)}static crossProduct(point0,point1){return point0.x*point1.y-point0.y*point1.x}static dot(a,b){return a.x*b.x+a.y*b.y}static add(a,b){return a.add(b)}rotate90Ccw(){return new point_Point(-this.y,this.x)}rotate90Cw(){return new point_Point(this.y,-this.x)}clone(){return new point_Point(this.x,this.y)}rotate(angle){const c=Math.cos(angle),s=Math.sin(angle);return new point_Point(c*this.x-s*this.y,s*this.x+c*this.y)}static mkPoint(x,a,y,b){return a.mul(x).add(b.mul(y))}static convSum(x,a,b){return a.add(b.sub(a).mul(x))}static anglePCP(point1,center,point3){return point_Point.angle(point1.sub(center),point3.sub(center))}static angle(side0,side1){const ax=side0.x,ay=side0.y,bx=side1.x,by=side1.y,cross=ax*by-ay*bx,dot=ax*bx+ay*by;if(Math.abs(dot)<GeomConstants.tolerance)return Math.abs(cross)<GeomConstants.tolerance?0:cross<-GeomConstants.tolerance?3*Math.PI/2:Math.PI/2;if(Math.abs(cross)<GeomConstants.tolerance)return dot<-GeomConstants.tolerance?Math.PI:0;const atan2=Math.atan2(cross,dot);return cross>=-GeomConstants.tolerance?atan2:2*Math.PI+atan2}static signedDoubledTriangleArea(a,b,c){return(b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y)}static getTriangleOrientation(cornerA,cornerB,cornerC){const area=point_Point.signedDoubledTriangleArea(cornerA,cornerB,cornerC);return area>GeomConstants.distanceEpsilon?point_TriangleOrientation.Counterclockwise:area<-GeomConstants.distanceEpsilon?point_TriangleOrientation.Clockwise:point_TriangleOrientation.Collinear}static getTriangleOrientationWithIntersectionEpsilon(cornerA,cornerB,cornerC){const area=point_Point.signedDoubledTriangleArea(cornerA,cornerB,cornerC);return area>GeomConstants.intersectionEpsilon?point_TriangleOrientation.Counterclockwise:area<-GeomConstants.intersectionEpsilon?point_TriangleOrientation.Clockwise:point_TriangleOrientation.Collinear}static ClosestPointAtLineSegment(point,segmentStart,segmentEnd){const bc=segmentEnd.sub(segmentStart),ba=point.sub(segmentStart),c1=bc.dot(ba),c2=bc.dot(bc);return c1<=0+GeomConstants.tolerance?segmentStart:c2<=c1+GeomConstants.tolerance?segmentEnd:segmentStart.add(bc.mul(c1/c2))}static pointToTheLeftOfLineOrOnLine(point,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(point,linePoint0,linePoint1)>=0}static pointToTheLeftOfLine(point,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(point,linePoint0,linePoint1)>0}static pointToTheRightOfLineOrOnLine(point,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(linePoint0,linePoint1,point)<=0}static pointToTheRightOfLine(point,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(linePoint0,linePoint1,point)<0}static canProject(point,segmentStart,segmentEnd){const bc=segmentEnd.sub(segmentStart);if(point.sub(segmentStart).dot(bc)<0)return!1;return!(point.sub(segmentEnd).dot(bc)>0)}static distToLineSegment(a,b,c){const bc=c.sub(b),ba=a.sub(b);let c1,c2;if((c1=bc.dot(ba))<=GeomConstants.tolerance)return{par:0,dist:ba.length};if((c2=bc.dot(bc))<=c1+GeomConstants.tolerance)return{par:1,dist:a.sub(c).length};const p=c1/c2;return{par:p,dist:b.add(bc.mul(p)).length}}}class PolylinePoint{constructor(){this._next=null,this.prev=null}get point(){return this._point}set point(value){this._point=value}get next(){return this._next}set next(value){this._next=value}get nextOnPolyline(){return this.polyline.next(this)}get prevOnPolyline(){return this.polyline.prev(this)}getNext(){return this.next}setNext(nVal){this.next=nVal,null!=this.polyline&&this.polyline.setInitIsRequired()}getPrev(){return this.prev}setPrev(prevVal){this.prev=prevVal,null!=this.polyline&&this.polyline.setInitIsRequired()}static mkFromPoint(p){const pp=new PolylinePoint;return pp.point=p,pp}}!function(VertexId){VertexId[VertexId.Corner=0]="Corner",VertexId[VertexId.VertexA=1]="VertexA",VertexId[VertexId.otherCorner=2]="otherCorner",VertexId[VertexId.VertexB=3]="VertexB"}(VertexId||(VertexId={}));class Parallelogram{contains(point){const g=point.sub(this.corner),e=GeomConstants.distanceEpsilon,gbRot=g.dot(this.bRot);if(gbRot>this.abRot+e||gbRot<-e)return!1;const gaRot=g.dot(this.aRot);return gaRot<=this.baRot+e&&gaRot>=-e}get area(){return Math.abs(this.a.x*this.b.y-this.a.y*this.b.x)}vertex(vertexPar){switch(vertexPar){case VertexId.Corner:return this.corner;case VertexId.VertexA:return this.aPlusCorner;case VertexId.otherCorner:return this.otherCorner;case VertexId.VertexB:return this.bPlusCorner;default:return}}static parallelogramOfTwo(box0,box1){const result=new Parallelogram,v=box0.corner,mm={minx:v.x,maxx:v.x,miny:v.y,maxy:v.y};return Parallelogram.pumpMinMax(mm,box0.aPlusCorner),Parallelogram.pumpMinMax(mm,box0.otherCorner),Parallelogram.pumpMinMax(mm,box0.bPlusCorner),Parallelogram.pumpMinMax(mm,box1.corner),Parallelogram.pumpMinMax(mm,box1.aPlusCorner),Parallelogram.pumpMinMax(mm,box1.otherCorner),Parallelogram.pumpMinMax(mm,box1.bPlusCorner),result.corner=new point_Point(mm.minx,mm.miny),result.a=new point_Point(0,mm.maxy-mm.miny),result.b=new point_Point(mm.maxx-mm.minx,0),result.aPlusCorner=result.a.add(result.corner),result.otherCorner=result.b.add(result.aPlusCorner),result.bPlusCorner=result.b.add(result.corner),result.aRot=new point_Point(-result.a.y,result.a.x),result.aRot.length>.5&&(result.aRot=result.aRot.normalize()),result.bRot=new point_Point(-result.b.y,result.b.x),result.bRot.length>.5&&(result.bRot=result.bRot.normalize()),result.abRot=result.a.dot(result.bRot),result.baRot=result.b.dot(result.aRot),result.abRot<0&&(result.abRot=-result.abRot,result.bRot=result.bRot.neg()),result.baRot<0&&(result.baRot=-result.baRot,result.aRot=result.aRot.neg()),result.isSeg=result.a.sub(result.b).length<GeomConstants.distanceEpsilon,result}static pumpMinMax(mm,p){p.x<mm.minx?mm.minx=p.x:p.x>mm.maxx&&(mm.maxx=p.x),p.y<mm.miny?mm.miny=p.y:p.y>mm.maxy&&(mm.maxy=p.y)}static intersect(parallelogram0,parallelogram1){return 0!=!(Parallelogram.separByA(parallelogram0,parallelogram1)||Parallelogram.separByA(parallelogram1,parallelogram0)||Parallelogram.separByB(parallelogram0,parallelogram1)||Parallelogram.separByB(parallelogram1,parallelogram0))&&(!parallelogram0.isSeg||!parallelogram1.isSeg||(!point_Point.parallelWithinEpsilon(parallelogram0.otherCorner.sub(parallelogram0.corner),parallelogram1.otherCorner.sub(parallelogram1.corner),1e-5)||Parallelogram.ParallelSegsIntersect(parallelogram1,parallelogram0)))}static ParallelSegsIntersect(p0,p1){const v0=p0.corner,v1=p0.otherCorner,v2=p1.corner,v3=p1.otherCorner,d=v1.sub(v0),r1=d.dot(d);let r2=v2.sub(v0).dot(d),r3=v3.sub(v0).dot(d);if(r2>r3){const t=r2;r2=r3,r3=t}return!(r3<0-GeomConstants.distanceEpsilon||r2>r1+GeomConstants.distanceEpsilon)}static separByB(p0,p1){const eps=GeomConstants.distanceEpsilon,p1a=p1.vertex(0).sub(p0.corner).dot(p0.bRot),list=[VertexId.VertexA,VertexId.otherCorner,VertexId.VertexB];if(p1a>p0.abRot+eps){for(const i of list)if(p1.vertex(i).sub(p0.corner).dot(p0.bRot)<=p0.abRot+eps)return!1;return!0}if(p1a<-eps){for(const i of list)if(p1.vertex(i).sub(p0.corner).dot(p0.bRot)>=-eps)return!1;return!0}return!1}static separByA(p0,p1){const eps=GeomConstants.distanceEpsilon;let t=p1.corner.sub(p0.corner);const p1a=point_Point.dot(t,p0.aRot);return p1a>p0.baRot+eps?(t=p1.aPlusCorner.sub(p0.corner),!(point_Point.dot(t,p0.aRot)<=p0.baRot+eps)&&(t=p1.bPlusCorner.sub(p0.corner),!(point_Point.dot(t,p0.aRot)<=p0.baRot+eps)&&(t=p1.otherCorner.sub(p0.corner),!(point_Point.dot(t,p0.aRot)<=p0.baRot+eps)))):p1a<-eps&&(t=p1.aPlusCorner.sub(p0.corner),!(point_Point.dot(t,p0.aRot)>=-eps)&&(t=p1.bPlusCorner.sub(p0.corner),!(point_Point.dot(t,p0.aRot)>=-eps)&&(t=p1.otherCorner.sub(p0.corner),!(point_Point.dot(t,p0.aRot)>=-eps))))}static parallelogramByCornerSideSide(corner,sideA,sideB){const result=new Parallelogram;return result.corner=corner,result.a=sideA,result.b=sideB,result.aRot=new point_Point(-sideA.y,sideA.x),result.aRot.length>.5&&(result.aRot=result.aRot.normalize()),result.bRot=new point_Point(-sideB.y,sideB.x),result.bRot.length>.5&&(result.bRot=result.bRot.normalize()),result.abRot=result.bRot.dot(sideA),result.baRot=sideB.dot(result.aRot),result.abRot<0&&(result.abRot=-result.abRot,result.bRot=result.bRot.neg()),result.baRot<0&&(result.baRot=-result.baRot,result.aRot=result.aRot.neg()),result.isSeg=sideA.sub(sideB).length<GeomConstants.distanceEpsilon,result.aPlusCorner=sideA.add(corner),result.otherCorner=sideB.add(result.aPlusCorner),result.bPlusCorner=sideB.add(corner),result}static getParallelogramOfAGroup(boxes){let minx=0,maxx=0,miny=0,maxy=0,firstTime=!0;for(const b of boxes){const verts=allVerticesOfParall(b);for(const v of verts){const x=v.x,y=v.y;firstTime?(firstTime=!1,minx=maxx=x,miny=maxy=y):(x<minx?minx=x:x>maxx&&(maxx=x),y<miny?miny=y:y>maxy&&(maxy=y))}}return Parallelogram.parallelogramByCornerSideSide(new point_Point(minx,miny),new point_Point(0,maxy-miny),new point_Point(maxx-minx,0))}}function*allVerticesOfParall(p){yield p.corner,yield p.aPlusCorner,yield p.otherCorner,yield p.bPlusCorner}class LineSegment{constructor(x,y,x1,y1){this.parStart=0,this.parEnd=1,this.start=new point_Point(x,y),this.end=new point_Point(x1,y1)}offsetCurve(offset,dir){return null}trim(start,end){if((start=Math.max(this.parStart,start))>(end=Math.min(this.parEnd,end)))throw"wrong params in trimming";const p1=this.value(start),p2=this.value(end);return point_Point.close(p1,p2,GeomConstants.distanceEpsilon)?null:LineSegment.mkPP(p1,p2)}value(t){return this.start.add(this.end.sub(this.start).mul(t))}trimWithWrap(start,end){return null}pNodeOverICurve(){const side=this.end.sub(this.start).mul(.5);return{parallelogram:Parallelogram.parallelogramByCornerSideSide(this.start,side,side),seg:this,leafBoxesOffset:0,node:{low:0,high:1,chord:this}}}normal(){let t=this.start.sub(this.end);return t=t.div(t.length),new point_Point(-t.y,t.x)}static mkPP(start,end){return new LineSegment(start.x,start.y,end.x,end.y)}static mkLinePXY(p,x,y){return new LineSegment(p.x,p.y,x,y)}derivative(t){return this.end.sub(this.start)}secondDerivative(t){return new point_Point(0,0)}thirdDerivative(t){return new point_Point(0,0)}reverse(){return LineSegment.mkPP(this.end,this.start)}translate(delta){this.start=this.start.add(delta),this.end=this.end.add(delta)}scaleFromOrigin(xScale,yScale){return LineSegment.mkPP(this.start.scale(xScale,yScale),this.end.scale(xScale,yScale))}getParameterAtLength(length){const len=this.end.sub(this.start).length;if(len<GeomConstants.tolerance)return 0;const t=length/len;return t>1?1:t<0?0:t}transform(transformation){return LineSegment.mkPP(transformation.multiplyPoint(this.start),transformation.multiplyPoint(this.end))}closestParameterWithinBounds(targetPoint,low,high){let t=this.closestParameter(targetPoint);return t<low&&(t=low),t>high&&(t=high),t}lengthPartial(start,end){return this.value(end).sub(this.value(start)).length}get length(){return this.start.sub(this.end).length}get boundingBox(){return Rectangle.mkPP(this.start,this.end)}clone(){return LineSegment.mkPP(this.start.clone(),this.end.clone())}static closestParameterOnLineSegment(point,segmentStart,segmentEnd){const bc=segmentEnd.sub(segmentStart),ba=point.sub(segmentStart),c1=bc.dot(ba);if(c1<=0+GeomConstants.tolerance)return 0;const c2=bc.dot(bc);return c2<=c1+GeomConstants.tolerance?1:c1/c2}closestParameter(targetPoint){return LineSegment.closestParameterOnLineSegment(targetPoint,this.start,this.end)}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}static IntersectPPPP(a,b,c,d){const r=point_Point.lineLineIntersection(a,b,c,d);if(null!=r)return LineSegment.xIsBetweenPoints(a,b,r)&&LineSegment.xIsBetweenPoints(c,d,r)?r:void 0}static xIsBetweenPoints(a,b,x){return a.sub(x).dot(b.sub(x))<=GeomConstants.distanceEpsilon}curvature(t){return 0}curvatureDerivative(t){return 0}curvatureSecondDerivative(_){return 0}static minDistBetweenLineSegments(a,b,c,d){const u=b.sub(a),v=d.sub(c),w=a.sub(c),D=point_Point.crossProduct(u,v),uu=u.dot(u),uv=u.dot(v),vv=v.dot(v),uw=u.dot(w),vw=v.dot(w);let sN,tN;const absD=Math.abs(D);let sD=absD,tD=absD;absD<GeomConstants.tolerance?(sN=0,sD=1,tN=vw,tD=vv):(sN=point_Point.crossProduct(v,w),tN=point_Point.crossProduct(u,w),D<0&&(sN=-sN,tN=-tN),sN<0?(sN=0,tN=vw,tD=vv):sN>sD&&(sN=sD=1,tN=vw+uv,tD=vv)),tN<0?(tN=0,-uw<0?sN=0:-uw>uu?sN=sD:(sN=-uw,sD=uu)):tN>tD&&(tN=tD=1,-uw+uv<0?sN=0:-uw+uv>uu?sN=sD:(sN=-uw+uv,sD=uu));const parab_=Math.abs(sN)<GeomConstants.tolerance?0:sN/sD,parcd_=Math.abs(tN)<GeomConstants.tolerance?0:tN/tD;return{parab:parab_,parcd:parcd_,dist:w.add(u.mul(parab_).sub(v.mul(parcd_))).length}}}class ParallelogramNode{static distToSegm(p,s,e){const l=e.sub(s);if(l.length<GeomConstants.intersectionEpsilon)return p.sub(s.add(e).div(2)).length;let perp=new point_Point(-l.y,l.x);return perp=perp.mul(1/perp.length),Math.abs(p.sub(s).dot(perp))}static createParallelogramOnSubSeg(start,end,seg){let tan1=seg.derivative(start);const tan2=seg.derivative(end),tan2Perp=new point_Point(-tan2.y,tan2.x),corner=seg.value(start),e=seg.value(end),numerator=e.sub(corner).dot(tan2Perp),denumerator=tan1.dot(tan2Perp),numeratorTiny=Math.abs(numerator)<GeomConstants.distanceEpsilon;if(!numeratorTiny&&Math.abs(denumerator)<GeomConstants.distanceEpsilon)return;const x=numeratorTiny?0:numerator/denumerator;return tan1=tan1.mul(x),Parallelogram.parallelogramByCornerSideSide(corner,tan1,e.sub(corner).sub(tan1))}static createParallelogramNodeForCurveSeg(start,end,seg,eps){if(start==seg.parStart&&end==seg.parEnd&&point_Point.close(seg.start,seg.end,GeomConstants.distanceEpsilon))return ParallelogramNode.createNodeWithSegmentSplit(start,end,seg,eps);const s=seg.value(start),e=seg.value(end),w=e.sub(s),middle=seg.value((start+end)/2);if(ParallelogramNode.distToSegm(middle,s,e)<=GeomConstants.intersectionEpsilon&&w.dot(w)<GeomConstants.lineSegmentThreshold*GeomConstants.lineSegmentThreshold&&end-start<GeomConstants.lineSegmentThreshold){const ls=LineSegment.mkPP(s,e),pn=ls.pNodeOverICurve();pn.seg=seg;const leaf=pn.node;return leaf.low=start,leaf.high=end,leaf.chord=ls,pn}if(ParallelogramNode.WithinEpsilon(seg,start,end,eps)){const box=ParallelogramNode.createParallelogramOnSubSeg(start,end,seg);if(null!=box)return function createPNLeaf(start,end,box,seg,eps){return{parallelogram:box,seg:seg,leafBoxesOffset:eps,node:{low:start,high:end,chord:null}}}(start,end,box,seg,eps)}return ParallelogramNode.createNodeWithSegmentSplit(start,end,seg,eps)}static WithinEpsilon(seg,start,end,eps){const d=(end-start)/3,s=seg.value(start),e=seg.value(end);if(ParallelogramNode.distToSegm(seg.value(start+d),s,e)>eps)return!1;return ParallelogramNode.distToSegm(seg.value(start+2*d),s,e)<=eps}static createParallelogramNodeForCurveSegDefaultOffset(seg){return ParallelogramNode.createParallelogramNodeForCurveSeg(seg.parStart,seg.parEnd,seg,GeomConstants.defaultLeafBoxesOffset)}static createNodeWithSegmentSplit(start,end,ell,eps){const pBNode={parallelogram:null,seg:ell,leafBoxesOffset:1,node:{children:[]}},intNode=pBNode.node;return intNode.children.push(ParallelogramNode.createParallelogramNodeForCurveSeg(start,.5*(start+end),ell,eps)),intNode.children.push(ParallelogramNode.createParallelogramNodeForCurveSeg(.5*(start+end),end,ell,eps)),pBNode.parallelogram=Parallelogram.parallelogramOfTwo(intNode.children[0].parallelogram,intNode.children[1].parallelogram),pBNode}}class IntersectionInfo{constructor(pr0,pr1,x,s0,s1){this.par0=pr0,this.par1=pr1,this.x=x,this.seg0=s0,this.seg1=s1}}class ClosestPointOnCurve{static closestPoint(curve,a,hint,low,high){let dt,t=hint,numberOfIteration=0,numberOfOvershoots=0,abort=!1;do{const c=curve.value(t),ct=curve.derivative(t),ctt=curve.secondDerivative(t),secondDerivative=ct.dot(ct)+c.sub(a).dot(ctt);if(Math.abs(secondDerivative)<GeomConstants.tolerance)return t;dt=c.sub(a).dot(ct.div(secondDerivative)),t-=dt,t>high+GeomConstants.tolerance?(t=high,numberOfOvershoots++):t<low-GeomConstants.tolerance&&(t=low,numberOfOvershoots++),numberOfIteration++}while(Math.abs(dt)>GeomConstants.tolerance&&!(abort=numberOfIteration>=5||numberOfOvershoots>=5));return abort&&curve.value(hint).sub(a).length<GeomConstants.distanceEpsilon&&(t=hint),t}}class Ellipse{constructor(parStart,parEnd,axis0,axis1,center){this.parStart=parStart,this.parEnd=parEnd,this.aAxis=axis0,this.bAxis=axis1,this.center=center,this.pNode=null,this.setBoundingBox()}offsetCurve(offset,dir){const d=dir.sub(this.center),angle=point_Point.angle(this.aAxis,d);if(this.aAxis.mul(Math.cos(angle)).add(this.bAxis.mul(Math.sin(angle))).length<d.length){const al=this.aAxis.length,bl=this.bAxis.length;return Ellipse.mkEllipsePPP(this.aAxis.normalize().mul(al+offset),this.bAxis.normalize().mul(bl+offset),this.center)}{const al=this.aAxis.length,bl=this.bAxis.length;return Ellipse.mkEllipsePPP(this.aAxis.normalize().mul(al-offset),this.bAxis.normalize().mul(bl-offset),this.center)}}reverse(){return null}static mkEllipsePPP(a,b,center){return new Ellipse(0,2*Math.PI,a,b,center)}get start(){return this.value(this.parStart)}get end(){return this.value(this.parEnd)}trim(start,end){return new Ellipse(Math.max(start,this.parStart),Math.min(end,this.parEnd),this.aAxis,this.bAxis,this.center)}trimWithWrap(start,end){return null}get boundingBox(){return this.box}value(t){return this.center.add(point_Point.mkPoint(Math.cos(t),this.aAxis,Math.sin(t),this.bAxis))}derivative(t){return point_Point.mkPoint(-Math.sin(t),this.aAxis,Math.cos(t),this.bAxis)}secondDerivative(t){return point_Point.mkPoint(-Math.cos(t),this.aAxis,-Math.sin(t),this.bAxis)}thirdDerivative(t){return point_Point.mkPoint(Math.sin(t),this.aAxis,-Math.cos(t),this.bAxis)}pNodeOverICurve(){return null!=this.pNode?this.pNode:this.pNode=ParallelogramNode.createParallelogramNodeForCurveSegDefaultOffset(this)}setBoundingBox(){if(closeDistEps(this.parStart,0)&&closeDistEps(this.parEnd,2*Math.PI))this.box=this.fullBox();else{let t;this.box=Rectangle.mkPP(this.start,this.end);for(let i=Math.ceil(this.parStart/(Math.PI/2));(t=i*Math.PI/2)<this.parEnd;i++)t>this.parStart&&this.box.add(this.value(t))}}static mkEllipse(parStart,parEnd,axis0,axis1,centerX,centerY){return new Ellipse(parStart,parEnd,axis0,axis1,new point_Point(centerX,centerY))}static mkFullEllipsePPP(axis0,axis1,center){return new Ellipse(0,2*Math.PI,axis0,axis1,center)}static mkFullEllipseNNP(axisA,axisB,center){return new Ellipse(0,2*Math.PI,new point_Point(axisA,0),new point_Point(0,axisB),center)}static mkCircle(radius,center){return Ellipse.mkFullEllipseNNP(radius,radius,center)}translate(delta){this.center=this.center.add(delta),this.box.center=this.box.center.add(delta),this.pNode=null}scaleFromOrigin(xScale,yScale){return new Ellipse(this.parStart,this.parEnd,this.aAxis.mul(xScale),this.bAxis.mul(yScale),this.center.scale(xScale,yScale))}getParameterAtLength(length){let l=this.parStart,u=this.parEnd;const lenplus=length+.001,lenminsu=length-.001;for(;u-l>GeomConstants.distanceEpsilon;){const m=.5*(u+l),len=this.lengthPartial(this.parStart,m);if(len>lenplus)u=m;else{if(!(len<lenminsu))return m;l=m}}return(u+l)/2}transform(transformation){if(null!=transformation){const ap=transformation.multiplyPoint(this.aAxis).sub(transformation.offset()),bp=transformation.multiplyPoint(this.bAxis).sub(transformation.offset());return new Ellipse(this.parStart,this.parEnd,ap,bp,transformation.multiplyPoint(this.center))}return this}closestParameterWithinBounds(targetPoint,low,high){const t=(high-low)/9;let closest=low,minDist=Number.MAX_VALUE;for(let i=0;i<=8;i++){const par=low+i*t,p=targetPoint.sub(this.value(par)),d=p.dot(p);d<minDist&&(minDist=d,closest=par)}0==closest&&high==2*Math.PI&&(low=-Math.PI);let ret=ClosestPointOnCurve.closestPoint(this,targetPoint,closest,low,high);return ret<0&&(ret+=2*Math.PI),ret}lengthPartial(start,end){return Curve.lengthWithInterpolationAndThreshold(this.trim(start,end),GeomConstants.lineSegmentThreshold/100)}get length(){return Curve.lengthWithInterpolation(this)}clone(){return new Ellipse(this.parStart,this.parEnd,this.aAxis.clone(),this.bAxis.clone(),this.center.clone())}closestParameter(targetPoint){let savedParStart=0;const t=(this.parEnd-this.parStart)/9;let closest=this.parStart,minDist=Number.MAX_VALUE;for(let i=0;i<=8;i++){const par=this.parStart+i*t,p=targetPoint.sub(this.value(par)),d=p.dot(p);d<minDist&&(minDist=d,closest=par)}let parStartWasChanged=!1;0==closest&&this.parEnd==2*Math.PI&&(parStartWasChanged=!0,savedParStart=this.parStart,this.parStart=-Math.PI);let ret=ClosestPointOnCurve.closestPoint(this,targetPoint,closest,this.parStart,this.parEnd);return ret<0&&(ret+=2*Math.PI),parStartWasChanged&&(this.parStart=savedParStart),ret}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}curvature(t){throw"NotImplementedException()"}curvatureDerivative(t){throw"NotImplementedException();"}curvatureSecondDerivative(t){throw"NotImplementedException()"}orientedCounterclockwise(){return point_Point.crossProduct(this.aAxis,this.bAxis)>0}fullBox(){const del=this.aAxis.add(this.bAxis);return Rectangle.mkPP(this.center.add(del),this.center.sub(del))}isArc(){return Math.abs(this.aAxis.dot(this.bAxis))<GeomConstants.tolerance&&Math.abs(this.aAxis.length-this.bAxis.length)<GeomConstants.tolerance&&point_Point.closeDistEps(this.aAxis.rotate90Ccw(),this.bAxis)}}class MinDistCurveCurve{constructor(curveA,curveB,aMin,aMax,bMin,mBax,aGuess,bGuess){this.curveA=curveA,this.curveB=curveB,this.aMin=aMin,this.bMin=bMin,this.aMax=aMax,this.bMax=mBax,this.aGuess=aGuess,this.bGuess=bGuess,this.si=aGuess,this.ti=bGuess}initValues(){this.a=this.curveA.value(this.si),this.b=this.curveB.value(this.ti),this.a_b=this.a.sub(this.b),this.ad=this.curveA.derivative(this.si),this.add=this.curveA.secondDerivative(this.si),this.bd=this.curveB.derivative(this.ti),this.bdd=this.curveB.secondDerivative(this.ti)}Fs(){return this.a_b.dot(this.ad)}Fss(){return this.a_b.dot(this.add)+this.ad.dot(this.ad)}Fst(){return-this.bd.dot(this.ad)}Ftt(){return-this.a_b.dot(this.bdd)+this.bd.dot(this.bd)}Ft(){return-this.a_b.dot(this.bd)}delta(x,y,u,w){return x*w-u*y}solve(){let numberOfBoundaryCrossings=0;let numberOfTotalReps=0;let d,abort=!1;if(this.initValues(),this.curveA instanceof LineSegment&&this.curveB instanceof LineSegment){let bd1=this.curveB.derivative(0);bd1=bd1.div(bd1.length);const an=this.curveA.normal(),del=Math.abs(an.dot(bd1));if(Math.abs(del)<GeomConstants.distanceEpsilon||this.delta(this.Fss(),this.Fst(),this.Fst(),this.Ftt())<GeomConstants.tolerance)return this.success=!0,void this.parallelLineSegLineSegMinDist()}do{const delta=this.delta(this.Fss(),this.Fst(),this.Fst(),this.Ftt());if(Math.abs(delta)<GeomConstants.tolerance){this.success=!1,abort=!0;break}d={s:this.delta(-this.Fs(),this.Fst(),-this.Ft(),this.Ftt())/delta,t:this.delta(this.Fss(),-this.Fs(),this.Fst(),-this.Ft())/delta};const nsi=this.si+d.s,nti=this.ti+d.t;let bc;nsi>this.aMax+GeomConstants.distanceEpsilon||nsi<this.aMin-GeomConstants.distanceEpsilon||nti>this.bMax+GeomConstants.distanceEpsilon||nti<this.bMin-GeomConstants.distanceEpsilon?(numberOfBoundaryCrossings++,this.chopDsDt(d),this.si+=d.s,this.ti+=d.t,bc=!0):(bc=!1,this.si=nsi,this.ti=nti,this.si>this.aMax?this.si=this.aMax:this.si<this.aMin&&(this.si=this.aMin),this.ti>this.bMax?this.ti=this.bMax:this.ti<this.bMin&&(this.ti=this.bMin)),this.initValues(),numberOfTotalReps++,abort=numberOfBoundaryCrossings>=10||numberOfTotalReps>=100||0==d.s&&0==d.t&&bc}while((Math.abs(d.s)>=GeomConstants.tolerance||Math.abs(d.t)>=GeomConstants.tolerance)&&!abort);if(abort){const t=this.curveA.value(this.aGuess).sub(this.curveB.value(this.bGuess));if(t.dot(t)<GeomConstants.distanceEpsilon*GeomConstants.distanceEpsilon)return this.aSolution=this.aGuess,this.bSolution=this.bGuess,this.aPoint=this.curveA.value(this.aGuess),this.bPoint=this.curveB.value(this.bGuess),void(this.success=!0)}this.aSolution=this.si,this.bSolution=this.ti,this.aPoint=this.a,this.bPoint=this.b,this.success=!abort}chopDsDt(d){if(0!=d.s&&0!=d.t){let k1=1;this.si+d.s>this.aMax?k1=(this.aMax-this.si)/d.s:this.si+d.s<this.aMin&&(k1=(this.aMin-this.si)/d.s);let k2=1;this.ti+d.t>this.bMax?k2=(this.bMax-this.ti)/d.t:this.ti+d.t<this.bMin&&(k2=(this.bMin-this.ti)/d.t);const k=Math.min(k1,k2);d.s*=k,d.t*=k}else 0==d.s?this.ti+d.t>this.bMax?d.t=this.bMax-this.ti:this.ti+d.t<this.bMin&&(d.t=this.bMin-this.ti):this.si+d.s>this.aMax?d.s=this.aMax-this.si:this.si+d.s<this.aMin&&(d.s=this.aMin-this.si)}parallelLineSegLineSegMinDist(){const l0=this.curveA,l1=this.curveB,v0=l0.start,v1=l0.end,v2=l1.start,v3=l1.end;let d0=v1.sub(v0);const nd0=d0.length;let r1,r2,r3,r0=0;if(nd0>GeomConstants.distanceEpsilon){d0=d0.div(nd0),r1=d0.dot(v1.sub(v0)),r2=d0.dot(v2.sub(v0)),r3=d0.dot(v3.sub(v0));let swapped=!1;if(r2>r3){swapped=!0;const t=r2;r2=r3,r3=t}if(r3<r0)this.aSolution=0,this.bSolution=swapped?0:1;else if(r2>r1)this.aSolution=1,this.bSolution=swapped?1:0;else{const r=Math.min(r1,r3);this.aSolution=r/(r1-r0),this.bSolution=(r-r2)/(r3-r2),swapped&&(this.bSolution=1-this.bSolution)}}else{let d1=v3.sub(v2);const nd1=d1.length;if(nd1>GeomConstants.distanceEpsilon)if(d1=d1.div(nd1),r0=0,r1=d1.dot(v3.sub(v2)),r2=d1.dot(v0.sub(v2)),r2<r0)this.bSolution=0,this.aSolution=1;else if(r2>r1)this.bSolution=1,this.aSolution=0;else{const r=Math.min(r1,r2);this.bSolution=r/(r1-r0),this.aSolution=0}else this.aSolution=0,this.bSolution=0}this.aPoint=this.curveA.value(this.aSolution),this.bPoint=this.curveB.value(this.bSolution)}}class BezierSeg{constructor(b0,b1,b2,b3){this.b=new Array(4),this.parStart=0,this.parEnd=1,this.b[0]=b0,this.b[1]=b1,this.b[2]=b2,this.b[3]=b3,this.c=this.b[1].sub(this.b[0]).mul(3),this.e=this.b[2].sub(this.b[1]).mul(3).sub(this.c),this.l=this.b[3].sub(this.b[0]).sub(this.c).sub(this.e)}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}B(controlPointIndex){return this.b[controlPointIndex]}pNodeOverICurve(){return null!=this.pBoxNode?this.pBoxNode:this.pBoxNode=ParallelogramNode.createParallelogramNodeForCurveSegDefaultOffset(this)}value(t){const t2=t*t,t3=t2*t;return this.l.mul(t3).add(this.e.mul(t2).add(this.c.mul(t)).add(this.b[0]))}static adjustParamTo01(u){return u>1?1:u<0?0:u}trim(u,v){if((u=BezierSeg.adjustParamTo01(u))>(v=BezierSeg.adjustParamTo01(v)))return this.trim(v,u);if(u>1-GeomConstants.tolerance)return new BezierSeg(this.b[3],this.b[3],this.b[3],this.b[3]);const b1=new Array(3),b2=new Array(2),pv=this.casteljau(u,b1,b2),trimByU=new BezierSeg(pv,b2[1],b1[2],this.b[3]),pu=trimByU.casteljau((v-u)/(1-u),b1,b2);return new BezierSeg(trimByU.b[0],b1[0],b2[0],pu)}trimWithWrap(start,end){throw"NotImplementedException()"}casteljau(t,b1,b2){const f=1-t;for(let i=0;i<3;i++)b1[i]=point_Point.mkPoint(f,this.b[i],t,this.b[i+1]);for(let i=0;i<2;i++)b2[i]=point_Point.mkPoint(f,b1[i],t,b1[i+1]);return point_Point.mkPoint(f,b2[0],t,b2[1])}derivative(t){return this.l.mul(3*t*t).add(this.e.mul(2*t)).add(this.c)}secondDerivative(t){return point_Point.mkPoint(6*t,this.l,2,this.e)}thirdDerivative(t){return this.l.mul(6)}get start(){return this.b[0]}get end(){return this.b[3]}reverse(){return new BezierSeg(this.b[3],this.b[2],this.b[1],this.b[0])}translate(delta){this.b[0]=this.b[0].add(delta),this.b[1]=this.b[1].add(delta),this.b[2]=this.b[2].add(delta),this.b[3]=this.b[3].add(delta),this.c=this.b[1].sub(this.b[0]).mul(3),this.e=this.b[2].sub(this.b[1]).mul(3).sub(this.c),this.l=this.b[3].sub(this.b[0]).sub(this.c).sub(this.e),this.pBoxNode=null}scaleFromOrigin(xScale,yScale){return new BezierSeg(this.b[0].scale(xScale,yScale),this.b[1].scale(xScale,yScale),this.b[2].scale(xScale,yScale),this.b[3].scale(xScale,yScale))}offsetCurve(offset,dir){return null}lengthPartial(start,end){return this.trim(start,end).length}get length(){return BezierSeg.lengthOnControlPolygon(this.b[0],this.b[1],this.b[2],this.b[3])}static lengthOnControlPolygon(b0,b1,b2,b3){const innerCordLength=b3.sub(b0).length,controlPointPolygonLength=b1.sub(b0).length+b2.sub(b1).length+b3.sub(b2).length;if(controlPointPolygonLength-innerCordLength>GeomConstants.lineSegmentThreshold){const mb0=point_Point.middle(b0,b1),mb1=point_Point.middle(b1,b2),mb2=point_Point.middle(b2,b3),mmb0=point_Point.middle(mb0,mb1),mmb1=point_Point.middle(mb2,mb1),mmmb0=point_Point.middle(mmb0,mmb1);return BezierSeg.lengthOnControlPolygon(b0,mb0,mmb0,mmmb0)+BezierSeg.lengthOnControlPolygon(mmmb0,mmb1,mb2,b3)}return(controlPointPolygonLength+innerCordLength)/2}get boundingBox(){const ret=Rectangle.mkPP(this.b[0],this.b[1]);return ret.add(this.b[2]),ret.add(this.b[3]),ret}transform(transformation){return new BezierSeg(transformation.multiplyPoint(this.b[0]),transformation.multiplyPoint(this.b[1]),transformation.multiplyPoint(this.b[2]),transformation.multiplyPoint(this.b[3]))}closestParameterWithinBounds(targetPoint,low,high){const t=(high-low)/8;let closest=0,minDist=Number.MAX_VALUE;for(let i=0;i<9;i++){const p=targetPoint.sub(this.value(i*t+low)),d=p.dot(p);d<minDist&&(minDist=d,closest=i*t+low)}return ClosestPointOnCurve.closestPoint(this,targetPoint,closest,low,high)}clone(){return new BezierSeg(this.b[0],this.b[1],this.b[2],this.b[3])}static mkBezier(b){return new BezierSeg(b[0],b[1],b[2],b[3])}curvature(t){const den=this.G(t);return this.F(t)/den}F(t){return this.Xp(t)*this.Ypp(t)-this.Yp(t)*this.Xpp(t)}G(t){const xp=this.Xp(t),yp=this.Yp(t),den=xp*xp+yp*yp;return Math.sqrt(den*den*den)}Xp(t){return 3*this.l.x*t*t+2*this.e.x*t+this.c.x}Ypp(t){return 6*this.l.y*t+2*this.e.y}Yp(t){return 3*this.l.y*t*t+2*this.e.y*t+this.c.y}Xpp(t){return 6*this.l.x*t+2*this.e.x}Xppp(t){return 6*this.l.x}Yppp(t){return 6*this.l.y}curvatureDerivative(t){const h=this.G(t);return(this.Fp(t)*h-this.Gp(t)*this.F(t))/(h*h)}Fp(t){return this.Xp(t)*this.Yppp(t)-this.Yp(t)*this.Xppp(t)}Fpp(t){return this.Xpp(t)*this.Yppp(t)-this.Ypp(t)*this.Xppp(t)}closestParameter(targetPoint){const t=1/8;let closest=0,minDist=Number.MAX_VALUE;for(let i=0;i<9;i++){const p=targetPoint.sub(this.value(i*t)),d=p.dot(p);d<minDist&&(minDist=d,closest=i*t)}return ClosestPointOnCurve.closestPoint(this,targetPoint,closest,0,1)}curvatureSecondDerivative(t){const g=this.G(t);return(this.Qp(t)*g-2*this.Q(t)*this.Gp(t))/(g*g*g)}Q(t){return this.Fp(t)*this.G(t)-this.Gp(t)*this.F(t)}Qp(t){return this.Fpp(t)*this.G(t)-this.Gpp(t)*this.F(t)}Gpp(t){const xp=this.Xp(t),yp=this.Yp(t),xpp=this.Xpp(t),ypp=this.Ypp(t),xppp=this.Xppp(t),yppp=this.Yppp(t),u=Math.sqrt(xp*xp+yp*yp),v=xp*xpp+yp*ypp;return 3*(v*v/u+u*(xpp*xpp+xp*xppp+ypp*ypp+yp*yppp))}Gp(t){const xp=this.Xp(t),yp=this.Yp(t),xpp=this.Xpp(t),ypp=this.Ypp(t);return 3*Math.sqrt(xp*xp+yp*yp)*(xp*xpp+yp*ypp)}getParameterAtLength(length){let low=0,upper=1;for(;upper-low>GeomConstants.tolerance;){const middle=(upper+low)/2,err=this.evaluateError(length,middle);if(err>0)upper=middle;else{if(!(err<0))return middle;low=middle}}return(low+upper)/2}evaluateError(length,t){const f=1-t,mb0=point_Point.mkPoint(f,this.b[0],t,this.b[1]),mb1=point_Point.mkPoint(f,this.b[1],t,this.b[2]),mb2=point_Point.mkPoint(f,this.b[2],t,this.b[3]),mmb0=point_Point.mkPoint(f,mb0,t,mb1),mmb1=point_Point.mkPoint(f,mb1,t,mb2),mmmb0=point_Point.mkPoint(f,mmb0,t,mmb1),lengthAtT=BezierSeg.lengthOnControlPolygon(this.b[0],mb0,mmb0,mmmb0);return lengthAtT>length+GeomConstants.distanceEpsilon?1:lengthAtT<length-GeomConstants.distanceEpsilon?-1:0}}!function(PointLocation){PointLocation[PointLocation.Outside=0]="Outside",PointLocation[PointLocation.Boundary=1]="Boundary",PointLocation[PointLocation.Inside=2]="Inside"}(PointLocation||(PointLocation={}));class Curve{constructor(){this.segs=[],this.parEnd_=0}static CurvesIntersect(curve1,curve2){return curve1==curve2||null!=Curve.intersectionOne(curve1,curve2,!1)}static lengthWithInterpolationAndThreshold(_seg,_eps){throw new Error("not implemented")}static lengthWithInterpolation(_seg){throw"not implemented"}get parStart(){return 0}get parEnd(){return this.parEnd_}lengthPartial(start,end){const params={start:start,end:end};this.adjustStartEndEndParametersToDomain(params);const si=this.getSegIndexParam(start),ej=this.getSegIndexParam(end);if(si.segIndex<ej.segIndex){let seg=this.segs[si.segIndex],ret=seg.lengthPartial(si.par,seg.parEnd);for(let k=si.segIndex+1;k<ej.segIndex;k++)ret+=this.segs[k].length;return seg=this.segs[ej.segIndex],ret+seg.lengthPartial(seg.parStart,ej.par)}throw new Error("not implemented.")}reverse(){const ret=new Curve;for(let i=this.segs.length-1;i>=0;i--)ret.addSegment(this.segs[i].reverse());return ret}mkCurveWithSegs(segs){this.segs=segs;for(const s of segs)this.parEnd_+=Curve.paramSpan(s)}get start(){return this.segs[0].start}get end(){return this.segs[this.segs.length-1].end}scaleFromOrigin(xScale,yScale){const c=new Curve;for(const s of this.segs)c.addSegment(s.scaleFromOrigin(xScale,yScale));return c}trim(start,end){const params={start:start,end:end};this.adjustStartEndEndParametersToDomain(params);const s=this.getSegIndexParam(params.start),e=this.getSegIndexParam(params.end);if(s.segIndex==e.segIndex)return this.segs[s.segIndex].trim(s.par,e.par);let c=new Curve;s.par<this.segs[s.segIndex].parEnd&&(c=c.addSegment(this.segs[s.segIndex].trim(s.par,this.segs[s.segIndex].parEnd)));for(let i=s.segIndex+1;i<e.segIndex;i++)c=c.addSegment(this.segs[i]);return this.segs[e.segIndex].parStart<e.par&&(c=c.addSegment(this.segs[e.segIndex].trim(this.segs[e.segIndex].parStart,e.par))),c}translate(delta){for(const s of this.segs)s.translate(delta);this.pBNode=null}adjustStartEndEndParametersToDomain(params){if(params.start>params.end){const t=params.start;params.start=params.end,params.end=t}params.start<this.parStart&&(params.start=this.parStart),params.end>this.parEnd&&(params.end=this.parEnd)}trimWithWrap(start,end){if(start<end)return this.trim(start,end);const c=new Curve;return c.addSegment(this.trim(start,this.parEnd)),c.addSegment(this.trim(this.parStart,end)),c}addSegs(segs){for(const s of segs)this.addSegment(s);return this}addSegment(curve){if(null==curve)return this;if(curve instanceof Curve)for(const cc of curve.segs)this.segs.push(cc),this.parEnd_+=Curve.paramSpan(cc);else this.segs.push(curve),this.parEnd_+=Curve.paramSpan(curve);return this}pNodeOverICurve(){if(null!=this.pBNode)return this.pBNode;const parallelograms=[],childrenNodes=[];for(const curveSeg of this.segs){const pBoxNode=curveSeg.pNodeOverICurve();parallelograms.push(pBoxNode.parallelogram),childrenNodes.push(pBoxNode)}return this.pBNode={parallelogram:Parallelogram.getParallelogramOfAGroup(parallelograms),seg:this,leafBoxesOffset:GeomConstants.defaultLeafBoxesOffset,node:{children:childrenNodes}},this.pBNode}static intersectionOne(curve0,curve1,liftIntersection){let ret=Curve.curveCurveXWithParallelogramNodesOne(curve0.pNodeOverICurve(),curve1.pNodeOverICurve());return liftIntersection&&null!=ret&&(ret=Curve.liftIntersectionToCurves(curve0,curve1,ret)),ret}static getAllIntersections(curve0,curve1,liftIntersections){return curve0 instanceof LineSegment?Curve.getAllIntersectionsOfLineAndICurve(curve0,curve1,liftIntersections):Curve.getAllIntersectionsInternal(curve0,curve1,liftIntersections)}static getAllIntersectionsInternal(curve0,curve1,liftIntersections){const intersections=[];if(Curve.curveCurveXWithParallelogramNodes(curve0.pNodeOverICurve(),curve1.pNodeOverICurve(),intersections),liftIntersections)for(let i=0;i<intersections.length;i++)intersections[i]=Curve.liftIntersectionToCurves(curve0,curve1,intersections[i]);return intersections}static getAllIntersectionsOfLineAndICurve(lineSeg,iCurve,liftIntersections){return iCurve instanceof Polyline?Curve.getAllIntersectionsOfLineAndPolyline(lineSeg,iCurve):iCurve instanceof Curve?Curve.getAllIntersectionsOfLineAndCurve(lineSeg,iCurve,liftIntersections):iCurve instanceof Ellipse&&iCurve.isArc()?Curve.getAllIntersectionsOfLineAndArc(lineSeg,iCurve):Curve.getAllIntersectionsInternal(lineSeg,iCurve,liftIntersections)}static getAllIntersectionsOfLineAndCurve(lineSeg,curve,liftIntersections){const ret=[],lineParallelogram=lineSeg.pNodeOverICurve(),curveParallelogramRoot=curve.pNodeOverICurve();if(0==Parallelogram.intersect(lineParallelogram.parallelogram,curveParallelogramRoot.parallelogram))return ret;let parOffset=0;for(const seg of curve.segs){const iiList=Curve.getAllIntersections(lineSeg,seg,!1);if(liftIntersections){for(const intersectionInfo of iiList)intersectionInfo.par1+=parOffset-seg.parStart,intersectionInfo.seg1=curve;parOffset+=seg.parEnd-seg.parStart}for(const intersectionInfo of iiList)Curve.alreadyInside(ret,intersectionInfo)||ret.push(intersectionInfo)}return ret}static closeIntersections(x,y){return point_Point.close(x.x,y.x,GeomConstants.intersectionEpsilon)}static closeIntersectionPoints(x,y){return point_Point.close(x,y,GeomConstants.intersectionEpsilon)}static alreadyInside(ret,intersectionInfo){for(let i=0;i<ret.length;i++){const ii=ret[i];if(Curve.closeIntersections(ii,intersectionInfo))return!0}return!1}static getAllIntersectionsOfLineAndArc(lineSeg,ellipse){let lineDir=lineSeg.end.sub(lineSeg.start);const ret=[],segLength=lineDir.length;if(segLength<GeomConstants.distanceEpsilon){const lsStartMinCen=lineSeg.start.sub(ellipse.center);if(closeDistEps(lsStartMinCen.length,ellipse.aAxis.length)){let angle=point_Point.angle(ellipse.aAxis,lsStartMinCen);ellipse.parStart-GeomConstants.tolerance<=angle&&(angle=Math.max(angle,ellipse.parStart),angle<=ellipse.parEnd+GeomConstants.tolerance&&(angle=Math.min(ellipse.parEnd,angle),ret.push(new IntersectionInfo(0,angle,lineSeg.start,lineSeg,ellipse))))}return ret}const perp=lineDir.rotate90Ccw().div(segLength),segProjection=lineSeg.start.sub(ellipse.center).dot(perp),closestPointOnLine=ellipse.center.add(perp.mul(segProjection)),rad=ellipse.aAxis.length,absSegProj=Math.abs(segProjection);if(rad<absSegProj-GeomConstants.distanceEpsilon)return ret;if(lineDir=perp.rotate90Cw(),closeDistEps(rad,absSegProj))Curve.tryToAddPointToLineCircleCrossing(lineSeg,ellipse,ret,closestPointOnLine,segLength,lineDir);else{const otherLeg=Math.sqrt(rad*rad-segProjection*segProjection),d=lineDir.mul(otherLeg);Curve.tryToAddPointToLineCircleCrossing(lineSeg,ellipse,ret,closestPointOnLine.add(d),segLength,lineDir),Curve.tryToAddPointToLineCircleCrossing(lineSeg,ellipse,ret,closestPointOnLine.sub(d),segLength,lineDir)}return ret}static tryToAddPointToLineCircleCrossing(lineSeg,ellipse,ret,point,segLength,lineDir){let t=point.sub(lineSeg.start).dot(lineDir);if(t<-GeomConstants.distanceEpsilon)return;if(t=Math.max(t,0),t>segLength+GeomConstants.distanceEpsilon)return;t=Math.min(t,segLength),t/=segLength;let angle=point_Point.angle(ellipse.aAxis,point.sub(ellipse.center));ellipse.parStart-GeomConstants.tolerance<=angle&&(angle=Math.max(angle,ellipse.parStart),angle<=ellipse.parEnd+GeomConstants.tolerance&&(angle=Math.min(ellipse.parEnd,angle),ret.push(new IntersectionInfo(t,angle,point,lineSeg,ellipse))))}static getAllIntersectionsOfLineAndPolyline(lineSeg,poly){const ret=[];let offset=0,polyPoint=poly.startPoint;for(;null!=polyPoint&&null!=polyPoint.getNext();polyPoint=polyPoint.getNext()){const sol=Curve.crossTwoLineSegs(lineSeg.start,lineSeg.end,polyPoint.point,polyPoint.getNext().point,0,1,0,1);null!=sol&&(Curve.adjustSolution(lineSeg.start,lineSeg.end,polyPoint.point,polyPoint.getNext().point,sol),Curve.oldIntersection(ret,sol.x)||ret.push(new IntersectionInfo(sol.aSol,offset+sol.bSol,sol.x,lineSeg,poly))),offset++}if(poly.closed){const sol=Curve.crossTwoLineSegs(lineSeg.start,lineSeg.end,polyPoint.point,poly.start,0,1,0,1);null!=sol&&(Curve.adjustSolution(lineSeg.start,lineSeg.end,polyPoint.point,poly.start,sol),Curve.oldIntersection(ret,sol.x)||ret.push(new IntersectionInfo(sol.aSol,offset+sol.bSol,sol.x,lineSeg,poly)))}return ret}static adjustSolution(aStart,aEnd,bStart,bEnd,sol){Curve.closeIntersectionPoints(sol.x,aStart)?(sol.x=aStart,sol.aSol=0):Curve.closeIntersectionPoints(sol.x,aEnd)&&(sol.x=aEnd,sol.aSol=1),Curve.closeIntersectionPoints(sol.x,bStart)?(sol.x=bStart,sol.bSol=Math.floor(sol.bSol)):Curve.closeIntersectionPoints(sol.x,bEnd)&&(sol.x=bEnd,sol.bSol=Math.ceil(sol.bSol))}static curveCurveXWithParallelogramNodesOne(n0,n1){if(!Parallelogram.intersect(n0.parallelogram,n1.parallelogram))return null;const n0Pb=n0.node,n1Pb=n1.node,n0Internal=n0Pb.hasOwnProperty("children"),n1Internal=n1Pb.hasOwnProperty("children");if(n0Internal&&n1Internal)for(const n00 of n0Pb.children)for(const n11 of n1Pb.children){const x=Curve.curveCurveXWithParallelogramNodesOne(n00,n11);if(null!=x)return x}else if(n1Internal)for(const n of n1Pb.children){const x=Curve.curveCurveXWithParallelogramNodesOne(n0,n);if(null!=x)return x}else{if(!n0Internal)return Curve.crossOverIntervalsOne(n0,n1);for(const n of n0Pb.children){const x=Curve.curveCurveXWithParallelogramNodesOne(n,n1);if(null!=x)return x}}return null}static curveCurveXWithParallelogramNodes(n0,n1,intersections){if(!Parallelogram.intersect(n0.parallelogram,n1.parallelogram))return;const isInternal0=n0.node.hasOwnProperty("children"),isInternal1=n1.node.hasOwnProperty("children");if(isInternal0&&isInternal1)for(const n00 of n0.node.children)for(const n11 of n1.node.children)Curve.curveCurveXWithParallelogramNodes(n00,n11,intersections);else if(isInternal1)for(const n of n1.node.children)Curve.curveCurveXWithParallelogramNodes(n0,n,intersections);else if(isInternal0)for(const n of n0.node.children)Curve.curveCurveXWithParallelogramNodes(n,n1,intersections);else intersections=Curve.crossOverLeaves(n0,n1,intersections)}static crossOverIntervalsOne(n0,n1){const l0=n0.node,l1=n1.node,d0=(l0.high-l0.low)/2,d1=(l1.high-l1.low)/2;for(let i=1;i<2;i++){const p0=i*d0+l0.low;for(let j=1;j<2;j++){const p1=j*d1+l1.low;let sol;if(null==l0.chord&&null==l1.chord?sol=Curve.crossWithinIntervalsWithGuess(n0.seg,n1.seg,l0.low,l0.high,l1.low,l1.high,p0,p1):null!=l0.chord&&null==l1.chord?sol=Curve.crossWithinIntervalsWithGuess(l0.chord,n1.seg,0,1,l1.low,l1.high,.5*i,p1):null==l0.chord?(sol=Curve.crossWithinIntervalsWithGuess(n0.seg,l1.chord,l0.low,l0.high,0,1,p0,.5*j),null!=sol&&(sol.bSol=l1.low+sol.bSol*(l1.high-l1.low))):(sol=Curve.crossWithinIntervalsWithGuess(l0.chord,l1.chord,0,1,0,1,.5*i,.5*j),null!=sol&&(sol.aSol=l0.low+sol.aSol*(l0.high-l0.low),sol.bSol=l1.low+sol.bSol*(l1.high-l1.low))),null!=sol)return Curve.createIntersectionOne(n0,n1,sol.aSol,sol.bSol,sol.x)}}return Curve.goDeeperOne(n0,n1)}static crossOverLeaves(n0,n1,intersections){const l0=n0.node,l1=n1.node;let found=!1;const p0=(l0.high-l0.low)/2+l0.low,p1=(l1.high-l1.low)/2+l1.low;let sol;return null==l0.chord&&null==l1.chord?sol=Curve.crossWithinIntervalsWithGuess(n0.seg,n1.seg,l0.low,l0.high,l1.low,l1.high,p0,p1):null!=l0.chord&&null==l1.chord?(sol=Curve.crossWithinIntervalsWithGuess(l0.chord,n1.seg,0,1,l1.low,l1.high,.5,p1),null!=sol&&(sol.aSol=l0.low+sol.aSol*(l0.high-l0.low))):null==l0.chord?(sol=Curve.crossWithinIntervalsWithGuess(n0.seg,l1.chord,l0.low,l0.high,0,1,p0,.5),null!=sol&&(sol.bSol=l1.low+sol.bSol*(l1.high-l1.low))):(sol=Curve.crossWithinIntervalsWithGuess(l0.chord,l1.chord,0,1,0,1,.5,.5),null!=sol&&(sol.bSol=l1.low+sol.bSol*(l1.high-l1.low),sol.aSol=l0.low+sol.aSol*(l0.high-l0.low))),null!=sol&&(Curve.addIntersection(n0,n1,intersections,sol),found=!0),found||Curve.goDeeper(intersections,n0,n1),intersections}static addIntersection(n0,n1,intersections,sol){const l0=n0.node;Curve.closeIntersectionPoints(sol.x,n0.seg.value(l0.low))?(sol.x=n0.seg.value(l0.low),sol.aSol=l0.low):Curve.closeIntersectionPoints(sol.x,n0.seg.value(l0.high))&&(sol.x=n0.seg.value(l0.high),sol.aSol=l0.high);const l1=n1.node;Curve.closeIntersectionPoints(sol.x,n1.seg.value(l1.low))?(sol.x=n1.seg.value(l1.low),sol.bSol=l1.low):Curve.closeIntersectionPoints(sol.x,n1.seg.value(l1.high))&&(sol.x=n1.seg.value(l1.high),sol.bSol=l1.high);if(!Curve.oldIntersection(intersections,sol.x)){const xx=new IntersectionInfo(sol.aSol,sol.bSol,sol.x,n0.seg,n1.seg);intersections.push(xx)}}static oldIntersection(intersections,x){for(const ii of intersections)if(x.sub(ii.x).length<100*GeomConstants.distanceEpsilon)return!0;return!1}static createIntersectionOne(n0,n1,aSol,bSol,x){const l0=n0.node,l1=n1.node;return Curve.closeIntersectionPoints(x,n0.seg.value(l0.low))?(x=n0.seg.value(l0.low),aSol=l0.low):Curve.closeIntersectionPoints(x,n0.seg.value(l0.high))&&(x=n0.seg.value(l0.high),aSol=l0.high),Curve.closeIntersectionPoints(x,n1.seg.value(l1.low))?(x=n1.seg.value(l1.low),bSol=l1.low):Curve.closeIntersectionPoints(x,n1.seg.value(l1.high))&&(x=n1.seg.value(l1.high),bSol=l1.high),new IntersectionInfo(aSol,bSol,x,n0.seg,n1.seg)}static liftIntersectionToCurves_(c0,c1,aSol,bSol,x,seg0,seg1){const a=this.liftParameterToCurve(c0,aSol-seg0.parStart,seg0),b=this.liftParameterToCurve(c1,bSol-seg1.parStart,seg1);return new IntersectionInfo(a,b,x,c0,c1)}static DropIntersectionToSegs(xx){let seg0,par0,seg1,par1;if(xx.seg0 instanceof Curve){const sp=xx.seg0.getSegParam(xx.par0);seg0=sp.seg,par0=sp.par}else par0=xx.par0,seg0=xx.seg0;if(xx.seg1 instanceof Curve){const sp=xx.seg1.getSegParam(xx.par1);par1=sp.par,seg1=sp.seg}else par1=xx.par1,seg1=xx.seg1;return new IntersectionInfo(par0,par1,xx.x,seg0,seg1)}static liftIntersectionToCurves(c0,c1,xx){return Curve.liftIntersectionToCurves_(c0,c1,xx.par0,xx.par1,xx.x,xx.seg0,xx.seg1)}static liftParameterToCurve(curve,par,seg){if(curve==seg)return par;if(!curve.hasOwnProperty("segs"))return;const c=curve;let offset=0;for(const s of c.segs){if(s==seg)return par+offset;offset+=Curve.paramSpan(s)}throw"bug in liftParameterToCurve"}static paramSpan(s){return s.parEnd-s.parStart}static goDeeperOne(nl0,nl1){const l0=nl0.node,l1=nl1.node;if(nl0.leafBoxesOffset>GeomConstants.distanceEpsilon&&nl1.leafBoxesOffset>GeomConstants.distanceEpsilon){const nn0=ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low,l0.high,nl0.seg,nl0.leafBoxesOffset/2),nn1=ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low,l1.high,nl1.seg,nl1.leafBoxesOffset/2);return Curve.curveCurveXWithParallelogramNodesOne(nn0,nn1)}if(nl0.leafBoxesOffset>GeomConstants.distanceEpsilon){const nn0=ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low,l0.high,nl0.seg,nl0.leafBoxesOffset/2);return Curve.curveCurveXWithParallelogramNodesOne(nn0,nl1)}if(nl1.leafBoxesOffset>GeomConstants.distanceEpsilon){const nn1=ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low,l1.high,nl1.seg,nl1.leafBoxesOffset/2);return Curve.curveCurveXWithParallelogramNodesOne(nl0,nn1)}const l0Low=nl0.seg.value(l0.low),l0High=nl0.seg.value(l0.high);if(!point_Point.closeDistEps(l0Low,l0High)){const l1Low=nl1.seg.value(l1.low),l1High=nl1.seg.value(l1.high);if(!point_Point.closeDistEps(l1Low,l1High)){const ls0=nl0.seg instanceof LineSegment?nl0.seg:LineSegment.mkPP(l0Low,l0High),ls1=nl1.seg instanceof LineSegment?nl1.seg:LineSegment.mkPP(l1Low,l1High),sol=Curve.crossWithinIntervalsWithGuess(ls0,ls1,0,1,0,1,.5,.5);if(null!=sol)return Curve.adjustParameters(nl0,ls0,nl1,ls1,sol),Curve.createIntersectionOne(nl0,nl1,sol.aSol,sol.bSol,sol.x)}}return null}static goDeeper(intersections,nl0,nl1){const l0=nl0.node,l1=nl1.node;if(nl0.leafBoxesOffset>GeomConstants.distanceEpsilon&&nl1.leafBoxesOffset>GeomConstants.distanceEpsilon){const nn0=ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low,l0.high,nl0.seg,nl0.leafBoxesOffset/2),nn1=ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low,l1.high,nl1.seg,nl1.leafBoxesOffset/2);Curve.curveCurveXWithParallelogramNodes(nn0,nn1,intersections)}else if(nl0.leafBoxesOffset>GeomConstants.distanceEpsilon){const nn0=ParallelogramNode.createParallelogramNodeForCurveSeg(l0.low,l0.high,nl0.seg,nl0.leafBoxesOffset/2);Curve.curveCurveXWithParallelogramNodes(nn0,nl1,intersections)}else if(nl1.leafBoxesOffset>GeomConstants.distanceEpsilon){const nn1=ParallelogramNode.createParallelogramNodeForCurveSeg(l1.low,l1.high,nl1.seg,nl1.leafBoxesOffset/2);Curve.curveCurveXWithParallelogramNodes(nl0,nn1,intersections)}else{const l0Low=nl0.seg.value(l0.low),l0High=nl0.seg.value(l0.high);if(!point_Point.closeDistEps(l0Low,l0High)){const l1Low=nl1.seg.value(l1.low),l1High=nl1.seg.value(l1.high);if(!point_Point.closeDistEps(l1Low,l1High)){const ls0=nl0.seg instanceof LineSegment?nl0.seg:LineSegment.mkPP(l0Low,l0High),ls1=nl1.seg instanceof LineSegment?nl1.seg:LineSegment.mkPP(l1Low,l1High),sol=Curve.crossWithinIntervalsWithGuess(ls0,ls1,0,1,0,1,.5,.5);null!=sol&&(Curve.adjustParameters(nl0,ls0,nl1,ls1,sol),Curve.addIntersection(nl0,nl1,intersections,sol))}}}}static adjustParameters(l0,ls0,l1,ls1,sol){if(ls0!=l0.seg&&l0.seg instanceof Polyline==0)sol.aSol=l0.seg.closestParameter(sol.x);else{const leaf0=l0.node;sol.aSol=leaf0.low+sol.aSol*(leaf0.high-leaf0.low)}if(ls1!=l1.seg&&l1.seg instanceof Polyline==0)sol.bSol=l1.seg.closestParameter(sol.x);else{const leaf1=l1.node;sol.bSol=leaf1.low+sol.bSol*(leaf1.high-leaf1.low)}}getSegParam(t){let u=this.parStart;for(const sg of this.segs){const nextu=u+sg.parEnd-sg.parStart;if(t>=u&&t<=nextu)return{par:t-u+sg.parStart,seg:sg};u=nextu}const lastSeg=this.segs[this.segs.length-1];return{seg:lastSeg,par:lastSeg.parEnd}}getSegIndexParam(t){let u=0;const segLen=this.segs.length;for(let i=0;i<segLen;i++){const sg=this.segs[i],nextu=u+sg.parEnd-sg.parStart;if(t>=u&&t<=nextu)return{segIndex:i,par:t-u+sg.parStart};u=nextu}return{segIndex:segLen-1,par:this.segs[segLen-1].parEnd}}value(t){return function segParamValue(sp){return sp.seg.value(sp.par)}(this.getSegParam(t))}derivative(t){return function segParamDerivative(sp){return sp.seg.derivative(sp.par)}(this.getSegParam(t))}secondDerivative(t){return function segParamSecondDerivative(sp){return sp.seg.secondDerivative(sp.par)}(this.getSegParam(t))}thirdDerivative(t){return function segParamThirdDerivative(sp){return sp.seg.thirdDerivative(sp.par)}(this.getSegParam(t))}static crossWithinIntervalsWithGuess(a,b,amin,amax,bmin,bmax,aGuess,bGuess){if(a instanceof LineSegment&&b instanceof LineSegment){const r=Curve.crossTwoLineSegs(a.start,a.end,b.start,b.end,amin,amax,bmin,bmax);if(null!=r)return r}const mdout=Curve.minDistWithinIntervals(a,b,amin,amax,bmin,bmax,aGuess,bGuess);if(null==mdout)return;const aMinusB=mdout.aX.sub(mdout.bX);return aMinusB.dot(aMinusB)>=GeomConstants.distanceEpsilon?void 0:{aSol:mdout.aSol,bSol:mdout.bSol,x:point_Point.middle(mdout.aX,mdout.bX)}}static crossTwoLineSegs(aStart,aEnd,bStart,bEnd,amin,amax,bmin,bmax){const u=aEnd.sub(aStart),v=bStart.sub(bEnd),w=bStart.sub(aStart),sol=LinearSystem2.solve(u.x,v.x,w.x,u.y,v.y,w.y);if(null==sol)return;let aSol=sol.x,bSol=sol.y;const x=aStart.add(u.mul(aSol));return aSol<amin-GeomConstants.tolerance||(aSol=Math.max(aSol,amin),aSol>amax+GeomConstants.tolerance||(aSol=Math.min(aSol,amax),bSol<bmin-GeomConstants.tolerance||(bSol=Math.max(bSol,bmin),bSol>bmax+GeomConstants.tolerance)))?void 0:(bSol=Math.min(bSol,bmax),{aSol:aSol,bSol:bSol,x:x})}static PointRelativeToCurveLocation(point,curve){if(!curve.boundingBox.contains(point))return PointLocation.Outside;const l=2*curve.boundingBox.diagonal,degree=Math.PI/180;let inside=0;for(let i=13;i<360;i+=13){const lineDir=new point_Point(Math.cos(i*degree),Math.sin(i*degree)),ls=LineSegment.mkPP(point,point.add(lineDir.mul(l))),intersections=this.getAllIntersectionsOfLineAndICurve(ls,curve,!0);if(Curve.AllIntersectionsAreGood(intersections,curve)){for(const xx of intersections)if(point_Point.closeDistEps(xx.x,point))return PointLocation.Boundary;if(intersections.length%2==1?inside++:inside--,inside>=2)return PointLocation.Inside;if(inside<=-2)return PointLocation.Outside}}return PointLocation.Boundary}static AllIntersectionsAreGood(intersections,polygon){let curve=null;if(!polygon.hasOwnProperty("segs")){polygon instanceof Polyline&&(curve=polygon.toCurve())}if(curve)for(const xx of intersections)if(!Curve.RealCut(Curve.DropIntersectionToSegs(xx),curve,!1))return!1;return!0}static RealCut(xx,polyline,onlyFromInsideCuts){const sseg=xx.seg0,pseg=xx.seg1,spar=xx.par0,ppar=xx.par1,x=xx.x,ts=sseg.derivative(spar).normalize(),pn=pseg.derivative(ppar).normalize().rotate(Math.PI/2);if(point_Point.closeDistEps(x,pseg.end)){let exitSeg=null;for(let i=0;i<polyline.segs.length-1;i++)if(polyline.segs[i]==pseg){exitSeg=polyline.segs[i+1];break}if(null==exitSeg)return!1;const tsn=ts.rotate(Math.PI/2);return!(tsn.dot(pseg.derivative(pseg.parEnd))*tsn.dot(exitSeg.derivative(exitSeg.parStart))<GeomConstants.tolerance)}if(point_Point.closeDistEps(x,pseg.start)){let enterSeg=null;for(let i=polyline.segs.length-1;i>0;i--)if(polyline.segs[i]==pseg){enterSeg=polyline.segs[i-1];break}if(null==enterSeg)return!1;const tsn=ts.rotate(Math.PI/2);return!(tsn.dot(pseg.derivative(pseg.parStart))*tsn.dot(enterSeg.derivative(enterSeg.parEnd))<GeomConstants.tolerance)}const d=ts.dot(pn);return onlyFromInsideCuts?d>GeomConstants.distanceEpsilon:Math.abs(d)>GeomConstants.distanceEpsilon}static realCutWithClosedCurve(xx,polygon,onlyFromInsideCuts){const sseg=xx.seg0,pseg=xx.seg1,spar=xx.par0,ppar=xx.par1,x=xx.x,ts=sseg.derivative(spar).normalize(),pn=pseg.derivative(ppar).normalize().rotate(Math.PI/2);if(point_Point.closeDistEps(x,pseg.end)){let exitSeg=null;for(let i=0;i<polygon.segs.length;i++)if(polygon.segs[i]==pseg){exitSeg=polygon.segs[(i+1)%polygon.segs.length];break}if(null==exitSeg)throw new Error;const tsn=ts.rotate(Math.PI/2);return!(tsn.dot(pseg.derivative(pseg.parEnd))*tsn.dot(exitSeg.derivative(exitSeg.parStart))<GeomConstants.tolerance)}if(point_Point.closeDistEps(x,pseg.start)){let enterSeg=null;for(let i=0;i<polygon.segs.length;i++)if(polygon.segs[i]==pseg){enterSeg=polygon.segs[i>0?i-1:polygon.segs.length-1];break}const tsn=ts.rotate(Math.PI/2);return!(tsn.dot(pseg.derivative(pseg.parStart))*tsn.dot(enterSeg.derivative(enterSeg.parEnd))<GeomConstants.tolerance)}const d=ts.dot(pn);return onlyFromInsideCuts?d>GeomConstants.distanceEpsilon:Math.abs(d)>GeomConstants.distanceEpsilon}static minDistWithinIntervals(a,b,aMin,aMax,bMin,bMax,aGuess,bGuess){const md=new MinDistCurveCurve(a,b,aMin,aMax,bMin,bMax,aGuess,bGuess);return md.solve(),md.success?{aSol:md.aSolution,bSol:md.bSolution,aX:md.aPoint,bX:md.bPoint}:void 0}offsetCurve(offset,dir){throw new Error("Method not implemented.")}get boundingBox(){if(0==this.segs.length)return Rectangle.mkEmpty();const b=this.segs[0].boundingBox.clone();for(let i=1;i<this.segs.length;i++)b.addRecSelf(this.segs[i].boundingBox);return b}clone(){const c=new Curve;for(const seg of this.segs)c.addSegment(seg.clone());return c}getParameterAtLength(length){let parSpan=0;for(const seg of this.segs){const segL=seg.length;if(segL>=length)return parSpan+seg.getParameterAtLength(length);length-=segL,parSpan+=seg.parEnd-seg.parStart}return this.parEnd}get length(){let r=0;for(const s of this.segs)r+=s.length;return r}transform(transformation){const c=new Curve;for(const s of this.segs)c.addSegment(s.transform(transformation));return c}closestParameterWithinBounds(targetPoint,low,high){let par=0,dist=Number.MAX_VALUE,offset=0;for(const seg of this.segs){if(offset>high)break;const segparamSpan=Curve.paramSpan(seg);if(offset+segparamSpan>=low){const segLow=Math.max(seg.parStart,seg.parStart+(low-offset)),segHigh=Math.min(seg.parEnd,seg.parStart+(high-offset)),t=seg.closestParameterWithinBounds(targetPoint,segLow,segHigh),d=targetPoint.sub(seg.value(t)),dd=d.dot(d);dd<dist&&(par=offset+t-seg.parStart,dist=dd)}offset+=segparamSpan}return par}closestParameter(targetPoint){let par=0,dist=Number.MAX_VALUE,offset=0;for(const c of this.segs){const t=c.closestParameter(targetPoint),d=targetPoint.sub(c.value(t)),dd=d.dot(d);dd<dist&&(par=offset+t-c.parStart,dist=dd),offset+=Curve.paramSpan(c)}return par}static addLineSegment(curve,pointA,pointB){return curve.addSegment(LineSegment.mkPP(pointA,pointB))}static addLineSegmentCNNP(c,x,y,b){return Curve.addLineSegment(c,new point_Point(x,y),b)}static addLineSegmentCNNNN(curve,x0,y0,x1,y1){Curve.addLineSegment(curve,new point_Point(x0,y0),new point_Point(x1,y1))}static continueWithLineSegmentNN(c,x,y){Curve.addLineSegment(c,c.end,new point_Point(x,y))}static continueWithLineSegmentP(c,x){Curve.addLineSegment(c,c.end,x)}static closeCurve(curve){return Curve.continueWithLineSegmentP(curve,curve.start),curve}leftDerivative(t){const seg=this.tryToGetLeftSegment(t);return null!=seg?seg.derivative(seg.parEnd):this.derivative(t)}rightDerivative(t){const seg=this.tryToGetRightSegment(t);return null!=seg?seg.derivative(seg.parStart):this.derivative(t)}tryToGetLeftSegment(t){if(Math.abs(t-this.parStart)<GeomConstants.tolerance)return this.start.equal(this.end)?this.segs[this.segs.length-1]:null;for(const seg of this.segs)if(t-=Curve.paramSpan(seg),Math.abs(t)<GeomConstants.tolerance)return seg;return null}tryToGetRightSegment(t){if(Math.abs(t-this.parEnd)<GeomConstants.tolerance)return this.start==this.end?this.segs[0]:null;for(const seg of this.segs){if(Math.abs(t)<GeomConstants.tolerance)return seg;t-=Curve.paramSpan(seg)}return null}static ClosestPoint(curve,location){return curve.value(curve.closestParameter(location))}static CurveIsInsideOther(innerCurve,outerCurve){if(!outerCurve.boundingBox.containsRect(innerCurve.boundingBox))return!1;const xx=Curve.getAllIntersections(innerCurve,outerCurve,!0);if(0==xx.length)return Curve.NonIntersectingCurveIsInsideOther(innerCurve,outerCurve);if(1==xx.length)return innerCurve.start.equal(xx[0].x)?Curve.PointRelativeToCurveLocation(innerCurve.value((innerCurve.parStart+innerCurve.parEnd)/2),outerCurve)==PointLocation.Inside:Curve.PointRelativeToCurveLocation(innerCurve.start,outerCurve)==PointLocation.Inside;for(const p of Curve.PointsBetweenIntersections(innerCurve,xx))if(Curve.PointRelativeToCurveLocation(p,outerCurve)==PointLocation.Outside)return!1;return!0}static*PointsBetweenIntersections(a,xx){xx.sort(((x,y)=>x.par0<y.par0?-1:x.par0>y.par0?1:0));for(let i=0;i<xx.length-1;i++)yield a.value((xx[i].par0+xx[i+1].par0)/2);const start=xx[xx.length-1].par0,end=xx[0].par0;let middle=start+(a.parEnd-start+(end-a.parStart))/2;middle>a.parEnd&&(middle=a.parStart+(middle-a.parEnd)),yield a.value(middle)}static NonIntersectingCurveIsInsideOther(a,b){for(let par=a.parStart;par<a.parEnd;par+=.5){const parLoc=Curve.PointRelativeToCurveLocation(a.value(par),b);if(PointLocation.Boundary!=parLoc)return PointLocation.Inside==parLoc}return PointLocation.Outside!=Curve.PointRelativeToCurveLocation(a.end,b)}static ClosedCurveInteriorsIntersect(c1,c2){if(!c2.boundingBox.intersects(c1.boundingBox))return!1;const xx=Curve.getAllIntersections(c1,c2,!0);if(0==xx.length)return Curve.NonIntersectingCurveIsInsideOther(c1,c2)||Curve.NonIntersectingCurveIsInsideOther(c2,c1);if(1==xx.length)return c1.start.equal(xx[0].x)?Curve.PointRelativeToCurveLocation(c1.value((c1.parStart+c1.parEnd)/2),c2)!=PointLocation.Inside&&c2.start.equal(xx[0].x)?Curve.PointRelativeToCurveLocation(c2.value((c2.parStart+c2.parEnd)/2),c1)==PointLocation.Inside:Curve.PointRelativeToCurveLocation(c2.start,c1)==PointLocation.Inside:Curve.PointRelativeToCurveLocation(c1.start,c2)==PointLocation.Inside;for(const p of Curve.PointsBetweenIntersections(c1,xx))if(Curve.PointRelativeToCurveLocation(p,c2)==PointLocation.Inside)return!0;return!0}curvature(t){const sp=this.getSegParam(t);return sp.seg.curvature(sp.par)}curvatureDerivative(t){throw new Error("Not implemente")}curvatureSecondDerivative(t){throw new Error("Not implemented")}static createBezierSeg(kPrev,kNext,a,b,c){const s=point_Point.mkPoint(kPrev,a.point,1-kPrev,b.point),e=point_Point.mkPoint(kNext,c.point,1-kNext,b.point),t=b.point.mul(2/3);return new BezierSeg(s,s.div(3).add(t),t.add(e.div(3)),e)}static createBezierSegN(a,b,perp,i){const d=perp.mul(i);return new BezierSeg(a,a.add(d),b.add(d),b)}static findCorner(a){const b=a.next;if(null==b.next)return;const c=b.next;return null!=c?{b:b,c:c}:void 0}static trimEdgeSplineWithNodeBoundaries(sourceBoundary,targetBoundary,spline,narrowestInterval){let start=spline.parStart,end=spline.parEnd;null!=sourceBoundary&&(start=Curve.findNewStart(spline,start,sourceBoundary,narrowestInterval)),null!=targetBoundary&&(end=Curve.findNewEnd(spline,targetBoundary,narrowestInterval,end));const st=Math.min(start,end),en=Math.max(start,end);return st<en?spline.trim(st,en):spline}static findNewEnd(spline,targetBoundary,narrowestInterval,end){const intersections=Curve.getAllIntersections(spline,targetBoundary,!0);if(0==intersections.length)return end=spline.parEnd;if(narrowestInterval){end=spline.parEnd;for(const xx of intersections)xx.par0<end&&(end=xx.par0)}else{end=spline.parStart;for(const xx of intersections)xx.par0>end&&(end=xx.par0)}return end}static findNewStart(spline,start,sourceBoundary,narrowestInterval){const intersections=Curve.getAllIntersections(spline,sourceBoundary,!0);if(0!=intersections.length){if(narrowestInterval){start=spline.parStart;for(const xx of intersections)xx.par0>start&&(start=xx.par0)}else{start=spline.parEnd;for(const xx of intersections)xx.par0<start&&(start=xx.par0)}return start}start=spline.parStart}static polylineAroundClosedCurve(curve){if(curve instanceof Ellipse)return Curve.refineEllipse(curve);if(curve instanceof Polyline)return curve;if(curve instanceof Curve&&Curve.allSegsAreLines(curve)){const ret=new Polyline;for(const ls of curve.segs)ret.addPoint(ls.start);if(ret.closed=!0,!ret.isClockwise())return ret.reverse()}return curve.boundingBox.perimeter()}static allSegsAreLines(c){for(const s of c.segs)if(!(s instanceof LineSegment))return!1;return!0}static refineEllipse(ellipse){const rect=ellipse.boundingBox.perimeter(),a=Math.PI/4,w=ellipse.boundingBox.width,h=ellipse.boundingBox.height,l=Math.sqrt(w*w+h*h),xs=[];for(let i=0;i<4;i++){const t=a+i*Math.PI/2,p=ellipse.value(t),tan=ellipse.derivative(t).normalize().mul(l),ls=LineSegment.mkPP(p.sub(tan),p.add(tan));for(const x of Curve.getAllIntersections(rect,ls,!0))xs.push(x)}xs.sort(((a,b)=>a.par0<b.par0?-1:a.par0>b.par0?1:0));const ret=new Polyline;return xs.forEach((x=>ret.addPoint(x.x))),ret.closed=!0,ret}static polyFromBox(rectangle){const p=new Polyline;return p.addPoint(rectangle.leftTop),p.addPoint(rectangle.rightTop),p.addPoint(rectangle.rightBottom),p.addPoint(rectangle.leftBottom),p.closed=!0,p}}function interpolate(a,ap,b,bp,s,eps){let r=[];if(function isCloseToLineSeg(a,ap,b,bp,s,e){for(const x of[1/3,.5,2/3]){const p=a*x+b*(1-x);if(!point_Point.closeSquare(s.value(p),point_Point.mkPoint(x,ap,1-x,bp),e))return!1}return!0}(a,ap,b,bp,s,eps))r.push(ap),r.push(bp);else{const m=.5*(a+b),mp=s.value(m);r=interpolate(a,ap,m,mp,s,eps);const tail=interpolate(m,mp,b,bp,s,eps).slice(1);r=r.concat(tail)}return r}function interpolateICurve(s,eps){return interpolate(s.parStart,s.start,s.parEnd,s.end,s,eps)}class Polyline{constructor(){this.initIsRequired=!0,this.isClosed_=!1}RemoveStartPoint(){const p=this.startPoint.next;p.prev=null,this.startPoint=p,this.setInitIsRequired()}RemoveEndPoint(){const p=this.endPoint.prev;p.next=null,this.endPoint=p,this.setInitIsRequired()}setInitIsRequired(){this.initIsRequired=!0}addPointXY(x,y){this.addPoint(new point_Point(x,y))}isClockwise(){return point_Point.getTriangleOrientation(this.startPoint.point,this.startPoint.next.point,this.startPoint.next.next.point)==point_TriangleOrientation.Clockwise}addPoint(p){const pp=new PolylinePoint;pp.polyline=this,pp.point=p.clone(),null!=this.endPoint?(this.endPoint.next=pp,pp.prev=this.endPoint,this.endPoint=pp):this.startPoint=this.endPoint=pp,this.setInitIsRequired()}PrependPoint(p){const pp=PolylinePoint.mkFromPoint(p);pp.polyline=this,null!=this.startPoint?point_Point.closeDistEps(p,this.startPoint.point)||(this.startPoint.prev=pp,pp.next=this.startPoint,this.startPoint=pp):(this.endPoint=pp,this.startPoint=pp),this.setInitIsRequired()}*[Symbol.iterator](){for(let s=this.startPoint;null!=s;s=s.next)yield s.point}*polylinePoints(){for(let s=this.startPoint;null!=s;s=s.next)yield s}*skip(skipCount){for(let s=this.startPoint;null!=s;s=s.next)skipCount>0?skipCount--:yield s}static parallelogramOfLineSeg(a,b){const side=b.sub(a).div(2);return Parallelogram.parallelogramByCornerSideSide(a,side,side)}static mkFromPoints(ps){const r=new Polyline;for(const p of ps)r.addPoint(p);return r}static mkClosedFromPoints(ps){const r=Polyline.mkFromPoints(ps);return r.closed=!0,r}calculatePbNode(){const parallelograms=[],children=[];let pp=this.startPoint,offset=0;for(;null!=pp.next;){const parallelogram=Polyline.parallelogramOfLineSeg(pp.point,pp.next.point);parallelograms.push(parallelogram),children.push({parallelogram:parallelogram,seg:this,leafBoxesOffset:0,node:{low:offset,high:offset+1,chord:LineSegment.mkPP(pp.point,pp.next.point)}}),pp=pp.next,offset++}if(this.isClosed_){const parallelogram=Polyline.parallelogramOfLineSeg(this.endPoint.point,this.startPoint.point);parallelograms.push(parallelogram),children.push({parallelogram:parallelogram,seg:this,leafBoxesOffset:0,node:{low:offset,high:offset+1,chord:LineSegment.mkPP(this.endPoint.point,this.startPoint.point)}})}this.pBNode={parallelogram:Parallelogram.getParallelogramOfAGroup(parallelograms),seg:this,leafBoxesOffset:0,node:{children:children}}}init(){this.bBox=Rectangle.rectangleOnPoint(this.startPoint.point);for(const p of this.skip(1))this.bBox.add(p.point);this.updateCount(),this.calculatePbNode(),this.initIsRequired=!1}updateCount(){this.count_=0;for(let pp=this.startPoint;null!=pp;pp=pp.next)this.count_++}get count(){return this.initIsRequired&&this.init(),this.count_}get closed(){return this.isClosed_}set closed(value){this.isClosed_=value}value(t){this.initIsRequired&&this.init();const p=this.getAdjustedParamAndStartEndPoints(t);return point_Point.convSum(p.t,p.a,p.b)}getAdjustedParamAndStartEndPoints(t){let s=this.startPoint;for(;null!=s.next;){if(t<=1)return{a:s.point,b:s.next.point,t:t};s=s.next,t-=1}if(this.closed&&t<=1)return{a:this.endPoint.point,b:this.startPoint.point,t:t};throw new Error("out of the parameter domain")}derivative(t){const ap=this.getAdjustedParamAndStartEndPoints(t);return ap.b.sub(ap.a)}secondDerivative(t){return new point_Point(0,0)}thirdDerivative(t){return new point_Point(0,0)}pNodeOverICurve(){return this.initIsRequired&&this.init(),this.pBNode}get boundingBox(){return this.initIsRequired&&this.init(),this.bBox}get parStart(){return 0}get parEnd(){return this.initIsRequired&&this.init(),this.closed?this.count_:this.count_-1}static polylineFromCurve(curve){const ret=new Polyline;ret.addPoint(curve.start);for(const ls of curve.segs)ret.addPoint(ls.end);return ret.closed=curve.start==curve.end,ret}trim(start,end){let curve=this.toCurve();return curve=curve.trim(start,end),Polyline.polylineFromCurve(curve)}trimWithWrap(start,end){throw new Error("Method not implemented.")}translate(delta){let p=this.startPoint;for(;;){if(p.point=p.point.add(delta),p==this.endPoint)break;p=p.getNext()}this.setInitIsRequired()}scaleFromOrigin(xScale,yScale){throw new Error("Method not implemented.")}get start(){return this.startPoint.point}get end(){return this.endPoint.point}reverse(){const r=new Polyline;r.closed=this.closed;let p=this.endPoint;for(;;){if(r.addPoint(p.point),p==this.startPoint)break;p=p.getPrev()}return r}offsetCurve(offset,dir){throw new Error("Method not implemented.")}lengthPartial(start,end){throw new Error("Method not implemented.")}get length(){throw new Error("Method not implemented.")}getParameterAtLength(length){throw new Error("Method not implemented.")}transform(transformation){const ret=new Polyline;for(const p of this.polylinePoints())ret.addPoint(transformation.multiplyPoint(p.point));return ret.closed=this.closed,ret}closestParameterWithinBounds(targetPoint,low,high){throw new Error("Method not implemented.")}closestParameter(targetPoint){let ret=0,dist=Number.MAX_VALUE,offset=0,pp=this.startPoint;for(;null!=pp.next;){const ls=LineSegment.mkPP(pp.point,pp.next.point),t=ls.closestParameter(targetPoint),delta=ls.value(t).sub(targetPoint),newDist=delta.dot(delta);newDist<dist&&(dist=newDist,ret=t+offset),pp=pp.next,offset++}if(this.closed){const ls=LineSegment.mkPP(this.endPoint.point,this.startPoint.point),t=ls.closestParameter(targetPoint),delta=ls.value(t).sub(targetPoint);delta.dot(delta)<dist&&(ret=t+offset)}return ret}clone(){const r=new Polyline;r.closed=this.closed;let p=this.startPoint;for(;;){if(r.addPoint(p.point),p==this.endPoint)break;p=p.getNext()}return r}leftDerivative(t){throw new Error("Method not implemented.")}rightDerivative(t){throw new Error("Method not implemented.")}curvature(t){throw new Error("Method not implemented.")}curvatureDerivative(t){throw new Error("Method not implemented.")}curvatureSecondDerivative(t){throw new Error("Method not implemented.")}next(a){var _a;return null!==(_a=a.next)&&void 0!==_a?_a:this.closed?this.startPoint:null}prev(a){var _a;return null!==(_a=a.prev)&&void 0!==_a?_a:this.closed?this.endPoint:null}toCurve(){const c=new Curve;Curve.addLineSegment(c,this.startPoint.point,this.startPoint.next.point);let p=this.startPoint.next;for(;null!=(p=p.next);)Curve.continueWithLineSegmentP(c,p.point);return this.closed&&Curve.continueWithLineSegmentP(c,this.startPoint.point),c}}class Size{constructor(width,height){this.width=width,this.height=height}pad(padW){this.width+=2*padW}}class Rectangle{constructor(t){this.left_=t.left,this.right_=t.right,this.top_=t.top,this.bottom=t.bottom}static mkSizeCenter(size,center){const w=size.width/2,h=size.height/2;return new Rectangle({left:center.x-w,right:center.x+w,bottom:center.y-h,top:center.y+h})}add_rect(rectangle){return this.addRec(rectangle)}contains_point(point){return this.contains(point)}contains_rect(rect){return this.containsRect(rect)}intersection_rect(rectangle){return this.intersection(rectangle)}intersects_rect(rectangle){return this.intersects(rectangle)}unite(b){return Rectangle.rectangleOfTwo(this,b)}contains_point_radius(p,radius){return this.containsWithPadding(p,radius)}intersects(rectangle){return this.intersectsOnX(rectangle)&&this.intersectsOnY(rectangle)}intersection(rectangle){if(!this.intersects(rectangle)){const intersection=Rectangle.mkEmpty();return intersection.setToEmpty(),intersection}const l=Math.max(this.left,rectangle.left),r=Math.min(this.right,rectangle.right),b=Math.max(this.bottom,rectangle.bottom),t=Math.min(this.top,rectangle.top);return new Rectangle({left:l,bottom:b,right:r,top:t})}get center(){return this.leftTop.add(this.rightBottom).mul(.5)}set center(value){const shift=value.sub(this.center);this.leftTop=this.leftTop.add(shift),this.rightBottom=this.rightBottom.add(shift)}intersectsOnY(r){return!(r.bottom_>this.top_+GeomConstants.distanceEpsilon)&&!(r.top_<this.bottom_-GeomConstants.distanceEpsilon)}intersectsOnX(r){return!(r.left>this.right_+GeomConstants.distanceEpsilon)&&!(r.right<this.left_-GeomConstants.distanceEpsilon)}static mkEmpty(){return new Rectangle({left:0,right:-1,bottom:0,top:-1})}get left(){return this.left_}set left(value){this.left_=value}get right(){return this.right_}set right(value){this.right_=value}get top(){return this.top_}set top(value){this.top_=value}get bottom(){return this.bottom_}set bottom(value){this.bottom_=value}get leftBottom(){return new point_Point(this.left_,this.bottom_)}set leftBottom(value){this.left_=value.x,this.bottom=value.y}get rightTop(){return new point_Point(this.right_,this.top_)}set rightTop(value){this.right_=value.x,this.top_=value.y}get leftTop(){return new point_Point(this.left_,this.top_)}set leftTop(value){this.left_=value.x,this.top_=value.y}get rightBottom(){return new point_Point(this.right_,this.bottom_)}set rightBottom(value){this.right_=value.x,this.bottom=value.y}static mkPP(point0,point1){const r=new Rectangle({left:point0.x,right:point0.x,top:point0.y,bottom:point0.y});return r.add(point1),r}static rectangleOnPoint(p){return new Rectangle({left:p.x,right:p.x,top:p.y,bottom:p.y})}static rectangleFromLeftBottomAndSize(left,bottom,sizeF){const right=left+sizeF.x,top=bottom+sizeF.y;return new Rectangle({left:left,right:right,top:top,bottom:bottom})}static getRectangleOnCoords(x0,y0,x1,y1){const r=new Rectangle({left:x0,bottom:y0,right:x0,top:y0});return r.add(new point_Point(x1,y1)),r}static mkOnPoints(points){const r=Rectangle.mkEmpty();for(const p of points)r.add(p);return r}static rectangleOnRectangles(rectangles){const r=Rectangle.mkEmpty();for(const p of rectangles)r.addRecSelf(p);return r}get width(){return this.right_-this.left_}set width(value){const hw=value/2,cx=(this.left_+this.right_)/2;this.left_=cx-hw,this.right_=cx+hw}isEmpty(){return this.width<0}setToEmpty(){this.left=0,this.right=-1}get height(){return this.top_-this.bottom_}set height(value){const hw=value/2,cx=(this.top_+this.bottom_)/2;this.top_=cx+hw,this.bottom=cx-hw}static rectangleOfTwo(a,b){const r=new Rectangle({left:a.left_,right:a.right_,top:a.top_,bottom:a.bottom_});return r.addRecSelf(b),r}containsWithPadding(point,padding){return this.left_-padding-GeomConstants.distanceEpsilon<=point.x&&point.x<=this.right_+padding+GeomConstants.distanceEpsilon&&this.bottom_-padding-GeomConstants.distanceEpsilon<=point.y&&point.y<=this.top_+padding+GeomConstants.distanceEpsilon}get area(){return(this.right_-this.left_)*(this.top_-this.bottom_)}add(point){this.isEmpty()?(this.left_=this.right_=point.x,this.top_=this.bottom=point.y):(this.left_>point.x&&(this.left_=point.x),this.top_<point.y&&(this.top_=point.y),this.right_<point.x&&(this.right_=point.x),this.bottom_>point.y&&(this.bottom=point.y))}addWithCheck(point){let wider,higher;return(wider=point.x<this.left_)?this.left_=point.x:(wider=this.right_<point.x)&&(this.right_=point.x),(higher=point.y>this.top_)?this.top_=point.y:(higher=this.bottom_>point.y)&&(this.bottom=point.y),wider||higher}addRecSelf(rectangle){this.add(rectangle.leftTop),this.add(rectangle.rightBottom)}addRec(rectangle){const ret=this.clone();return ret.add(rectangle.leftTop),ret.add(rectangle.rightBottom),ret}static translate(rectangle,delta){const r=rectangle.clone();return r.center=rectangle.center.add(delta),r}contains(point){return this.containsWithPadding(point,0)}containsRect(rect){return this.contains(rect.leftTop)&&this.contains(rect.rightBottom)}get diagonal(){return Math.sqrt(this.width*this.width+this.height*this.height)}padWidth(padding){this.left-=padding,this.right+=padding}padHeight(padding){this.top+=padding,this.bottom-=padding}pad(padding){return padding<-this.width/2&&(padding=-this.width/2),padding<-this.height/2&&(padding=-this.height/2),this.padWidth(padding),this.padHeight(padding),this}padEverywhere(margins){this.left-=margins.left,this.right+=margins.right,this.bottom-=margins.bottom,this.top+=margins.top}static intersect(rect1,rect2){return rect1.intersects(rect2)?Rectangle.mkPP(new point_Point(Math.max(rect1.left,rect2.left),Math.max(rect1.bottom,rect2.bottom)),new point_Point(Math.min(rect1.right,rect2.right),Math.min(rect1.top,rect2.top))):Rectangle.mkEmpty()}perimeter(){const poly=new Polyline;return poly.addPoint(this.leftTop),poly.addPoint(this.rightTop),poly.addPoint(this.rightBottom),poly.addPoint(this.leftBottom),poly.closed=!0,poly}scaleAroundCenter(scale){this.width=this.width*scale,this.height=this.height*scale}clone(){return Rectangle.mkPP(this.leftTop,this.rightBottom)}get size(){return new Size(this.width,this.height)}set size(value){this.width=value.width,this.height=value.height}static creatRectangleWithSize(size,center){const w=size.width/2,left=center.x-w,right=center.x+w,h=size.height/2,bottom=center.y-h,top=center.y+h;return new Rectangle({left:left,right:right,top:top,bottom:bottom})}addPointWithSize(size,point){const w=size.width/2,h=size.height/2;this.add(new point_Point(point.x-w,point.y-h)),this.add(new point_Point(point.x+w,point.y-h)),this.add(new point_Point(point.x-w,point.y+h)),this.add(new point_Point(point.x+w,point.y+h))}}class GeomObject{constructor(attrCont){this.attrCont=attrCont,this.bind()}bind(){this.attrCont&&this.attrCont.setAttr(0,this)}static getGeom(attrCont){return attrCont.getAttr(0)}}class PlaneTransformation{constructor(m00,m01,m02,m10,m11,m12){this.elements=[[m00,m01,m02],[m10,m11,m12]]}get Elements(){return this.elements}getElem(i,j){return this.elements[i][j]}setElem(i,j,v){this.elements[i][j]=v}static Divide(m0,m1){return m0.multiply(m1.inverse())}isIdentity(){return closeDistEps(this.elements[0][0],1)&&closeDistEps(this.elements[0][1],0)&&closeDistEps(this.elements[0][2],0)&&closeDistEps(this.elements[1][0],0)&&closeDistEps(this.elements[1][1],1)&&closeDistEps(this.elements[1][2],0)}offset(){return new point_Point(this.getElem(0,2),this.getElem(1,2))}static getIdentity(){return new PlaneTransformation(1,0,0,0,1,0)}static rotation(angle){const cos=Math.cos(angle),sin=Math.sin(angle);return new PlaneTransformation(cos,-sin,0,sin,cos,0)}static scaleAroundCenterTransformation(xScale,yScale,center){const dY=1-yScale;return new PlaneTransformation(xScale,0,(1-xScale)*center.x,0,yScale,dY*center.y)}multiplyPoint(p){return new point_Point(this.getElem(0,0)*p.x+this.getElem(0,1)*p.y+this.getElem(0,2),this.getElem(1,0)*p.x+this.getElem(1,1)*p.y+this.getElem(1,2))}multiply(b){return null!=b?new PlaneTransformation(this.getElem(0,0)*b.getElem(0,0)+this.getElem(0,1)*b.getElem(1,0),this.getElem(0,0)*b.getElem(0,1)+this.getElem(0,1)*b.getElem(1,1),this.getElem(0,0)*b.getElem(0,2)+this.getElem(0,1)*b.getElem(1,2)+this.getElem(0,2),this.getElem(1,0)*b.getElem(0,0)+this.getElem(1,1)*b.getElem(1,0),this.getElem(1,0)*b.getElem(0,1)+this.getElem(1,1)*b.getElem(1,1),this.getElem(1,0)*b.getElem(0,2)+this.getElem(1,1)*b.getElem(1,2)+this.getElem(1,2)):null}inverse(){const det=this.getElem(0,0)*this.getElem(1,1)-this.getElem(1,0)*this.getElem(0,1),a00=this.getElem(1,1)/det,a01=-this.getElem(0,1)/det,a10=-this.getElem(1,0)/det,a11=this.getElem(0,0)/det,a02=-a00*this.getElem(0,2)-a01*this.getElem(1,2),a12=-a10*this.getElem(0,2)-a11*this.getElem(1,2);return new PlaneTransformation(a00,a01,a02,a10,a11,a12)}}!function(Direction){Direction[Direction.None=0]="None",Direction[Direction.North=1]="North",Direction[Direction.East=2]="East",Direction[Direction.South=4]="South",Direction[Direction.West=8]="West"}(Direction||(Direction={}));class PointComparer{static get DifferenceEpsilon(){return PointComparer.differenceEpsilon}static EqualPP(a,b){return PointComparer.Equal(a.x,b.x)&&PointComparer.Equal(a.y,b.y)}static Equal(x,y){return 0==PointComparer.Compare(x,y)}static Compare(lhs,rhs){let cmp=0;return lhs+PointComparer.DifferenceEpsilon<rhs?cmp=-1:rhs+PointComparer.DifferenceEpsilon<lhs&&(cmp=1),cmp}static ComparePP(lhs,rhs){let cmp=PointComparer.Compare(lhs.x,rhs.x);return 0==cmp&&(cmp=PointComparer.Compare(lhs.y,rhs.y)),cmp}static LessOrEqual(a,b){const comp=PointComparer.Compare(a,b);return comp<0||0==comp}static Less(a,b){return PointComparer.Compare(a,b)<0}static GetDirections(a,b){return CompassVector.DirectionFromPointToPoint(a,b)}static IsPureDirection(a,b){return CompassVector.IsPureDirection(PointComparer.GetDirections(a,b))}static IsPureDirectionD(dir){return CompassVector.IsPureDirection(dir)}static IsPureLower(a,b){const dir=PointComparer.GetDirections(a,b);return Direction.East==dir||Direction.North==dir}static GetPureDirectionVV(first,second){return PointComparer.GetDirections(first.point,second.point)}}PointComparer.differenceEpsilon=GeomConstants.distanceEpsilon/2;class CompassVector{constructor(direction){this.Dir=direction}get Right(){return new CompassVector(CompassVector.RotateRight(this.Dir))}static RotateRight(direction){switch(direction){case Direction.North:return Direction.East;case Direction.East:return Direction.South;case Direction.South:return Direction.West;case Direction.West:return Direction.North;default:throw new Error}}static RotateLeft(direction){switch(direction){case Direction.North:return Direction.West;case Direction.West:return Direction.South;case Direction.South:return Direction.East;case Direction.East:return Direction.North;default:throw new Error}}static ToIndex(direction){switch(direction){case Direction.North:return 0;case Direction.East:return 1;case Direction.South:return 2;case Direction.West:return 3;default:throw new Error}}static VectorDirection(d){let r=Direction.None;return d.x>PointComparer.DifferenceEpsilon?r=Direction.East:d.x<-PointComparer.DifferenceEpsilon&&(r=Direction.West),d.y>PointComparer.DifferenceEpsilon?r|=Direction.North:d.y<-PointComparer.DifferenceEpsilon&&(r|=Direction.South),r}static VectorDirectionPP(a,b){let r=Direction.None;const horizontalDiff=b.x-a.x,verticalDiff=b.y-a.y;return horizontalDiff>PointComparer.DifferenceEpsilon?r=Direction.East:-horizontalDiff>PointComparer.DifferenceEpsilon&&(r=Direction.West),verticalDiff>PointComparer.DifferenceEpsilon?r|=Direction.North:-verticalDiff>PointComparer.DifferenceEpsilon&&(r|=Direction.South),r}static DirectionFromPointToPoint(a,b){return CompassVector.VectorDirectionPP(a,b)}static OppositeDir(dir){switch(dir){case Direction.North:return Direction.South;case Direction.West:return Direction.East;case Direction.South:return Direction.North;case Direction.East:return Direction.West;default:return Direction.None}}static IsPureDirection(dir){switch(dir){case Direction.North:case Direction.East:case Direction.South:case Direction.West:return!0;default:return!1}}static IsPureDirectionPP(a,b){return CompassVector.IsPureDirection(CompassVector.DirectionFromPointToPoint(a,b))}static DirectionsAreParallel(a,b){return a==b||a==CompassVector.OppositeDir(b)}ToPoint(){let x=0,y=0;return(this.Dir&Direction.East)==Direction.East&&x++,(this.Dir&Direction.North)==Direction.North&&y++,(this.Dir&Direction.West)==Direction.West&&x--,(this.Dir&Direction.South)==Direction.South&&y--,new point_Point(x,y)}static toPoint(dir){return new CompassVector(dir).ToPoint()}static negate(directionVector){return new CompassVector(CompassVector.OppositeDir(directionVector.Dir))}}class curveFactory_CurveFactory{static createHexagon(width,height,center){const h=height/2,w=width/2,x=center.x,y=center.y;return Polyline.mkClosedFromPoints([new point_Point(-1*w+x,-1*h+y),new point_Point(w+x,-1*h+y),new point_Point(w+(h+x),0+y),new point_Point(w+x,h+y),new point_Point(-1*w+x,h+y),new point_Point(-1*(w-h)+x,0+y)])}static createOctagon(width,height,center){const w=width/2,h=height/2,ps=new Array(8);ps[0]=new point_Point(w+curveFactory_CurveFactory.octagonPad*w,h-h*curveFactory_CurveFactory.octagonPad),ps[3]=new point_Point(-1*ps[0].x,ps[0].y),ps[4]=new point_Point(ps[3].x,-1*ps[3].y),ps[7]=new point_Point(ps[0].x,-1*ps[0].y),ps[1]=new point_Point(w-w*curveFactory_CurveFactory.octagonPad,h+h*curveFactory_CurveFactory.octagonPad),ps[2]=new point_Point(-1*ps[1].x,ps[1].y),ps[6]=new point_Point(ps[1].x,-1*ps[1].y),ps[5]=new point_Point(ps[2].x,-1*ps[2].y);for(let i=0;i<8;i++)ps[i]=ps[i].add(center);return Polyline.mkClosedFromPoints(ps)}static createInvertedHouse(width,height,center){const shape=curveFactory_CurveFactory.createHouse(width,height,center);return curveFactory_CurveFactory.rotateCurveAroundCenterByDegree(shape,center,180)}static createHouse(width,height,center){const w=width/2,h=height/2,x=center.x,y=center.y,c=new Curve;return Curve.addLineSegmentCNNNN(c,x-w,y-h,x+w,y-h),Curve.continueWithLineSegmentNN(c,x+w,y+h),Curve.continueWithLineSegmentNN(c,x,y+2*h),Curve.continueWithLineSegmentNN(c,x-w,y+h),Curve.closeCurve(c)}static CreateDiamond(width,height,center){const w=width,h=height,x=center.x,y=center.y,c=new Curve,p=[new point_Point(x,y-h),new point_Point(x+w,y),new point_Point(x,y+h),new point_Point(x-w,y)];return c.addSegs([LineSegment.mkPP(p[0],p[1]),LineSegment.mkPP(p[1],p[2]),LineSegment.mkPP(p[2],p[3]),LineSegment.mkPP(p[3],p[0])]),c}static rotateCurveAroundCenterByDegree(curve,center,angle){return curveFactory_CurveFactory.rotateCurveAroundCenterByRadian(curve,center,angle*Math.PI/180)}static rotateCurveAroundCenterByRadian(curve,center,angle){const c=Math.cos(angle),s=Math.sin(angle),transform=new PlaneTransformation(1,0,center.x,0,1,center.y).multiply(new PlaneTransformation(c,-s,0,s,c,0)).multiply(new PlaneTransformation(1,0,-center.x,0,1,-center.y));return curve.transform(transform)}static mkCircle(radius,center){return Ellipse.mkCircle(radius,center)}static createRectangle(width,height,center){const w=width/2,h=height/2,x=center.x,y=center.y,c=new Curve,p=[new point_Point(x-w,y-h),new point_Point(x+w,y-h),new point_Point(x+w,y+h),new point_Point(x-w,y+h)];return c.addSegs([LineSegment.mkPP(p[0],p[1]),LineSegment.mkPP(p[1],p[2]),LineSegment.mkPP(p[2],p[3]),LineSegment.mkPP(p[3],p[0])]),c}static isRoundedRect(ic){if(!(ic instanceof Curve))return;const segs=ic.segs;if(8!=segs.length&&4!=segs.length)return;const full=8==segs.length;let radX,radY;for(let k=0;k<4;k++){const i=full?2*k+1:k;if(0==k){if(!(segs[i]instanceof Ellipse))return;const el=segs[i];radX=el.aAxis.length,radY=el.bAxis.length}else{if(!(segs[i]instanceof Ellipse))return;const el=segs[i];if(radX!=el.aAxis.length||radY!=el.bAxis.length)return}}return{radX:radX,radY:radY}}static mkRectangleWithRoundedCorners(width,height,radX,radY,center=new point_Point(0,0)){if(0==radX||0==radY)return curveFactory_CurveFactory.createRectangle(width,height,center);const c=new Curve,w=width/2;radX>w/2&&(radX=w/2);const h=height/2;radY>h/2&&(radY=h/2);const x=center.x,y=center.y,ox=w-radX,oy=h-radY,top=y+h,bottom=y-h,left=x-w,right=x+w,a=new point_Point(radX,0),b=new point_Point(0,radY);return ox>0&&c.addSegment(LineSegment.mkPP(new point_Point(x-ox,bottom),new point_Point(x+ox,bottom))),c.addSegment(Ellipse.mkEllipse(1.5*Math.PI,2*Math.PI,a,b,x+ox,y-oy)),oy>0&&c.addSegment(LineSegment.mkPP(new point_Point(right,y-oy),new point_Point(right,y+oy))),c.addSegment(Ellipse.mkEllipse(0,.5*Math.PI,a,b,x+ox,y+oy)),ox>0&&c.addSegment(LineSegment.mkPP(new point_Point(x+ox,top),new point_Point(x-ox,top))),c.addSegment(Ellipse.mkEllipse(.5*Math.PI,Math.PI,a,b,x-ox,y+oy)),oy>0&&c.addSegment(LineSegment.mkPP(new point_Point(left,y+oy),new point_Point(left,y-oy))),c.addSegment(Ellipse.mkEllipse(Math.PI,1.5*Math.PI,a,b,x-ox,y-oy)),c}}curveFactory_CurveFactory.octagonPad=1/4;class GeomNode extends GeomObject{constructor(){super(...arguments),this.padding=1}get isGraph(){return!1}get node(){return this.attrCont}get boundaryCurve(){return this._boundaryCurve}set boundaryCurve(value){(null!=value&&value.boundingBox.height<GeomNode.minHeight||value.boundingBox.width<GeomNode.minWidth)&&(value=curveFactory_CurveFactory.mkCircle(GeomNode.minWidth,value.boundingBox.center)),this._boundaryCurve=value}get id(){return this.node.id}toString(){return this.id}static mkNode(curve,node){const n=new GeomNode(node);return n.boundaryCurve=curve,n}get center(){return this.boundaryCurve.boundingBox.center}set center(value){const del=value.sub(this.center);this.boundaryCurve.translate(del)}fitBoundaryCurveToTarget(targetBounds){if(null!=this.boundaryCurve){const radii=curveFactory_CurveFactory.isRoundedRect(this.boundaryCurve);if(null==radii){const scaleX=targetBounds.width/this.boundaryCurve.boundingBox.width,scaleY=targetBounds.height/this.boundaryCurve.boundingBox.height;this.boundaryCurve=this.boundaryCurve.scaleFromOrigin(scaleX,scaleY),this.boundaryCurve.translate(targetBounds.center.sub(this.boundaryCurve.boundingBox.center))}else this.boundaryCurve=curveFactory_CurveFactory.mkRectangleWithRoundedCorners(targetBounds.width,targetBounds.height,radii.radX,radii.radY,targetBounds.center)}}*inEdges(){for(const e of this.node.inEdges)yield GeomObject.getGeom(e)}*outEdges(){for(const e of this.node.outEdges)yield GeomObject.getGeom(e)}*selfEdges(){for(const e of this.node.selfEdges)yield GeomObject.getGeom(e)}get boundingBox(){return this.boundaryCurve?this.boundaryCurve.boundingBox:null}set boundingBox(value){this.boundaryCurve&&(Math.abs(value.width-this.width)<1e-4&&Math.abs(value.height-this.height)<1e-4?this.center=value.center:this.fitBoundaryCurveToTarget(value))}get width(){return this.boundaryCurve.boundingBox.width}get height(){return this.boundaryCurve.boundingBox.height}transform(t,updateBoundingBox=!0){null!=this.boundaryCurve&&(this.boundaryCurve=this.boundaryCurve.transform(t))}underCollapsedCluster(){return null!=this.node&&this.node.isUnderCollapsedGraph()}}GeomNode.minHeight=2,GeomNode.minWidth=3;class CornerSite{constructor(){this.previouisBezierCoefficient=.5,this.nextBezierCoefficient=.5,this.previousTangentCoefficient=1/3,this.nextTangentCoefficient=1/3}static mkSiteP(sitePoint){const s=new CornerSite;return s.point=sitePoint,s}static mkSiteSP(previousSite,sitePoint){const s=new CornerSite;return s.point=sitePoint,s.prev=previousSite,previousSite.next=s,s}static mkSiteSPS(previousSite,sitePoint,nextSite){const s=new CornerSite;return s.prev=previousSite,s.point=sitePoint,s.next=nextSite,previousSite.next=s,nextSite.prev=s,s}get turn(){return null==this.next||null==this.prev?0:point_Point.getTriangleOrientation(this.prev.point,this.point,this.next.point)}clone(){const s=new CornerSite;return s.previouisBezierCoefficient=this.previouisBezierCoefficient,s.point=this.point,s}}class SmoothedPolyline{constructor(head){this.headSite=head}static mkFromPoints(points){let ret=null,site=null;for(const p of points)if(null==site)site=CornerSite.mkSiteP(p),ret=new SmoothedPolyline(site);else{const s=CornerSite.mkSiteP(p);s.prev=site,site.next=s,site=s}return ret}clone(){let h,s=this.headSite,prev=null,headOfTheClone=null;for(;null!=s;)h=s.clone(),h.prev=prev,null!=prev?prev.next=h:headOfTheClone=h,s=s.next,prev=h;return new SmoothedPolyline(headOfTheClone)}get lastSite(){let ret=this.headSite;for(;null!=ret.next;)ret=ret.next;return ret}*getSegments(){let s0=this.headSite,s1=s0.next;for(;null!=s1;)yield LineSegment.mkPP(s0.point,s1.point),s0=s1,s1=s1.next}*[Symbol.iterator](){let s0=this.headSite;for(;null!=s0;)yield s0.point,s0=s0.next}createCurve(){const curve=new Curve;let a=this.headSite;for(;;){const corner=Curve.findCorner(a);if(null==corner)break;const bezierSeg=SmoothedPolyline.createBezierSegOnSite(corner.b);0==curve.segs.length?point_Point.closeDistEps(a.point,bezierSeg.start)||Curve.addLineSegment(curve,a.point,bezierSeg.start):point_Point.closeDistEps(curve.end,bezierSeg.start)||Curve.continueWithLineSegmentP(curve,bezierSeg.start),curve.addSegment(bezierSeg),a=corner.b}if(0==curve.segs.length)if(point_Point.closeDistEps(a.point,a.next.point)){const w=5;curve.segs.push(new BezierSeg(a.point,a.point.add(new point_Point(w,w)),a.point.add(new point_Point(-w,w)),undefined.point))}else Curve.addLineSegment(curve,a.point,a.next.point);else point_Point.closeDistEps(curve.end,a.next.point)||Curve.continueWithLineSegmentP(curve,a.next.point);return curve}static createBezierSegOnSite(b){const kPrev=b.previouisBezierCoefficient,kNext=b.nextBezierCoefficient,a=b.prev,c=b.next,s=a.point.mul(kPrev).add(b.point.mul(1-kPrev)),e=c.point.mul(kNext).add(b.point.mul(1-kNext)),u=s.mul(b.previousTangentCoefficient).add(b.point.mul(1-b.previousTangentCoefficient)),v=e.mul(b.nextTangentCoefficient).add(b.point.mul(1-b.nextTangentCoefficient));return BezierSeg.mkBezier([s,u,v,e])}}class Arrowhead{constructor(){this.length=Arrowhead.defaultArrowheadLength,this.width=0}clone(){const r=new Arrowhead;return r.length=this.length,r.width=this.width,r.tipPosition=this.tipPosition,r}static calculateArrowheads(edge){if(null==edge.sourceArrowhead&&null==edge.targetArrowhead)return!0;const parStart=Arrowhead.findTrimStartForArrowheadAtSource(edge);if(null==parStart)return!1;const parEnd=Arrowhead.findTrimEndForArrowheadAtTarget(edge);if(null==parEnd)return!1;if(parStart>parEnd-GeomConstants.intersectionEpsilon||Curve.closeIntersectionPoints(edge.curve.value(parStart),edge.curve.value(parEnd)))return!1;const c=edge.curve.trim(parStart,parEnd);return null!=c&&(null!=edge.sourceArrowhead&&(edge.sourceArrowhead.tipPosition=edge.curve.start),null!=edge.targetArrowhead&&(edge.targetArrowhead.tipPosition=edge.curve.end),edge.curve=c,!0)}static getIntersectionsWithArrowheadCircle(curve,arrowheadLength,circleCenter){const e=Ellipse.mkFullEllipseNNP(arrowheadLength,arrowheadLength,circleCenter);return Curve.getAllIntersections(e,curve,!0)}static findTrimEndForArrowheadAtTarget(edgeGeometry){const eps=GeomConstants.distanceEpsilon*GeomConstants.distanceEpsilon;let p=edgeGeometry.curve.parEnd;if(null==edgeGeometry.targetArrowhead||edgeGeometry.targetArrowhead.length<=GeomConstants.distanceEpsilon)return p;const curve=edgeGeometry.curve;let newCurveEnd,intersections,arrowheadLength=edgeGeometry.targetArrowhead.length,reps=10;do{if(reps--,0==reps)return;intersections=Arrowhead.getIntersectionsWithArrowheadCircle(curve,arrowheadLength,curve.end),p=0!=intersections.length?Math.max(...intersections.map((x=>x.par1))):curve.parEnd,newCurveEnd=edgeGeometry.curve.value(p),arrowheadLength/=2}while(newCurveEnd.sub(curve.start).lengthSquared<eps||0==intersections.length);return p}static findTrimStartForArrowheadAtSource(edgeGeometry){if(null==edgeGeometry.sourceArrowhead||edgeGeometry.sourceArrowhead.length<=GeomConstants.distanceEpsilon)return edgeGeometry.curve.parStart;const eps=GeomConstants.distanceEpsilon*GeomConstants.distanceEpsilon;let newStart,arrowheadLength=edgeGeometry.sourceArrowhead.length;const curve=edgeGeometry.curve;let intersections,p,reps=10;for(;--reps>0;){if(intersections=Arrowhead.getIntersectionsWithArrowheadCircle(curve,arrowheadLength,curve.start),0==intersections.length)return curve.parStart;if(p=Math.min(...intersections.map((x=>x.par1))),newStart=intersections.filter((x=>x.par1==p))[0].x,newStart.sub(curve.end).lengthSquared>=eps)return p;arrowheadLength/=2}}static trimSplineAndCalculateArrowheads(edge,spline,narrowestInterval){return Arrowhead.trimSplineAndCalculateArrowheadsII(edge,edge.source.boundaryCurve,edge.target.boundaryCurve,spline,narrowestInterval)}static trimSplineAndCalculateArrowheadsII(edgeGeometry,sourceBoundary,targetBoundary,spline,narrowestInterval){if(edgeGeometry.curve=Curve.trimEdgeSplineWithNodeBoundaries(sourceBoundary,targetBoundary,spline,narrowestInterval),null==edgeGeometry.curve)return!1;if((null==edgeGeometry.sourceArrowhead||edgeGeometry.sourceArrowhead.length<GeomConstants.distanceEpsilon)&&(null==edgeGeometry.targetArrowhead||edgeGeometry.targetArrowhead.length<GeomConstants.distanceEpsilon))return!0;let success=!1;const sourceArrowheadSavedLength=null!=edgeGeometry.sourceArrowhead?edgeGeometry.sourceArrowhead.length:0,targetArrowheadSavedLength=null!=edgeGeometry.targetArrowhead?edgeGeometry.targetArrowhead.length:0,len=edgeGeometry.curve.end.sub(edgeGeometry.curve.start).length;null!=edgeGeometry.sourceArrowhead&&(edgeGeometry.sourceArrowhead.length=Math.min(len,sourceArrowheadSavedLength)),null!=edgeGeometry.targetArrowhead&&(edgeGeometry.targetArrowhead.length=Math.min(len,targetArrowheadSavedLength));let count=10;for(;(null!=edgeGeometry.sourceArrowhead&&edgeGeometry.sourceArrowhead.length>GeomConstants.intersectionEpsilon||null!=edgeGeometry.targetArrowhead&&edgeGeometry.targetArrowhead.length>GeomConstants.intersectionEpsilon)&&!success&&(success=Arrowhead.calculateArrowheads(edgeGeometry),success||(null!=edgeGeometry.sourceArrowhead&&(edgeGeometry.sourceArrowhead.length*=.5),null!=edgeGeometry.targetArrowhead&&(edgeGeometry.targetArrowhead.length*=.5)),count--,0!=count););return success||(null!=edgeGeometry.sourceArrowhead&&(edgeGeometry.sourceArrowhead.tipPosition=spline.start),null!=edgeGeometry.targetArrowhead&&(edgeGeometry.targetArrowhead.tipPosition=spline.end)),null!=edgeGeometry.sourceArrowhead&&(edgeGeometry.sourceArrowhead.length=sourceArrowheadSavedLength),null!=edgeGeometry.targetArrowhead&&(edgeGeometry.targetArrowhead.length=targetArrowheadSavedLength),success}static createBigEnoughSpline(edge){const a=edge.source.center;let b=edge.target.center;const bMinA=b.sub(a);let perp;bMinA.length<.001?(perp=new point_Point(1,0),b=a.add(perp.rotate(Math.PI/2))):perp=bMinA.rotate(Math.PI/2);let maxArrowLength=1;null!=edge.sourceArrowhead&&(maxArrowLength+=edge.sourceArrowhead.length),null!=edge.targetArrowhead&&(maxArrowLength+=edge.targetArrowhead.length),perp=perp.normalize().mul(1.5*maxArrowLength);for(let i=1;i<1e4;i*=2){const seg=Curve.createBezierSegN(a,b,perp,i);if(Arrowhead.trimSplineAndCalculateArrowheadsII(edge,edge.source.boundaryCurve,edge.target.boundaryCurve,seg,!1))return}Arrowhead.createEdgeCurveWithNoTrimming(edge,a,b)}static createEdgeCurveWithNoTrimming(edge,a,b){const ab=b.sub(a).normalize();let lineStart=a,lineEnd=b;const targetArrow=edge.targetArrowhead;null!=targetArrow&&(targetArrow.tipPosition=b,lineEnd=b.sub(ab.mul(targetArrow.length)));const sourceArrow=edge.sourceArrowhead;null!=sourceArrow&&(sourceArrow.tipPosition=a,lineStart=a.add(ab.mul(sourceArrow.length))),edge.curve=LineSegment.mkPP(lineStart,lineEnd)}}Arrowhead.defaultArrowheadLength=5;class GeomEdge extends GeomObject{constructor(edge){super(edge),this.targetArrowhead=new Arrowhead,this.lineWidth=1}Translate(delta){if(0!=delta.x||0!=delta.y){if(null!=this.curve&&this.curve.translate(delta),null!=this.smoothedPolyline)for(let s=this.smoothedPolyline.headSite,s0=this.smoothedPolyline.headSite;null!=s;s=s.next,s0=s0.next)s.point=s0.point.add(delta);null!=this.sourceArrowhead&&(this.sourceArrowhead.tipPosition=this.sourceArrowhead.tipPosition.add(delta)),null!=this.targetArrowhead&&(this.targetArrowhead.tipPosition=this.targetArrowhead.tipPosition.add(delta))}}GetMaxArrowheadLength(){let l=0;return null!=this.sourceArrowhead&&(l=this.sourceArrowhead.length),null!=this.targetArrowhead&&this.targetArrowhead.length>l?this.targetArrowhead.length:l}transform(matrix){if(null!=this.curve){if(this.curve=this.curve.transform(matrix),null!=this.underlyingPolyline)for(let s=this.underlyingPolyline.headSite,s0=this.underlyingPolyline.headSite;null!=s;s=s.next,s0=s0.next)s.point=matrix.multiplyPoint(s.point);null!=this.sourceArrowhead&&(this.sourceArrowhead.tipPosition=matrix.multiplyPoint(this.sourceArrowhead.tipPosition)),null!=this.targetArrowhead&&(this.targetArrowhead.tipPosition=matrix.multiplyPoint(this.targetArrowhead.tipPosition)),null!=this.label&&(this.label.center=matrix.multiplyPoint(this.label.center))}}get labelBBox(){return this.label.boundingBox}get edge(){return this.attrCont}get source(){return GeomObject.getGeom(this.edge.source)}get boundingBox(){const rect=Rectangle.mkEmpty();if(null!=this.underlyingPolyline)for(const p of this.underlyingPolyline)rect.add(p);null!=this.curve&&rect.addRecSelf(this.curve.boundingBox),null!=this.sourceArrowhead&&rect.add(this.sourceArrowhead.tipPosition),null!=this.targetArrowhead&&rect.add(this.targetArrowhead.tipPosition),this.edge.label&&rect.addRecSelf(this.label.boundingBox);const del=this.lineWidth;return rect.left-=del,rect.top+=del,rect.right+=del,rect.bottom-=del,rect}isInterGraphEdge(){return this.edge.isInterGraphEdge()}get target(){return GeomObject.getGeom(this.edge.target)}toString(){return this.source.toString()+"->"+this.target}static RouteSelfEdge(boundaryCurve,howMuchToStickOut,t){const w=boundaryCurve.boundingBox.width,h=boundaryCurve.boundingBox.height,center=boundaryCurve.boundingBox.center,p0=new point_Point(center.x-w/4,center.y),p1=new point_Point(center.x-w/4,center.y-h/2-howMuchToStickOut),p2=new point_Point(center.x+w/4,center.y-h/2-howMuchToStickOut),p3=new point_Point(center.x+w/4,center.y);return t.smoothedPolyline=SmoothedPolyline.mkFromPoints([p0,p1,p2,p3]),t.smoothedPolyline.createCurve()}underCollapsedCluster(){return this.source.underCollapsedCluster()||this.target.underCollapsedCluster()}}class Algorithm{constructor(cancelToken){this.cancelToken=cancelToken}ProgressStep(){}}class PackingConstants{}PackingConstants.GoldenRatio=(1+Math.sqrt(5))/2,PackingConstants.GoldenRatioRemainder=2-PackingConstants.GoldenRatio;class OptimalPacking extends Algorithm{constructor(rectangles,aspectRatio){super(null),this.desiredAspectRatio=1.2,this.bestPacking=null,this.cachedCosts=new Map,this.rectangles=rectangles,this.desiredAspectRatio=aspectRatio}get PackedWidth(){return null!=this.bestPacking?this.bestPacking.PackedWidth:0}get PackedHeight(){return null!=this.bestPacking?this.bestPacking.PackedHeight:0}Pack(lowerBound,upperBound,minGranularity){const c0=OptimalPacking.GetGoldenSectionStep(lowerBound,upperBound),precision=Math.max(minGranularity/10,(upperBound-lowerBound)/OptimalPacking.MaxSteps);upperBound+=precision,this.bestPackingCost=Number.MAX_VALUE,1==this.rectangles.length?this.PackLimit(lowerBound):2==this.rectangles.length?(this.PackLimit(lowerBound),this.PackLimit(upperBound)):this.rectangles.length>2&&OptimalPacking.GoldenSectionSearch((l=>this.PackLimit(l)),lowerBound,c0,upperBound,precision);const newRects=this.bestPacking.getRects();for(let i=0;i<this.rectangles.length;i++)this.rectangles[i]=newRects[i]}PackLimit(limit){let cost=this.cachedCosts.get(limit);if(null==cost){const packing=this.createPacking(this.rectangles,limit);packing.run(),this.cachedCosts.set(limit,cost=Math.abs(packing.PackedAspectRatio-this.desiredAspectRatio)),cost<this.bestPackingCost&&(this.bestPackingCost=cost,this.bestPacking=packing)}return cost}static GoldenSectionSearch(f,x1,x2,x3,precision){if(Math.abs(x1-x3)<precision)return f(x1)<f(x3)?x1:x3;const x4=OptimalPacking.GetGoldenSectionStep(x2,x3),fx2=f(x2),fx4=f(x4),leftSearch=()=>OptimalPacking.GoldenSectionSearch(f,x4,x2,x1,precision),rightSearch=()=>OptimalPacking.GoldenSectionSearch(f,x2,x4,x3,precision);if(fx4<fx2)return rightSearch();if(fx4>fx2)return leftSearch();const right=rightSearch(),left=leftSearch();return f(left)<f(right)?left:right}static GetGoldenSectionStep(x1,x2){return x1<x2?x1+PackingConstants.GoldenRatioRemainder*(x2-x1):x1-PackingConstants.GoldenRatioRemainder*(x1-x2)}}OptimalPacking.MaxSteps=1e3;var VertStatus,lib_src=__webpack_require__("../../../.yarn/berry/cache/stack-typescript-npm-1.0.4-94c4fe7556-10c0.zip/node_modules/stack-typescript/lib/src/index.js");class Packing extends Algorithm{get PackedWidth(){return this.packedWidth}set PackedWidth(value){this.packedWidth=value}get PackedHeight(){return this.packedHeight}set PackedHeight(value){this.packedHeight=value}get PackedAspectRatio(){return this.PackedWidth/this.PackedHeight}getRects(){const ret=[];for(const[r,center]of this.rectsToCenters)r.center=center,ret.push(r);return ret}}class GreedyRectanglePacking extends Packing{constructor(rectangles,wrapWidth,rectanglesPresorted=!1){super(null),this.rectsToCenters=new Map,this.rectanglesByDescendingHeight=rectanglesPresorted?rectangles:GreedyRectanglePacking.SortRectangles(rectangles),this.wrapWidth=wrapWidth}static SortRectangles(rectangles){return rectangles.sort(((a,b)=>b.height-a.height)),rectangles}run(){this.Pack()}Pack(){this.PackedWidth=0,this.PackedHeight=0;const stack=new lib_src.B;let wrap=!1,verticalPosition=0,packedWidth=0,packedHeight=0;const rects=this.rectanglesByDescendingHeight;for(let i=0;wrap||i<rects.length;){const r=rects[i],parent=stack.length>0?stack.top:null;if(null==parent||parent.right+r.width<=this.wrapWidth&&verticalPosition+r.height<=parent.top){const center=new point_Point(parent?parent.right:0,verticalPosition).add(new point_Point(r.width/2,r.height/2));r.center=center,this.rectsToCenters.set(r,center),packedWidth=Math.max(packedWidth,r.right),packedHeight=Math.max(packedHeight,r.top),stack.push(r),wrap=!1}else verticalPosition=parent.top,stack.pop(),wrap=!0;wrap||i++}this.PackedWidth=packedWidth,this.PackedHeight=packedHeight}}class OptimalRectanglePacking extends OptimalPacking{constructor(rectangles,aspectRatio){super(GreedyRectanglePacking.SortRectangles(rectangles),aspectRatio),this.createPacking=(rs,width)=>new GreedyRectanglePacking(rs,width,!0)}run(){let minRectWidth=Number.MAX_VALUE,maxRectWidth=0,totalWidth=0;for(const r of this.rectangles){const width=r.width;totalWidth+=width,minRectWidth=Math.min(minRectWidth,width),maxRectWidth=Math.max(maxRectWidth,width)}this.Pack(maxRectWidth,totalWidth,minRectWidth)}}function GeomGraph_optimalPackingRunner(geomGraph,subGraphs){const originalLeftBottoms=new Array;for(const g of subGraphs)originalLeftBottoms.push({g:g,lb:g.boundingBox.leftBottom.clone()});const rectangles=subGraphs.map((g=>g.boundingBox)),packing=new OptimalRectanglePacking(rectangles,1.5);packing.run();for(const{g:g,lb:lb}of originalLeftBottoms){const delta=g.boundingBox.leftBottom.sub(lb);g.translate(delta)}geomGraph.boundingBox=new Rectangle({left:0,bottom:0,right:packing.PackedWidth,top:packing.PackedHeight}),geomGraph.addLabelToGraphBB(geomGraph.boundingBox)}class GeomGraph extends GeomNode{constructor(graph){super(graph),this.MinimalWidth=0,this.MinimalHeight=0,this.Margins=10}isEmpty(){return this.graph.isEmpty()}setSettingsRecursively(ls){this.layoutSettings=ls;for(const n of this.deepNodes()){n.layoutSettings=ls}}get layoutSettings(){return this._layoutSettings}set layoutSettings(value){this._layoutSettings=value}translate(delta){if(0==delta.x&&0==delta.y)return;const m=new PlaneTransformation(1,0,delta.x,0,1,delta.y);this.transform(m)}get labelSize(){return this._labelSize}set labelSize(value){this._labelSize=value}get boundingBox(){return this._boundingBox}set boundingBox(value){this._boundingBox=value}get isGraph(){return!0}transform(matrix,updateBoundingBox=!0){if(!matrix.isIdentity()){null!=this.boundaryCurve&&(this.boundaryCurve=this.boundaryCurve.transform(matrix));for(const n of this.shallowNodes())n.transform(matrix,updateBoundingBox);for(const e of this.edges())e.transform(matrix);updateBoundingBox&&this.updateBoundingBox()}}*deepNodes(){for(const n of this.graph.deepNodes)yield GeomObject.getGeom(n)}setEdge(s,t){const structEdge=this.graph.setEdge(s,t);return new GeomEdge(structEdge)}pumpTheBoxToTheGraphWithMargins(minSeparation){const t={b:Rectangle.mkEmpty()};return this.pumpTheBoxToTheGraph(t),t.b.pad(Math.max(this.Margins,minSeparation)),this.MinimalWidth>0&&(t.b.width=Math.max(t.b.width,this.MinimalWidth)),this.MinimalHeight>0&&(t.b.height=Math.max(t.b.height,this.MinimalHeight)),this._boundingBox=t.b,t.b}get center(){return this.boundingBox?this.boundingBox.center:new point_Point(0,0)}set center(value){const del=value.sub(this.center),t=new PlaneTransformation(1,0,del.x,0,1,del.y);this.transform(t)}pumpTheBoxToTheGraph(t){for(const e of this.edges())if(!e.underCollapsedCluster()){if(null!=e.curve){const cb=e.curve.boundingBox;cb.pad(e.lineWidth),t.b.addRecSelf(cb)}null!=e.label&&t.b.addRecSelf(e.label.boundingBox)}for(const n of this.shallowNodes())!n.underCollapsedCluster()&&n.boundingBox&&t.b.addRecSelf(n.boundingBox)}get left(){return this.boundingBox.left}get right(){return this.boundingBox.right}get top(){return this.boundingBox.top}get bottom(){return this.boundingBox.bottom}CheckClusterConsistency(){throw new Error("Method not implemented.")}get edgeCount(){return this.graph.edgeCount}*shallowNodes(){for(const n of this.graph.shallowNodes)yield GeomObject.getGeom(n)}*edges(){for(const n of this.graph.edges)yield GeomObject.getGeom(n)}*deepEdges(){for(const e of this.graph.deepEdges())yield GeomObject.getGeom(e)}static mk(id,labelSize=new Size(0,0)){const g=new GeomGraph(new Graph(id));return g.labelSize=labelSize,g}*subgraphs(){for(const g of this.graph.subgraphs())yield GeomObject.getGeom(g)}static mkWithGraphAndLabel(graph,labelSize){const g=new GeomGraph(graph);return g.labelSize=labelSize,g}get height(){return this.boundingBox.height}get width(){return this.boundingBox.width}get shallowNodeCount(){return this.graph.shallowNodeCount}get graph(){return this.attrCont}liftNode(n){const liftedNode=this.graph.liftNode(n.node);return liftedNode?GeomObject.getGeom(liftedNode):null}findNode(id){const n=this.graph.findNode(id);return n?GeomObject.getGeom(n):null}addNode(gn){return this.graph.addNode(gn.node),gn}updateBoundingBox(){if(this.graph.isEmpty())return;const rect=Rectangle.mkEmpty();let padding=0;for(const e of this.graph.edges){const ge=GeomObject.getGeom(e);null!=ge.curve&&(rect.addRecSelf(ge.boundingBox),padding=Math.max(padding,ge.lineWidth))}for(const gn of this.shallowNodes())gn.boundingBox&&(rect.addRecSelf(gn.boundingBox),padding=Math.max(padding,gn.padding));this.addLabelToGraphBB(rect),rect.pad(Math.max(padding,this.Margins)),this.boundingBox=rect}addLabelToGraphBB(rect){this.labelSize&&(rect.top+=this.labelSize.height+2,rect.width<this.labelSize.width&&(rect.width=this.labelSize.width))}FlipYAndMoveLeftTopToOrigin(){const m=new PlaneTransformation(1,0,-this.left,0,-1,this.top);this.transform(m,!1);for(const v of this.deepNodes())if(v.isGraph){if(!v.graph.isEmpty()){const bb=v.boundingBox;v.boundingBox=Rectangle.mkSizeCenter(new Size(bb.width,bb.height),m.multiplyPoint(bb.center))}}const bb=this.boundingBox;this.boundingBox=Rectangle.mkSizeCenter(new Size(bb.width,bb.height),m.multiplyPoint(bb.center))}}function mkGraphOnEdges(edges){const n=new BasicGraphOnEdges;return n.SetEdges(edges,BasicGraphOnEdges.vertexCount(edges)),n}function mkGraphOnEdgesArray(edges){const n=new BasicGraphOnEdges;return n.SetEdges(edges,BasicGraphOnEdges.vertexCount(edges)),n}function mkGraphOnEdgesN(edges,numberOfVerts){const n=new BasicGraphOnEdges;return n.SetEdges(edges,numberOfVerts),n}class BasicGraphOnEdges{constructor(){this.nodeCount=0}*incidentEdges(v){for(const e of this.outEdges[v])yield e;for(const e of this.inEdges[v])yield e}static deleteFromArray(arr,obj){const index=arr.indexOf(obj,0);index>-1&&arr.splice(index,1)}removeEdge(edge){BasicGraphOnEdges.deleteFromArray(this.edges,edge),edge.source!=edge.target?(BasicGraphOnEdges.deleteFromArray(this.outEdges[edge.source],edge),BasicGraphOnEdges.deleteFromArray(this.inEdges[edge.target],edge)):BasicGraphOnEdges.deleteFromArray(this.selfEdges[edge.source],edge)}static vertexCount(edges){let nov=0;for(const ie of edges)ie.source>=nov&&(nov=ie.source),ie.target>=nov&&(nov=ie.target);return++nov}SetEdges(valEdges,nov){this.edges=valEdges,this.nodeCount=nov;const outEdgesCounts=new Array(this.nodeCount).fill(0),inEdgesCounts=new Array(this.nodeCount).fill(0),selfEdgesCounts=new Array(this.nodeCount).fill(0);this.outEdges=new Array(this.nodeCount),this.inEdges=new Array(this.nodeCount),this.selfEdges=new Array(this.nodeCount);for(const e of this.edges)e.source!=e.target?(outEdgesCounts[e.source]++,inEdgesCounts[e.target]++):selfEdgesCounts[e.source]++;for(let i=0;i<this.nodeCount;i++)this.outEdges[i]=new Array(outEdgesCounts[i]),outEdgesCounts[i]=0,this.inEdges[i]=new Array(inEdgesCounts[i]),inEdgesCounts[i]=0,this.selfEdges[i]=new Array(selfEdgesCounts[i]),selfEdgesCounts[i]=0;for(const e of this.edges){const u=e.source,v=e.target;u!=v?(this.outEdges[u][outEdgesCounts[u]++]=e,this.inEdges[v][inEdgesCounts[v]++]=e):this.selfEdges[u][selfEdgesCounts[u]++]=e}}inEdgesCount(node){return this.inEdges[node].length}outEdgesCount(node){return this.outEdges[node].length}selfEdgesCount(node){return this.selfEdges[node].length}addEdge(e){this.edges.push(e),e.source!=e.target?(this.outEdges[e.source].push(e),this.inEdges[e.target].push(e)):this.selfEdges[e.source].push(e)}*nodesOfConnectedGraph(){if(0==this.edges.length)return;const enqueed=new Set,q=new src.o;let i=this.edges[0].source;for(BasicGraphOnEdges.enqueue(enqueed,q,i),yield i;q.length>0;){i=q.dequeue();for(const e of this.outEdges[i]){const s=e.target;enqueed.has(s)||(BasicGraphOnEdges.enqueue(enqueed,q,s),yield s)}for(const e of this.inEdges[i]){const s=e.source;enqueed.has(s)||(BasicGraphOnEdges.enqueue(enqueed,q,s),yield s)}}}*pred(n){for(const e of this.inEdges[n])yield e.source}*succ(n){for(const e of this.outEdges[n])yield e.target}static enqueue(enqueed,q,i){q.enqueue(i),enqueed.add(i)}}class IntPair{constructor(x,y){this.x=x,this.y=y}get source(){return this.x}get target(){return this.y}isDiagonal(){return this.x==this.y}}class IntPairMap{constructor(n){this.arrayOfMaps=new Array(n);for(let i=0;i<n;i++)this.arrayOfMaps[i]=new Map}set(x,y,v){this.arrayOfMaps[x].set(y,v)}setPair(p,v){this.set(p.x,p.y,v)}delete(x,y){x<0||x>=this.arrayOfMaps.length||this.arrayOfMaps[x].delete(y)}has(x,y){return!(x<0||x>=this.arrayOfMaps.length)&&this.arrayOfMaps[x].has(y)}get(x,y){return x<0||x>=this.arrayOfMaps.length?null:this.arrayOfMaps[x].get(y)}getI(p){return this.get(p.x,p.y)}*keys(){for(let i=0;i<this.arrayOfMaps.length;i++){const map=this.arrayOfMaps[i];for(const p of map)yield new IntPair(i,p[0])}}*keyValues(){for(let i=0;i<this.arrayOfMaps.length;i++){const map=this.arrayOfMaps[i];for(const p of map)yield[new IntPair(i,p[0]),p[1]]}}*values(){for(let i=0;i<this.arrayOfMaps.length;i++){const map=this.arrayOfMaps[i];for(const p of map)yield p[1]}}}!function(VertStatus){VertStatus[VertStatus.NotVisited=0]="NotVisited",VertStatus[VertStatus.InStack=1]="InStack",VertStatus[VertStatus.Visited=2]="Visited"}(VertStatus||(VertStatus={}));class StackStruct{constructor(v,i){this.v=v,this.i=i}}class CycleRemoval{static getFeedbackSetWithConstraints(arg0,arg1){throw new Error("Method not implemented.")}static push(stack,status,v,i){status[v]=VertStatus.InStack,stack.push(new StackStruct(v,i))}static getFeedbackSet(graph){const feedbackSet=new IntPairMap(graph.nodeCount);if(null==graph||0==graph.nodeCount)return[];const status=new Array(graph.nodeCount).fill(VertStatus.NotVisited);for(let vertex=0;vertex<graph.nodeCount;vertex++){if(status[vertex]==VertStatus.Visited)continue;const stack=new lib_src.B;let i=0;for(CycleRemoval.push(stack,status,vertex,i);stack.size>0;){const s=stack.pop();vertex=s.v,status[vertex]=VertStatus.Visited,i=s.i;let outEnum=graph.outEdges[vertex];for(;i<outEnum.length;i++){const e=outEnum[i];if(e.source==e.target)continue;const targetStatus=status[e.target];targetStatus==VertStatus.InStack?feedbackSet.set(e.source,e.target,e):targetStatus==VertStatus.NotVisited&&(CycleRemoval.push(stack,status,vertex,i+1),vertex=e.target,status[e.target]=VertStatus.Visited,outEnum=graph.outEdges[vertex],i=-1)}}}return Array.from(feedbackSet.values())}}var LayerDirectionEnum,EdgeRoutingMode,SnapToGridByY,ReadonlyContainer,Container,ReadonlyCollection,Collection,ReadonlyIndexedCollection,FixedSizeIndexedCollection,IndexedCollection,ReadonlyKeyedContainer,KeyedContainer,ReadonlyKeyedCollection,KeyedCollection,ReadonlyKeyedMultiCollection,KeyedMultiCollection,dist=__webpack_require__("../../../.yarn/berry/cache/typescript-string-operations-npm-1.5.1-ec02792a09-10c0.zip/node_modules/typescript-string-operations/dist/index.js");class LayerEdge{constructor(source,target,crossingWeight,weight=1){this.Source=source,this.Target=target,this.CrossingWeight=crossingWeight,this.Weight=weight}toString(){return dist.Qf.Format("{0}->{1}",this.Source,this.Target)}}class Routing{static FindClosestPoints(segmentInFrontOfLabel,labelSide){const minDistOutput=Curve.minDistWithinIntervals(segmentInFrontOfLabel,labelSide,segmentInFrontOfLabel.parStart,segmentInFrontOfLabel.parEnd,labelSide.parStart,labelSide.parEnd,(segmentInFrontOfLabel.parStart+segmentInFrontOfLabel.parEnd)/2,(labelSide.parStart+labelSide.parEnd)/2);if(minDistOutput)return{curveClosestPoint:minDistOutput.aX,labelSideClosest:minDistOutput.bX}}static GetSegmentInFrontOfLabel(edgeCurve,labelY){if(edgeCurve instanceof Curve)for(const seg of edgeCurve.segs)if((seg.start.y-labelY)*(seg.end.y-labelY)<=0)return seg;return null}static ShiftLabel(e,curveClosestPoint,labelSideClosest){const w=e.lineWidth/2,shift=curveClosestPoint.sub(labelSideClosest),shiftLength=shift.length;shiftLength>w&&(e.label.center=e.label.center.add(shift.div(shiftLength*(shiftLength-w))))}static updateLabel(e,anchor){let labelSide=null;anchor.labelIsToTheRightOfTheSpline?(e.label.center=new point_Point(anchor.x+anchor.rightAnchor/2,anchor.y),labelSide=LineSegment.mkPP(e.labelBBox.leftTop,e.labelBBox.leftBottom)):anchor.labelIsToTheLeftOfTheSpline&&(e.label.center=new point_Point(anchor.x-anchor.leftAnchor/2,anchor.y),labelSide=LineSegment.mkPP(e.labelBBox.rightTop,e.labelBBox.rightBottom));const segmentInFrontOfLabel=Routing.GetSegmentInFrontOfLabel(e.curve,e.label.center.y);if(null!=segmentInFrontOfLabel&&0==Curve.getAllIntersections(e.curve,Curve.polyFromBox(e.labelBBox),!1).length){const t=Routing.FindClosestPoints(segmentInFrontOfLabel,labelSide);if(t)Routing.ShiftLabel(e,t.curveClosestPoint,t.labelSideClosest);else{let curveClosestPoint,labelSideClosest;const u=segmentInFrontOfLabel.closestParameter(labelSide.start),v=segmentInFrontOfLabel.closestParameter(labelSide.end);segmentInFrontOfLabel.value(u).sub(labelSide.start).length<segmentInFrontOfLabel.value(v).sub(labelSide.end).length?(curveClosestPoint=segmentInFrontOfLabel.value(u),labelSideClosest=labelSide.start):(curveClosestPoint=segmentInFrontOfLabel.value(v),labelSideClosest=labelSide.end),Routing.ShiftLabel(e,curveClosestPoint,labelSideClosest)}}}}class PolyIntEdge{constructor(source,target,geomEdge,weight=1,separation=1){this.reversed=!1,this.source=source,this.target=target,this.edge=geomEdge,this.weight=weight,this.separation=separation}get CrossingWeight(){return 1}get hasLabel(){return null!=this.edge.label}get labelWidth(){return this.edge.label.width}get labelHeight(){return this.edge.label.height}reverse(){const t=this.source;this.source=this.target,this.target=t,this.reversed=!this.reversed}toString(){return"edge("+this.source+"->"+this.target+")"}get curve(){return this.edge.curve}set curve(value){this.edge.curve=value}get underlyingPolyline(){return this.edge.underlyingPolyline}set underlyingPolyline(value){this.edge.underlyingPolyline=value}get LayerSpan(){return null!=this.LayerEdges?this.LayerEdges.length:0}isSelfEdge(){return this.source==this.target}reversedClone(){const ret=new PolyIntEdge(this.target,this.source,this.edge);if(null!=this.LayerEdges){const len=this.LayerEdges.length;ret.LayerEdges=new Array(len);for(let i=0;i<len;i++){const le=this.LayerEdges[len-1-i];ret.LayerEdges[i]=new LayerEdge(le.Target,le.Source,le.CrossingWeight)}ret.LayerEdges[0].Source=this.target,ret.LayerEdges[this.LayerEdges.length-1].Target=this.source}return ret}get count(){return this.LayerEdges.length}getNode(i){if(i>=0){if(i<this.LayerEdges.length)return this.LayerEdges[i].Source;if(i==this.LayerEdges.length)return this.LayerEdges[i-1].Target}throw new Error("wrong index "+i)}updateEdgeLabelPosition(anchors){if(null!=this.edge.label){const m=this.LayerEdges.length/2,layerEdge=this.LayerEdges[m];Routing.updateLabel(this.edge,anchors[layerEdge.Source])}}[Symbol.iterator](){return this.nodes()}*nodes(){yield this.LayerEdges[0].Source;for(const le of this.LayerEdges)yield le.Target}}class IntPairSet{constructor(){this.arrayOfSets=new Array}has(p){return this.hasxy(p.x,p.y)}remove(p){if(!(p.x<0||p.x>=this.arrayOfSets.length))return this.arrayOfSets[p.x].delete(p.y)}hasxy(x,y){if(x<0||x>=this.arrayOfSets.length)return!1;const s=this.arrayOfSets[x];return null!=s&&s.has(y)}static mk(ps){const r=new IntPairSet;for(const p of ps)r.add(p);return r}*values(){for(let i=0;i<this.arrayOfSets.length;i++){const arr=this.arrayOfSets[i];if(arr)for(const j of arr.values())yield new IntPair(i,j)}}add(p){let s=this.arrayOfSets[p.x];null==s&&(this.arrayOfSets[p.x]=s=new Set),s.add(p.y)}addNN(x,y){let s=this.arrayOfSets[x];null==s&&(this.arrayOfSets[x]=s=new Set),s.add(y)}clear(){for(const s of this.arrayOfSets)s&&s.clear()}}function*GetConnectedComponents(graph){const enqueueed=new Array(graph.nodeCount).fill(!1),queue=new src.o;for(let i=0;i<graph.nodeCount;i++)if(!enqueueed[i]){const nodes=new Array;for(Enqueue(i,queue,enqueueed);queue.length>0;){const s=queue.dequeue();nodes.push(s);for(const neighbor of Neighbors(graph,s))Enqueue(neighbor,queue,enqueueed)}yield nodes}}function*Neighbors(graph,s){for(const e of graph.outEdges[s])yield e.target;for(const e of graph.inEdges[s])yield e.source}function Enqueue(i,q,enqueueed){0==enqueueed[i]&&(q.enqueue(i),enqueueed[i]=!0)}class VerticalConstraintsForSugiyama{constructor(){this.maxLayerOfGeomGraph=new Set,this.minLayerOfGeomGraph=new Set,this.sameLayerConstraints=new Array,this.upDownConstraints=new Array,this.gluedUpDownIntConstraints=new IntPairSet,this.sameLayerDictionaryOfRepresentatives=new Map,this.representativeToItsLayer=new Map,this.maxLayerInt=new Array,this.minLayerInt=new Array,this.sameLayerInts=new Array,this.upDownInts=new Array}getFeedbackSetExternal(intGraph,nodeIdToIndex){throw new Error("Method not implemented.")}pinNodeToMaxLayer(node){this.maxLayerOfGeomGraph.add(node)}pinNodeToMinLayer(node){this.minLayerOfGeomGraph.add(node)}get isEmpty(){return 0==this.maxLayerOfGeomGraph.size&&0==this.minLayerOfGeomGraph.size&&0==this.sameLayerConstraints.length&&0==this.upDownConstraints.length}clear(){this.maxLayerOfGeomGraph.clear(),this.minLayerOfGeomGraph.clear(),this.sameLayerConstraints=[],this.upDownConstraints=[]}getFeedbackSetImp(intGraph,nodeIdToIndex){return this.nodeIdToIndex=nodeIdToIndex,this.intGraph=intGraph,this.maxRepresentative=-1,this.minRepresentative=-1,this.createIntegerConstraints(),this.glueTogetherSameConstraintsMaxAndMin(),this.addMaxMinConstraintsToGluedConstraints(),this.removeCyclesFromGluedConstraints(),this.getFeedbackSet()}removeCyclesFromGluedConstraints(){const graph=mkGraphOnEdgesN(Array.from(this.gluedUpDownIntConstraints.values()),this.intGraph.nodeCount),feedbackSet=CycleRemoval.getFeedbackSetWithConstraints(graph,null);for(const p of feedbackSet)this.gluedUpDownIntConstraints.remove(p)}addMaxMinConstraintsToGluedConstraints(){if(-1!=this.maxRepresentative)for(let i=0;i<this.intGraph.nodeCount;i++){const j=this.nodeToRepr(i);j!=this.maxRepresentative&&this.gluedUpDownIntConstraints.add(new IntPair(this.maxRepresentative,j))}if(-1!=this.minRepresentative)for(let i=0;i<this.intGraph.nodeCount;i++){const j=this.nodeToRepr(i);j!=this.minRepresentative&&this.gluedUpDownIntConstraints.add(new IntPair(j,this.minRepresentative))}}glueTogetherSameConstraintsMaxAndMin(){this.createDictionaryOfSameLayerRepresentatives();this.upDownInts.map(this.gluedIntPairNN);this.gluedUpDownIntConstraints=new IntPairSet}gluedIntPairNN(p){return new IntPair(this.nodeToRepr(p[0]),this.nodeToRepr(p[1]))}gluedIntPairI(p){return new IntPair(this.nodeToRepr(p.source),this.nodeToRepr(p.target))}gluedIntPair(p){return new IntPair(this.nodeToRepr(p.source),this.nodeToRepr(p.target))}gluedIntEdge(intEdge){const sourceRepr=this.nodeToRepr(intEdge.source),targetRepr=this.nodeToRepr(intEdge.target),ie=new PolyIntEdge(sourceRepr,targetRepr,intEdge.edge);return ie.separation=intEdge.separation,ie.weight=0,ie}nodeToRepr(node){const repr=this.sameLayerDictionaryOfRepresentatives.get(node);return repr||node}createDictionaryOfSameLayerRepresentatives(){const graphOfSameLayers=this.createGraphOfSameLayers();for(const comp of GetConnectedComponents(graphOfSameLayers))this.glueSameLayerNodesOfALayer(comp)}createGraphOfSameLayers(){return mkGraphOnEdgesN(this.createEdgesOfSameLayers(),this.intGraph.nodeCount)}createEdgesOfSameLayers(){const ret=new Array;return-1!=this.maxRepresentative&&this.maxLayerInt.filter((v=>v!=this.maxRepresentative)).map((v=>new IntPair(this.maxRepresentative,v))).forEach((p=>ret.push(p))),-1!=this.minRepresentative&&this.minLayerInt.filter((v=>v!=this.minRepresentative)).map((v=>new IntPair(this.minRepresentative,v))).forEach((p=>ret.push(p))),this.sameLayerInts.forEach((t=>ret.push(new IntPair(t[0],t[1])))),ret}glueSameLayerNodesOfALayer(sameLayerNodes){if(sameLayerNodes.length>1){let representative=-1;if(this.componentsIsMaxLayer(sameLayerNodes))for(const v of sameLayerNodes)this.sameLayerDictionaryOfRepresentatives.set(v,representative=this.maxRepresentative);else if(this.componentIsMinLayer(sameLayerNodes))for(const v of sameLayerNodes)this.sameLayerDictionaryOfRepresentatives.set(v,representative=this.minRepresentative);else for(const v of sameLayerNodes)-1==representative&&(representative=v),this.sameLayerDictionaryOfRepresentatives.set(v,representative);this.representativeToItsLayer.set(representative,sameLayerNodes)}}componentIsMinLayer(component){return component.findIndex((p=>this.minRepresentative==p))>=0}componentsIsMaxLayer(component){return component.findIndex((p=>this.maxRepresentative==p))>=0}createIntegerConstraints(){this.createMaxIntConstraints(),this.createMinIntConstraints(),this.createUpDownConstraints(),this.createSameLayerConstraints()}createSameLayerConstraints(){this.sameLayerInts=this.createIntConstraintsFromStringCouples(this.sameLayerConstraints)}createUpDownConstraints(){this.upDownInts=this.createIntConstraintsFromStringCouples(this.upDownConstraints)}createIntConstraintsFromStringCouples(list){return list.map((couple=>[this.nodeIndex(couple[0]),this.nodeIndex(couple[1])])).filter((t=>-1!=t[0]&&-1!=t[1]))}createMinIntConstraints(){this.minLayerInt=this.createIntConstraintsFromExtremeLayer(this.minLayerOfGeomGraph),this.minLayerInt.length>0&&(this.minRepresentative=this.minLayerInt[0])}createMaxIntConstraints(){this.maxLayerInt=this.createIntConstraintsFromExtremeLayer(this.maxLayerOfGeomGraph),this.maxLayerInt.length>0&&(this.maxRepresentative=this.maxLayerInt[0])}createIntConstraintsFromExtremeLayer(setOfNodes){return Array.from(setOfNodes).map((n=>this.nodeIndex(n))).filter((i=>-1!=i))}nodeIndex(node){const index=this.nodeIdToIndex.get(node.node.id);return index||-1}getFeedbackSet(){return this.gluedIntGraph=this.createGluedGraph(),Array.from(this.unglueIntPairs(CycleRemoval.getFeedbackSetWithConstraints(this.gluedIntGraph,this.gluedUpDownIntConstraints)))}*unglueIntPairs(gluedEdges){for(const gluedEdge of gluedEdges)for(const ungluedEdge of this.unglueEdge(gluedEdge))yield ungluedEdge}*unglueEdge(gluedEdge){for(const source of this.unglueNode(gluedEdge.source))for(const edge of this.intGraph.outEdges[source])this.nodeToRepr(edge.target)==gluedEdge.target&&(yield edge)}createGluedGraph(){const set=new IntPairSet;return this.intGraph.edges.forEach((e=>set.add(this.gluedIntPairI(e)))),mkGraphOnEdgesN(Array.from(set.values()),this.intGraph.nodeCount)}unglueNode(node){const layer=this.representativeToItsLayer.get(node);return layer||[node]}getGluedNodeCounts(){const ret=new Array(this.nodeIdToIndex.size).fill(0);for(let node=0;node<ret.length;node++)ret[this.nodeToRepr(node)]++;return ret}}class HorizontalConstraintsForSugiyama{constructor(){this.leftRightConstraints=new Array,this.leftRightNeighbors=new Array,this.nodeToBlockRoot=new Map,this.upDownVerticalConstraints=new Array,this.BlockRootToBlock=new Map}get IsEmpty(){return 0==this.leftRightNeighbors.length&&0==this.upDownVerticalConstraints.length&&0==this.leftRightConstraints.length}AddSameLayerNeighbors(neighbors){for(let i=0;i<neighbors.length-1;i++)this.AddSameLayerNeighborsPair(neighbors[i],neighbors[i+1])}AddSameLayerNeighborsPair(leftNode,rightNode){this.leftRightNeighbors.push([leftNode,rightNode])}NodeToBlockRootSoft(i){const blockRoot=this.nodeToBlockRoot.get(i);return blockRoot||i}CreateMappingOfNeibBlocks(){const graph=this.BasicGraphFromLeftRightIntNeibs();for(let root=0;root<graph.nodeCount;root++)if(0==graph.inEdges[root].length&&!this.nodeToBlockRoot.has(root)){const block=new Array;let current=root;for(let outEdges=graph.outEdges[current];outEdges.length>0;outEdges=graph.outEdges[current])current=outEdges[0].y,block.push(current),this.nodeToBlockRoot.set(current,root);block.length>0&&this.BlockRootToBlock.set(root,block)}}BasicGraphFromLeftRightIntNeibs(){return mkGraphOnEdges(Array.from(this.LeftRightIntNeibs.values()).map((p=>new IntPair(p.x,p.y))))}NodeIndex(node){const index=this.nodeIdToIndex.get(node.id);return index||-1}PrepareForOrdering(nodeToIndexParameter,yLayers){this.nodeIdToIndex=nodeToIndexParameter,this.MapNodesToToIntegers(yLayers),this.CreateMappingOfNeibBlocks(),this.LiftLeftRightRelationsToNeibBlocks()}LiftLeftRightRelationsToNeibBlocks(){this.LeftRighInts=IntPairSet.mk(this.leftRightConstraints.map((p=>function mktuple(a,b){return[a,b]}(this.NodeIndex(p[0]),this.NodeIndex(p[1])))).filter((p=>-1!=p[0]&&-1!=p[1])).map((ip=>new IntPair(this.NodeToBlockRootSoft(ip[0]),this.NodeToBlockRootSoft(ip[1])))).filter((ip=>ip.x!=ip.x)));const feedbackSet=CycleRemoval.getFeedbackSet(mkGraphOnEdges(Array.from(this.LeftRighInts.values())));for(const ip of feedbackSet)this.LeftRighInts.remove(new IntPair(ip.source,ip.target))}MapNodesToToIntegers(yLayers){this.LeftRightIntNeibs=IntPairSet.mk(Array.from(this.leftRightNeighbors.values()).map((p=>[this.NodeIndex(p[0]),this.NodeIndex(p[1])])).filter((t=>-1!=t[0]&&-1!=t[1])).map((t=>new IntPair(t[0],t[1])))),this.VerticalInts=IntPairSet.mk(this.upDownVerticalConstraints.map((p=>[this.NodeIndex(p[0]),this.NodeIndex(p[1])])).filter((p=>-1!=p[0]&&-1!=p[1]&&yLayers[p[0]]>yLayers[p[1]])).map((p=>new IntPair(p[0],p[1]))))}}!function(LayerDirectionEnum){LayerDirectionEnum[LayerDirectionEnum.TB=0]="TB",LayerDirectionEnum[LayerDirectionEnum.LR=1]="LR",LayerDirectionEnum[LayerDirectionEnum.BT=2]="BT",LayerDirectionEnum[LayerDirectionEnum.RL=3]="RL",LayerDirectionEnum[LayerDirectionEnum.None=4]="None"}(LayerDirectionEnum||(LayerDirectionEnum={}));class BundlingSettings{constructor(){this.capacityOverflowCoefficient=BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier,this.RotateBundles=!1,this.MaxHubRadius=50,this.MinHubRadius=.1,this.CreateUnderlyingPolyline=!1,this.pathLengthImportance=BundlingSettings.DefaultPathLengthImportance,this.inkImportance=BundlingSettings.DefaultInkImportance,this.edgeSeparation=BundlingSettings.DefaultEdgeSeparation,this.angleThreshold=Math.PI/180*45,this.hubRepulsionImportance=100,this.bundleRepulsionImportance=100,this.minimalRatioOfGoodCdtEdges=.9,this.highestQuality=!0,this.KeepOriginalSpline=!1,this.KeepOverlaps=!1,this.StopAfterShortestPaths=!1}get CapacityOverflowCoefficient(){return this.capacityOverflowCoefficient}set CapacityOverflowCoefficient(value){this.capacityOverflowCoefficient=value}get PathLengthImportance(){return this.pathLengthImportance}set PathLengthImportance(value){this.pathLengthImportance=value}get InkImportance(){return this.inkImportance}set InkImportance(value){this.inkImportance=value}get EdgeSeparation(){return this.edgeSeparation}set EdgeSeparation(value){this.edgeSeparation=value}get UseCubicBezierSegmentsInsideOfHubs(){return this.useCubicBezierSegmentsInsideOfHubs}set UseCubicBezierSegmentsInsideOfHubs(value){this.useCubicBezierSegmentsInsideOfHubs=value}get AngleThreshold(){return this.angleThreshold}set AngleThreshold(value){this.angleThreshold=value}get HubRepulsionImportance(){return this.hubRepulsionImportance}set HubRepulsionImportance(value){this.hubRepulsionImportance=value}get BundleRepulsionImportance(){return this.bundleRepulsionImportance}set BundleRepulsionImportance(value){this.bundleRepulsionImportance=value}get MinimalRatioOfGoodCdtEdges(){return this.minimalRatioOfGoodCdtEdges}set MinimalRatioOfGoodCdtEdges(value){this.minimalRatioOfGoodCdtEdges=value}get HighestQuality(){return this.highestQuality}set HighestQuality(value){this.highestQuality=value}}BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier=1e3,BundlingSettings.DefaultPathLengthImportance=500,BundlingSettings.DefaultInkImportance=.01,BundlingSettings.DefaultEdgeSeparation=.5,function(EdgeRoutingMode){EdgeRoutingMode[EdgeRoutingMode.Spline=0]="Spline",EdgeRoutingMode[EdgeRoutingMode.SplineBundling=1]="SplineBundling",EdgeRoutingMode[EdgeRoutingMode.StraightLine=2]="StraightLine",EdgeRoutingMode[EdgeRoutingMode.SugiyamaSplines=3]="SugiyamaSplines",EdgeRoutingMode[EdgeRoutingMode.Rectilinear=4]="Rectilinear",EdgeRoutingMode[EdgeRoutingMode.RectilinearToCenter=5]="RectilinearToCenter",EdgeRoutingMode[EdgeRoutingMode.None=6]="None"}(EdgeRoutingMode||(EdgeRoutingMode={}));class EdgeRoutingSettings{constructor(){this.coneAngle=Math.PI/180*30,this.padding=3,this.polylinePadding=1.5,this.routingToParentConeAngle=Math.PI/6,this.simpleSelfLoopsForParentEdgesThreshold=200,this.incrementalRoutingThreshold=5e6,this.routeMultiEdgesAsBundles=!0,this.KeepOriginalSpline=!1,this.EdgeRoutingMode=EdgeRoutingMode.Spline}get EdgeRoutingMode(){return this.edgeRoutingMode}set EdgeRoutingMode(value){value==EdgeRoutingMode.SplineBundling&&null==this.BundlingSettings&&null==this.BundlingSettings&&(this.BundlingSettings=new BundlingSettings),this.edgeRoutingMode=value}get ConeAngle(){return this.coneAngle}set ConeAngle(value){this.coneAngle=value}get Padding(){return this.padding}set Padding(value){this.padding=value}get PolylinePadding(){return this.polylinePadding}set PolylinePadding(value){this.polylinePadding=value}get RoutingToParentConeAngle(){return this.routingToParentConeAngle}set RoutingToParentConeAngle(value){this.routingToParentConeAngle=value}get SimpleSelfLoopsForParentEdgesThreshold(){return this.simpleSelfLoopsForParentEdgesThreshold}set SimpleSelfLoopsForParentEdgesThreshold(value){this.simpleSelfLoopsForParentEdgesThreshold=value}get IncrementalRoutingThreshold(){return this.incrementalRoutingThreshold}set IncrementalRoutingThreshold(value){this.incrementalRoutingThreshold=value}get RouteMultiEdgesAsBundles(){return this.routeMultiEdgesAsBundles}set RouteMultiEdgesAsBundles(value){this.routeMultiEdgesAsBundles=value}}!function(SnapToGridByY){SnapToGridByY[SnapToGridByY.None=0]="None",SnapToGridByY[SnapToGridByY.Top=1]="Top",SnapToGridByY[SnapToGridByY.Bottom=2]="Bottom"}(SnapToGridByY||(SnapToGridByY={}));class LayoutSettings{constructor(){this.edgeRoutingSettings=new EdgeRoutingSettings,this.minimalWidth=0,this.minimalHeight=0,this.nodeSeparation=10,this.packingAspectRatio=1.5}get MinimalWidth(){return this.minimalWidth}set MinimalWidth(value){this.minimalWidth=Math.max(value,0)}get MinimalHeight(){return this.minimalHeight}set MinimalHeight(value){this.minimalHeight=Math.max(value,0)}get NodeSeparation(){return this.nodeSeparation}set NodeSeparation(value){this.nodeSeparation=value}get PackingAspectRatio(){return this.packingAspectRatio}set PackingAspectRatio(value){this.packingAspectRatio=value}}class SugiyamaLayoutSettings_SugiyamaLayoutSettings extends LayoutSettings{constructor(){super(),this.margins={left:0,top:0,bottom:0,right:0},this.sameRanks=new Array,this.verticalConstraints=new VerticalConstraintsForSugiyama,this.horizontalConstraints=new HorizontalConstraintsForSugiyama,this.NoGainAdjacentSwapStepsBound=5,this.RepetitionCoefficientForOrdering=1,this.AspectRatio=0,this.MaxNumberOfPassesInOrdering=24,this.BrandesThreshold=600,this.LabelCornersPreserveCoefficient=.1,this.MinNodeHeight=9,this.MinNodeWidth=13.5,this.SnapToGridByY=SnapToGridByY.None,this.yLayerSep=30,this.transform=PlaneTransformation.getIdentity(),this.GridSizeByY=0,this.GridSizeByX=0,this.edgeRoutingSettings.EdgeRoutingMode=EdgeRoutingMode.SugiyamaSplines}get LayerSeparation(){return this.yLayerSep}set LayerSeparation(value){this.yLayerSep=Math.max(30,value)}ActualLayerSeparation(layersAreDoubled){return layersAreDoubled?this.LayerSeparation/2:this.LayerSeparation}transformIsRotation(ang){const p=PlaneTransformation.rotation(ang);for(let i=0;i<2;i++)for(let j=0;j<3;j++)if(!closeDistEps(p.elements[i][j],this.transform.elements[i][j]))return!1;return!0}get layerDirection(){return this.transformIsRotation(0)?LayerDirectionEnum.TB:this.transformIsRotation(Math.PI/2)?LayerDirectionEnum.LR:this.transformIsRotation(-Math.PI/2)?LayerDirectionEnum.RL:this.transformIsRotation(Math.PI)?LayerDirectionEnum.BT:LayerDirectionEnum.None}set layerDirection(value){switch(value){case LayerDirectionEnum.TB:break;case LayerDirectionEnum.LR:this.transform=PlaneTransformation.rotation(Math.PI/2);break;case LayerDirectionEnum.RL:this.transform=PlaneTransformation.rotation(-Math.PI/2);break;case LayerDirectionEnum.BT:this.transform=PlaneTransformation.rotation(Math.PI);break;default:throw new Error("unexpected layout direction")}}}class RealNumberSpan{constructor(){this.isEmpty=!0}AddValue(x){this.isEmpty?(this.max=x,this.min=x,this.isEmpty=!1):x<this.min?this.min=x:x>this.max&&(this.max=x)}get length(){return this.max-this.min}static sign(value){return value>GeomConstants.distanceEpsilon?1:value<-GeomConstants.distanceEpsilon?-1:0}}class BasicGraph extends BasicGraphOnEdges{constructor(edges,numberOfVerts){super(),this.SetEdges(edges,numberOfVerts)}}class Database{constructor(n){this.MultipleMiddles=new Set,this.Multiedges=new IntPairMap(n)}*RegularMultiedges(){for(const[k,v]of this.Multiedges.keyValues())k.x!=k.y&&(yield v)}*AllIntEdges(){for(const l of this.Multiedges.values())for(const e of l)yield e}addFeedbackSet(feedbackSet){for(const e of feedbackSet){const ip=new IntPair(e.source,e.target),ipr=new IntPair(e.target,e.source),listToShuffle=this.Multiedges.get(ip.x,ip.y);for(const er of listToShuffle)er.reverse();if(this.Multiedges.has(ipr.x,ipr.y)){const m=this.Multiedges.get(ipr.x,ipr.y);for(const e of listToShuffle)m.push(e)}else this.Multiedges.set(ipr.x,ipr.y,listToShuffle);this.Multiedges.delete(ip.x,ip.y)}}registerOriginalEdgeInMultiedges(edge){let o=this.Multiedges.get(edge.source,edge.target);null==o&&this.Multiedges.set(edge.source,edge.target,o=[]),o.push(edge)}*SkeletonEdges(){for(const[k,v]of this.Multiedges.keyValues())k.x!=k.y&&(yield v[0])}GetMultiedge(source,target){return this.GetMultiedgeI(new IntPair(source,target))}GetMultiedgeI(ip){return this.Multiedges.has(ip.x,ip.y)?this.Multiedges.get(ip.x,ip.y):new Array}}function copyTo(s,t){for(let i=0;i<s.length;i++)t[i]=s[i]}class LayerArrays{constructor(verticesToLayers){this.initialize(verticesToLayers)}initialize(verticesToLayers){this.y=verticesToLayers,this.verticesToX=null,this.layers=null}DropEmptyLayers(){const drop=new Array(this.Layers.length);let dropVal=0;for(let i=0;i<this.Layers.length;i++)drop[i]=dropVal,0==this.Layers[i].length&&dropVal++;if(0==dropVal)return this;const ny=new Array(this.y.length);for(let i=0;i<ny.length;i++)ny[i]=this.y[i]-drop[this.y[i]];const nls=new Array(this.layers.length-dropVal);for(let i=0;i<this.layers.length;i++)this.layers[i].length>0&&(nls[i-drop[i]]=Array.from(this.layers[i]));const la=new LayerArrays(ny);return la.layers=nls,la}updateLayers(ulayers){null==this.layers&&this.InitLayers();for(let i=0;i<this.layers.length;i++)copyTo(ulayers[i],this.layers[i]);this.UpdateXFromLayers()}UpdateXFromLayers(){null==this.layers&&this.InitLayers(),null==this.verticesToX&&(this.verticesToX=new Array(this.y.length));for(const layer of this.layers){let i=0;for(const v of layer)this.verticesToX[v]=i++}}get x(){return null!=this.verticesToX||(this.verticesToX=new Array(this.y.length),this.UpdateXFromLayers()),this.verticesToX}ReversedClone(){const rv=new Array(this.y.length),lastLayer=this.Layers.length-1;for(let i=0;i<this.y.length;i++)rv[i]=lastLayer-this.y[i];return new LayerArrays(rv)}get Layers(){return null!=this.layers||this.InitLayers(),this.layers}set Layers(value){this.layers=value}InitLayers(){let nOfLayers=0;for(const l of this.y)l+1>nOfLayers&&(nOfLayers=l+1);const counts=new Array(nOfLayers).fill(0);for(const l of this.y)counts[l]++;this.layers=new Array(nOfLayers);for(let i=0;i<nOfLayers;i++)this.layers[i]=new Array(counts[i]),counts[i]=0;for(let i=0;i<this.y.length;i++){const l=this.y[i];this.layers[l][counts[l]++]=i}}}class Balancing extends Algorithm{constructor(dag,layering,nodeCount,cancelToken){super(cancelToken),this.jumpers=new Set,this.possibleJumperFeasibleIntervals=new Map,this.nodeCount=nodeCount,this.dag=dag,this.layering=layering,this.Init()}static Balance(dag,layering,nodeCount,cancelObj){new Balancing(dag,layering,nodeCount,cancelObj).run()}run(){for(;this.jumpers.size>0;)this.Jump(this.ChooseJumper())}Init(){this.CalculateLayerCounts(),this.InitJumpers()}Jump(jumper){this.jumpers.delete(jumper);const upLow=this.possibleJumperFeasibleIntervals.get(jumper),ji=this.CalcJumpInfo(upLow.x,upLow.y,jumper);if(null==ji)return;this.layering[jumper]=ji.layerToJumpTo;const jumperCount=this.nodeCount[jumper];this.vertsCounts[ji.jumperLayer]-=jumperCount,this.vertsCounts[ji.layerToJumpTo]+=jumperCount,this.UpdateRegionsForPossibleJumpersAndInsertJumpers(ji.jumperLayer,jumper)}IsJumper(v){return this.possibleJumperFeasibleIntervals.has(v)}UpdateRegionsForPossibleJumpersAndInsertJumpers(jumperLayer,jumper){const neighborPossibleJumpers=new Set;for(const v of this.dag.pred(jumper))this.IsJumper(v)&&(this.CalculateRegionAndInsertJumper(v),neighborPossibleJumpers.add(v));for(const v of this.dag.succ(jumper))this.IsJumper(v)&&(this.CalculateRegionAndInsertJumper(v),neighborPossibleJumpers.add(v));const possibleJumpersToUpdate=new Array;for(const kv of this.possibleJumperFeasibleIntervals)neighborPossibleJumpers.has(kv[0])||kv[1].x>jumperLayer&&kv[1].y<jumperLayer&&possibleJumpersToUpdate.push(kv[0]);for(const v of possibleJumpersToUpdate)this.CalculateRegionAndInsertJumper(v)}InitJumpers(){const deltas=new Array(this.dag.nodeCount).fill(0);for(const ie of this.dag.edges)deltas[ie.source]-=ie.weight,deltas[ie.target]+=ie.weight;this.possibleJumperFeasibleIntervals=new Map;for(let i=0;i<this.dag.nodeCount;i++)0==deltas[i]&&this.CalculateRegionAndInsertJumper(i)}CalculateRegionAndInsertJumper(i){const ip=new IntPair(this.Up(i),this.Down(i));this.possibleJumperFeasibleIntervals.set(i,ip),this.InsertJumper(ip.x,ip.y,i)}InsertJumper(upLayer,lowLayer,jumper){null!=this.CalcJumpInfo(upLayer,lowLayer,jumper)&&this.jumpers.add(jumper)}CalcJumpInfo(upLayer,lowLayer,jumper){const jumperLayer=this.layering[jumper];let layerToJumpTo=-1,min=this.vertsCounts[jumperLayer]-2*this.nodeCount[jumper];for(let i=upLayer-1;i>jumperLayer;i--)this.vertsCounts[i]<min&&(min=this.vertsCounts[i],layerToJumpTo=i);for(let i=jumperLayer-1;i>lowLayer;i--)this.vertsCounts[i]<min&&(min=this.vertsCounts[i],layerToJumpTo=i);if(-1!=layerToJumpTo)return{jumperLayer:jumperLayer,layerToJumpTo:layerToJumpTo}}Up(i){let ret=Number.MAX_SAFE_INTEGER;for(const ie of this.dag.inEdges[i]){const r=this.layering[ie.source]-ie.separation+1;r<ret&&(ret=r)}return ret==Number.MAX_SAFE_INTEGER&&(ret=this.layering[i]+1),ret}Down(i){let ret=Number.NEGATIVE_INFINITY;for(const ie of this.dag.outEdges[i]){const r=this.layering[ie.target]+ie.separation-1;r>ret&&(ret=r)}return ret==Number.NEGATIVE_INFINITY&&(ret=this.layering[i]-1),ret}CalculateLayerCounts(){this.vertsCounts=new Array(Math.max(...this.layering)+1).fill(0);for(const r of this.layering)this.vertsCounts[r]+=this.nodeCount[r]}ChooseJumper(){for(const jumper of this.jumpers)return jumper;throw new Error("there are no jumpers to choose")}}class ProperLayeredGraph{constructor(intGraph){this.Initialize(intGraph)}Initialize(intGraph){this.BaseGraph=intGraph,this.totalNumberOfNodes=intGraph.nodeCount;for(const edge of this.BaseGraph.edges)if(null!=edge.LayerEdges)for(const layerEdge of edge.LayerEdges){const m=Math.max(layerEdge.Source,layerEdge.Target)+1;m>this.totalNumberOfNodes&&(this.totalNumberOfNodes=m)}this.firstVirtualNode=Number.POSITIVE_INFINITY;for(const e of this.BaseGraph.edges)if(null!=e.LayerEdges)for(let i=1;i<e.LayerEdges.length;i++){const le=e.LayerEdges[i];this.firstVirtualNode=Math.min(this.firstVirtualNode,le.Source)}this.firstVirtualNode==Number.POSITIVE_INFINITY&&(this.firstVirtualNode=this.BaseGraph.nodeCount,this.totalNumberOfNodes=this.BaseGraph.nodeCount),this.virtualNodesToInEdges=new Array(this.totalNumberOfNodes-this.firstVirtualNode),this.virtualNodesToOutEdges=new Array(this.totalNumberOfNodes-this.firstVirtualNode);for(const e of this.BaseGraph.edges)if(e.LayerSpan>0)for(const le of e.LayerEdges)le.Target!=e.target&&(this.virtualNodesToInEdges[le.Target-this.firstVirtualNode]=le),le.Source!=e.source&&(this.virtualNodesToOutEdges[le.Source-this.firstVirtualNode]=le)}*edges_(){for(const ie of this.BaseGraph.edges)if(ie.LayerSpan>0)for(const le of ie.LayerEdges)yield le}get Edges(){return this.edges_()}*InEdges(node){if(node<this.BaseGraph.nodeCount)for(const e of this.BaseGraph.inEdges[node])e.source!=e.target&&null!=e.LayerEdges&&(yield ProperLayeredGraph.LastEdge(e));else node>=this.firstVirtualNode&&(yield this.InEdgeOfVirtualNode(node))}static LastEdge(e){return e.LayerEdges[e.LayerEdges.length-1]}InEdgeOfVirtualNode(node){return this.virtualNodesToInEdges[node-this.firstVirtualNode]}*OutEdges(node){if(node<this.BaseGraph.nodeCount)for(const e of this.BaseGraph.outEdges[node])e.source!=e.target&&null!=e.LayerEdges&&(yield ProperLayeredGraph.FirstEdge(e));else node>=this.firstVirtualNode&&(yield this.OutEdgeOfVirtualNode(node))}OutDegreeIsMoreThanOne(node){return node<this.BaseGraph.nodeCount&&this.BaseGraph.outEdges[node].length>1}InDegreeIsMoreThanOne(node){return node<this.BaseGraph.nodeCount&&this.BaseGraph.inEdges[node].length>1}OutEdgeOfVirtualNode(node){return this.virtualNodesToOutEdges[node-this.firstVirtualNode]}static FirstEdge(e){return e.LayerEdges[0]}InEdgesCount(node){return this.RealInEdgesCount(node)}RealInEdgesCount(node){return node<this.BaseGraph.nodeCount?this.BaseGraph.inEdges[node].filter((e=>null!=e.LayerEdges)).length:1}OutEdgesCount(node){return this.RealOutEdgesCount(node)}RealOutEdgesCount(node){return node<this.BaseGraph.nodeCount?this.BaseGraph.outEdges[node].filter((l=>null!=l.LayerEdges)).length:1}get NodeCount(){return this.totalNumberOfNodes}IsRealNode(node){return node<this.BaseGraph.nodeCount}IsVirtualNode(node){return!this.IsRealNode(node)}ReversedClone(){const reversedEdges=this.CreateReversedEdges();return new ProperLayeredGraph(new BasicGraph(reversedEdges,this.BaseGraph.nodeCount))}CreateReversedEdges(){const ret=new Array;for(const e of this.BaseGraph.edges)e.isSelfEdge()||ret.push(e.reversedClone());return ret}*Succ(node){for(const le of this.OutEdges(node))yield le.Target}*Pred(node){for(const le of this.InEdges(node))yield le.Source}}!function(ReadonlyContainer){ReadonlyContainer.has=Symbol.for("@esfx/collection-core!ReadonlyCollection.has"),ReadonlyContainer.name="ReadonlyContainer",ReadonlyContainer.hasInstance=function hasInstance(value){return("object"==typeof value&&null!==value||"function"==typeof value)&&ReadonlyContainer.has in value}}(ReadonlyContainer||(ReadonlyContainer={})),function(Container){Container.has=ReadonlyContainer.has,Container.add=Symbol.for("@esfx/collection-core!Collection.add"),Container.delete=Symbol.for("@esfx/collection-core!Collection.delete"),Container.name="Container",Container.hasInstance=function hasInstance(value){return ReadonlyContainer.hasInstance(value)&&Container.add in value&&Container.delete in value}}(Container||(Container={})),function(ReadonlyCollection){ReadonlyCollection.has=ReadonlyContainer.has,ReadonlyCollection.size=Symbol.for("@esfx/collection-core!ReadonlyCollection.size"),ReadonlyCollection.name="ReadonlyCollection",ReadonlyCollection.hasInstance=function hasInstance(value){return ReadonlyContainer.hasInstance(value)&&("object"==typeof value&&null!==value||"function"==typeof value)&&Symbol.iterator in value&&ReadonlyCollection.size in value}}(ReadonlyCollection||(ReadonlyCollection={})),function(Collection){Collection.size=ReadonlyCollection.size,Collection.has=ReadonlyCollection.has,Collection.add=Container.add,Collection.delete=Container.delete,Collection.clear=Symbol.for("@esfx/collection-core!Collection.clear"),Collection.name="Collection",Collection.hasInstance=function hasInstance(value){return ReadonlyCollection.hasInstance(value)&&Container.hasInstance(value)&&Collection.clear in value}}(Collection||(Collection={})),function(ReadonlyIndexedCollection){ReadonlyIndexedCollection.size=ReadonlyCollection.size,ReadonlyIndexedCollection.has=ReadonlyCollection.has,ReadonlyIndexedCollection.indexOf=Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.indexOf"),ReadonlyIndexedCollection.getAt=Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.getAt"),ReadonlyIndexedCollection.name="ReadonlyIndexedCollection",ReadonlyIndexedCollection.hasInstance=function hasInstance(value){return ReadonlyCollection.hasInstance(value)&&ReadonlyIndexedCollection.indexOf in value&&ReadonlyIndexedCollection.getAt in value}}(ReadonlyIndexedCollection||(ReadonlyIndexedCollection={})),function(FixedSizeIndexedCollection){FixedSizeIndexedCollection.size=ReadonlyCollection.size,FixedSizeIndexedCollection.has=ReadonlyCollection.has,FixedSizeIndexedCollection.indexOf=ReadonlyIndexedCollection.indexOf,FixedSizeIndexedCollection.getAt=ReadonlyIndexedCollection.getAt,FixedSizeIndexedCollection.setAt=Symbol.for("@esfx/collection-core!FixedSizeIndexedCollection.setAt"),FixedSizeIndexedCollection.name="FixedSizeIndexedCollection",FixedSizeIndexedCollection.hasInstance=function hasInstance(value){return ReadonlyIndexedCollection.hasInstance(value)&&FixedSizeIndexedCollection.setAt in value}}(FixedSizeIndexedCollection||(FixedSizeIndexedCollection={})),function(IndexedCollection){IndexedCollection.size=ReadonlyCollection.size,IndexedCollection.has=ReadonlyCollection.has,IndexedCollection.indexOf=ReadonlyIndexedCollection.indexOf,IndexedCollection.getAt=ReadonlyIndexedCollection.getAt,IndexedCollection.setAt=FixedSizeIndexedCollection.setAt,IndexedCollection.add=Collection.add,IndexedCollection.delete=Collection.delete,IndexedCollection.clear=Collection.clear,IndexedCollection.insertAt=Symbol.for("@esfx/collection-core!IndexedCollection.insertAt"),IndexedCollection.removeAt=Symbol.for("@esfx/collection-core!IndexedCollection.removeAt"),IndexedCollection.name="IndexedCollection",IndexedCollection.hasInstance=function hasInstance(value){return FixedSizeIndexedCollection.hasInstance(value)&&IndexedCollection.insertAt in value&&IndexedCollection.removeAt in value}}(IndexedCollection||(IndexedCollection={})),function(ReadonlyKeyedContainer){ReadonlyKeyedContainer.has=Symbol.for("@esfx/collection-core!ReadonlyKeyedContainer.has"),ReadonlyKeyedContainer.get=Symbol.for("@esfx/collection-core!ReadonlyKeyedContainer.get"),ReadonlyKeyedContainer.name="ReadonlyKeyedContainer",ReadonlyKeyedContainer.hasInstance=function hasInstance(value){return("object"==typeof value&&null!==value||"function"==typeof value)&&ReadonlyKeyedContainer.has in value&&ReadonlyKeyedContainer.get in value}}(ReadonlyKeyedContainer||(ReadonlyKeyedContainer={})),function(KeyedContainer){KeyedContainer.has=ReadonlyKeyedContainer.has,KeyedContainer.get=ReadonlyKeyedContainer.get,KeyedContainer.set=Symbol.for("@esfx/collection-core!KeyedCollection.set"),KeyedContainer.delete=Symbol.for("@esfx/collection-core!KeyedCollection.delete"),KeyedContainer.name="KeyedContainer",KeyedContainer.hasInstance=function hasInstance(value){return ReadonlyKeyedContainer.hasInstance(value)&&KeyedContainer.set in value&&KeyedContainer.delete in value}}(KeyedContainer||(KeyedContainer={})),function(ReadonlyKeyedCollection){ReadonlyKeyedCollection.has=ReadonlyKeyedContainer.has,ReadonlyKeyedCollection.get=ReadonlyKeyedContainer.get,ReadonlyKeyedCollection.size=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.size"),ReadonlyKeyedCollection.keys=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.keys"),ReadonlyKeyedCollection.values=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.values"),ReadonlyKeyedCollection.name="ReadonlyKeyedCollection",ReadonlyKeyedCollection.hasInstance=function hasInstance(value){return("object"==typeof value&&null!==value||"function"==typeof value)&&Symbol.iterator in value&&ReadonlyKeyedContainer.hasInstance(value)&&ReadonlyKeyedCollection.size in value&&ReadonlyKeyedCollection.keys in value&&ReadonlyKeyedCollection.values in value}}(ReadonlyKeyedCollection||(ReadonlyKeyedCollection={})),function(KeyedCollection){KeyedCollection.size=ReadonlyKeyedCollection.size,KeyedCollection.has=ReadonlyKeyedCollection.has,KeyedCollection.get=ReadonlyKeyedCollection.get,KeyedCollection.keys=ReadonlyKeyedCollection.keys,KeyedCollection.values=ReadonlyKeyedCollection.values,KeyedCollection.set=KeyedContainer.set,KeyedCollection.delete=KeyedContainer.delete,KeyedCollection.clear=Symbol.for("@esfx/collection-core!KeyedCollection.clear"),KeyedCollection.name="KeyedCollection",KeyedCollection.hasInstance=function hasInstance(value){return ReadonlyKeyedCollection.hasInstance(value)&&KeyedContainer.hasInstance(value)&&KeyedCollection.clear in value}}(KeyedCollection||(KeyedCollection={})),function(ReadonlyKeyedMultiCollection){ReadonlyKeyedMultiCollection.size=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.size"),ReadonlyKeyedMultiCollection.has=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.has"),ReadonlyKeyedMultiCollection.hasValue=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.hasValue"),ReadonlyKeyedMultiCollection.get=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.get"),ReadonlyKeyedMultiCollection.keys=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.keys"),ReadonlyKeyedMultiCollection.values=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.values"),ReadonlyKeyedMultiCollection.name="ReadonlyKeyedMultiCollection",ReadonlyKeyedMultiCollection.hasInstance=function hasInstance(value){return("object"==typeof value&&null!==value||"function"==typeof value)&&Symbol.iterator in value&&ReadonlyKeyedMultiCollection.size in value&&ReadonlyKeyedMultiCollection.has in value&&ReadonlyKeyedMultiCollection.hasValue in value&&ReadonlyKeyedMultiCollection.get in value&&ReadonlyKeyedMultiCollection.keys in value&&ReadonlyKeyedMultiCollection.values in value}}(ReadonlyKeyedMultiCollection||(ReadonlyKeyedMultiCollection={})),function(KeyedMultiCollection){KeyedMultiCollection.size=ReadonlyKeyedMultiCollection.size,KeyedMultiCollection.has=ReadonlyKeyedMultiCollection.has,KeyedMultiCollection.hasValue=ReadonlyKeyedMultiCollection.hasValue,KeyedMultiCollection.get=ReadonlyKeyedMultiCollection.get,KeyedMultiCollection.keys=ReadonlyKeyedMultiCollection.keys,KeyedMultiCollection.values=ReadonlyKeyedMultiCollection.values,KeyedMultiCollection.add=Symbol.for("@esfx/collection-core!KeyedMultiCollection.add"),KeyedMultiCollection.delete=Symbol.for("@esfx/collection-core!KeyedMultiCollection.delete"),KeyedMultiCollection.deleteValue=Symbol.for("@esfx/collection-core!KeyedMultiCollection.deleteValue"),KeyedMultiCollection.clear=Symbol.for("@esfx/collection-core!KeyedMultiCollection.clear"),KeyedMultiCollection.name="KeyedMultiCollection",KeyedMultiCollection.hasInstance=function hasInstance(value){return ReadonlyKeyedMultiCollection.hasInstance(value)&&KeyedMultiCollection.add in value&&KeyedMultiCollection.delete in value&&KeyedMultiCollection.deleteValue in value&&KeyedMultiCollection.clear in value}}(KeyedMultiCollection||(KeyedMultiCollection={}));function xxh32(buffer,input_ptr,inputLength,seed){if(input_ptr%4)throw new TypeError("Pointer not aligned");const buffer_u32=new Uint32Array(buffer);let acc,end,limit,v1,v2,v3,v4;if(end=input_ptr+inputLength,input_ptr>>=2,inputLength>=16){limit=end-16>>2,v1=2246822519+(seed+2654435761|0)|0,v2=seed+2246822519|0,v3=seed+0|0,v4=seed+2654435761|0;do{v1=v1+2246822519*buffer_u32[input_ptr++]|0,v1=2654435761*(v1<<13|v1>>>19)|0,v2=v2+2246822519*buffer_u32[input_ptr++]|0,v2=2654435761*(v2<<13|v2>>>19)|0,v3=v3+2246822519*buffer_u32[input_ptr++]|0,v3=2654435761*(v3<<13|v3>>>19)|0,v4=v4+2246822519*buffer_u32[input_ptr++]|0,v4=2654435761*(v4<<13|v4>>>19)|0}while(input_ptr<=limit);acc=(v1<<1|v1>>>31)+(v2<<7|v2>>>25)|v3<<12|v3>>>20|v4<<18|v4>>>14}else acc=seed+374761393|0;for(acc=acc+inputLength|0,limit=end-4>>2;input_ptr<=limit;)acc=acc+3266489917*buffer_u32[input_ptr++]|0,acc=668265263*(acc<<17|acc>>>15)|0;if((input_ptr<<=2)<end){const buffer_u8=new Uint8Array(buffer_u32.buffer);do{acc=acc+374761393*buffer_u8[input_ptr++]|0,acc=2654435761*(acc<<11|acc>>>21)|0}while(input_ptr<end)}return acc=2246822519*(acc^acc>>>15)|0,acc=3266489917*(acc^acc>>>13)|0,acc^=acc>>>16,acc>>>0}const hasWebAssembly="undefined"!=typeof WebAssembly&&"function"==typeof WebAssembly.Module&&"function"==typeof WebAssembly.Instance,buffer=new Uint8Array([0,97,115,109,1,0,0,0,1,8,1,96,3,127,127,126,1,126,3,2,1,0,5,3,1,0,1,7,15,2,3,109,101,109,2,0,5,120,120,104,54,52,0,0,10,130,6,1,255,5,2,3,126,1,127,32,0,32,1,106,33,6,32,1,65,32,79,4,126,32,6,65,32,107,33,6,32,2,66,214,235,130,238,234,253,137,245,224,0,124,33,3,32,2,66,177,169,172,193,173,184,212,166,61,125,33,4,32,2,66,249,234,208,208,231,201,161,228,225,0,124,33,5,3,64,32,3,32,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,3,32,4,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,4,32,2,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,2,32,5,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,5,32,6,32,0,65,8,106,34,0,79,13,0,11,32,2,66,12,137,32,5,66,18,137,124,32,4,66,7,137,124,32,3,66,1,137,124,32,3,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,4,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,2,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,5,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,5,32,2,66,197,207,217,178,241,229,186,234,39,124,11,32,1,173,124,33,2,32,0,32,1,65,31,113,106,33,1,3,64,32,1,32,0,65,8,106,79,4,64,32,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,32,2,133,66,27,137,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,33,2,32,0,65,8,106,33,0,12,1,11,11,32,0,65,4,106,32,1,77,4,64,32,2,32,0,53,2,0,66,135,149,175,175,152,182,222,155,158,127,126,133,66,23,137,66,207,214,211,190,210,199,171,217,66,126,66,249,243,221,241,153,246,153,171,22,124,33,2,32,0,65,4,106,33,0,11,3,64,32,0,32,1,73,4,64,32,2,32,0,49,0,0,66,197,207,217,178,241,229,186,234,39,126,133,66,11,137,66,135,149,175,175,152,182,222,155,158,127,126,33,2,32,0,65,1,106,33,0,12,1,11,11,32,2,32,2,66,33,136,133,66,207,214,211,190,210,199,171,217,66,126,34,2,66,29,136,32,2,133,66,249,243,221,241,153,246,153,171,22,126,34,2,66,32,136,32,2,133,11]);var xxhash64_generated=hasWebAssembly?new WebAssembly.Instance(new WebAssembly.Module(buffer)).exports:void 0,mem=null==xxhash64_generated?void 0:xxhash64_generated.mem,xxh64=null==xxhash64_generated?void 0:xxhash64_generated.xxh64;const hasTextEncoder="function"==typeof TextEncoder;let utf8EncodeIntoCore=(source,buffer)=>(utf8EncodeIntoCore=function createUtf8EncodeInto(){function getUtf8EncodeIntoUsingTextEncoder(){const encoder=new TextEncoder;function utf8EncodeInto(source,buffer){const{written:written=0}=encoder.encodeInto(source,buffer);return written}return utf8EncodeInto}function getUtf8EncodeIntoFallback(){function utf8EncodeInto(source,buffer){const length=source.length;let written=0;for(let i=0;i<length;i++){let ch=source.charCodeAt(i);if(55296&ch&&!(4294910976&ch)&&i<length-1){const ch2=source.charCodeAt(i+1);56320==(64512&ch2)&&(ch=((1023&ch)<<10)+(1023&ch2)+65536,i++)}if(4294967168&ch)if(4294965248&ch)if(268431360&ch){if(4292870144&ch)throw new RangeError("Unsupported charCode.");buffer[written++]=ch>>18|240,buffer[written++]=ch>>12&63|128,buffer[written++]=ch>>6&63|128,buffer[written++]=63&ch|128}else buffer[written++]=ch>>12|224,buffer[written++]=ch>>6&63|128,buffer[written++]=63&ch|128;else buffer[written++]=ch>>6|192,buffer[written++]=63&ch|128;else buffer[written++]=ch}return written}return utf8EncodeInto}return hasTextEncoder?getUtf8EncodeIntoUsingTextEncoder():getUtf8EncodeIntoFallback()}())(source,buffer);const utf8EncodeInto=(source,buffer)=>utf8EncodeIntoCore(source,buffer);const hasNativeBigInt="function"==typeof BigInt&&"bigint"==typeof BigInt(0),hasBigUint64Array="function"==typeof BigUint64Array,hasXXHash64="object"==typeof mem&&"function"==typeof xxh64,converterBuffer=new ArrayBuffer(8),converterFloat64Array=new Float64Array(converterBuffer),converterUint32Array=new Uint32Array(converterBuffer);let createHashString=()=>(createHashString=function createCreateHashString(){function createCreateSeededHashStringUsingXXHash64(){const converterBigUint64Array=new BigUint64Array(converterUint32Array.buffer);let memory=new Uint8Array(mem.buffer);function ensureCapacity(size){mem.buffer.byteLength<size&&(mem.grow(Math.ceil((size-mem.buffer.byteLength)/65536)),memory=new Uint8Array(mem.buffer))}function convertBigUint64Hash(h){converterBigUint64Array[0]=h;const a=converterUint32Array[0];return(a<<7|a>>>25)^converterUint32Array[1]}function getRandomBigUint64Seed(){return converterUint32Array[0]=getRandomUint32Seed(),converterUint32Array[1]=getRandomUint32Seed(),converterBigUint64Array[0]}function hashStringSeeded(x,seed){ensureCapacity(3*x.length);const written=utf8EncodeInto(x,memory);return convertBigUint64Hash(xxh64(0,written,seed))}function createSeededHashString(){const seed=getRandomBigUint64Seed();function hashString(x){return hashStringSeeded(x,seed)}return hashString}return createSeededHashString}function createCreateSeededHashStringUsingXXHash32(){let memory=new Uint8Array(65536);function ensureCapacity(size){memory.byteLength<size&&(memory=new Uint8Array(size+(65536-size%65536)))}function hashStringSeeded(x,seed){ensureCapacity(3*x.length);const written=utf8EncodeInto(x,memory);return xxh32(memory.buffer,0,written,seed)|0}function createSeededHashString(){const seed=getRandomUint32Seed();function hashString(x){return hashStringSeeded(x,seed)}return hashString}return createSeededHashString}return hasNativeBigInt&&hasBigUint64Array&&hasXXHash64?createCreateSeededHashStringUsingXXHash64():createCreateSeededHashStringUsingXXHash32()}())(),hashNumberCore=x=>(hashNumberCore=function createHashNumber(){function hashFloat64(x){converterFloat64Array[0]=x;const a=converterUint32Array[0];return(a<<7|a>>>25)^converterUint32Array[1]}function hashNumber(x){return(x|0)===x?0|x:hashFloat64(x)}return hashNumber}())(x),hashBigIntCore=x=>(hashBigIntCore=function createHashBigInt(){function createHashBigIntUsingBigUint64Array(){const converterBigUint64Array=new BigUint64Array(converterBuffer),ZERO=BigInt(0),ONE=BigInt(1),TWO=BigInt(2),MAX_I32=BigInt(2)**BigInt(31)-BigInt(1),MIN_I32=~MAX_I32,SIZE_U64=BigInt(64);function hashBigInt(x){if(x===ZERO)return 0;if(x>=MIN_I32&&x<=MAX_I32)return Number(x);x=x<ZERO?~x*TWO+ONE:x*TWO;let hash=0;for(;x;)converterBigUint64Array[0]=x,hash=(hash<<7|hash>>>25)^converterUint32Array[0],hash=(hash<<7|hash>>>25)^converterUint32Array[1],x>>=SIZE_U64;return 0|hash}return hashBigInt}function createHashBigIntUsingNumberConstructor(){const ZERO=BigInt(0),ONE=BigInt(1),TWO=BigInt(2),MAX_I32=BigInt(2)**BigInt(31)-BigInt(1),MIN_I32=~MAX_I32,SIZE_U32=BigInt(32),U32_MASK=BigInt("0xFFFFFFFF");function hashBigInt(x){if(x===ZERO)return 0;if(x>=MIN_I32&&x<=MAX_I32)return Number(x);x=x<ZERO?~x*TWO+ONE:x*TWO;let hash=0;for(;x!==ZERO;)hash=(hash<<7|hash>>>25)^Number(x&U32_MASK),x>>=SIZE_U32,hash=(hash<<7|hash>>>25)^Number(x&U32_MASK),x>>=SIZE_U32;return 0|hash}return hashBigInt}function createHashBigIntUsingToString(){const hashBigIntString=createHashString();function hashBigInt(x){return hashBigIntString(x.toString())}return hashBigInt}return hasNativeBigInt&&hasBigUint64Array?createHashBigIntUsingBigUint64Array():hasNativeBigInt?createHashBigIntUsingNumberConstructor():createHashBigIntUsingToString()}())(x),hashStringCore=x=>(hashStringCore=createHashString())(x),hashSymbolCore=x=>(hashSymbolCore=function createHashSymbol(){const getDescription="description"in Symbol.prototype?symbol=>symbol.description:symbol=>{const s=symbol.toString();return s.length>=8&&"Symbol("===s.slice(0,7)&&")"===s.slice(-1)?s.slice(7,-1):s},builtinSymbolHasher=createHashString();let builtinSymbolHashes,builtinSymbols;try{(new WeakMap).set(Symbol.iterator,null),builtinSymbolHashes=new WeakMap,builtinSymbols=new WeakMap}catch(_a){builtinSymbolHashes=new Map,builtinSymbols=new Map}for(const key of Object.getOwnPropertyNames(Symbol))if("string"==typeof key){const value=Symbol[key];"symbol"==typeof value&&builtinSymbols.set(value,`Symbol.${key}`)}const registeredSymbolHasher=createHashString();let registeredSymbolHashes;try{(new WeakMap).set(Symbol.for("@esfx/equatable!~globalSymbolTest"),null),registeredSymbolHashes=new WeakMap}catch(_b){registeredSymbolHashes=new Map}const localSymbolHasher=createHashString();let localSymbolHashes,localSymbolCounter=1;try{(new WeakMap).set(Symbol(),null),localSymbolHashes=new WeakMap}catch(_c){localSymbolHashes=new Map}function hashGlobalSymbol(symbol,key){let hash=registeredSymbolHashes.get(symbol);return void 0===hash&&(hash=registeredSymbolHasher(key),registeredSymbolHashes.set(symbol,hash)),hash}function hashBuiltinSymbol(symbol,key){let hash=builtinSymbolHashes.get(symbol);return void 0===hash&&(hash=builtinSymbolHasher(key),builtinSymbolHashes.set(symbol,hash)),hash}function hashLocalSymbol(symbol){let hash=localSymbolHashes.get(symbol);return void 0===hash&&(hash=localSymbolHasher(`${localSymbolCounter++}#${getDescription(symbol)}`),localSymbolHashes.set(symbol,hash)),hash}function hashSymbol(x){const builtinKey=builtinSymbols.get(x);if(void 0!==builtinKey)return hashBuiltinSymbol(x,builtinKey);const globalKey=Symbol.keyFor(x);return void 0!==globalKey?hashGlobalSymbol(x,globalKey):hashLocalSymbol(x)}return hashSymbol}())(x),hashObjectCore=x=>(hashObjectCore=function createHashObject(){const objectHashes=new WeakMap,objectSeed=getRandomUint32Seed();let objectCounter=1;function hashUint32(key){return key=~key+(key<<15),key^=key>>12,key+=key<<2,key^=key>>4,key*=2057,(key^=key>>16)>>>0}function hashObject(x){let hash=objectHashes.get(x);return void 0===hash&&(hash=hashUint32(objectCounter++^objectSeed)^objectSeed,objectHashes.set(x,hash)),hash}return hashObject}())(x);const hashNumber=x=>hashNumberCore(x),hashBigInt=x=>hashBigIntCore(x),hashString=x=>hashStringCore(x),hashSymbol=x=>hashSymbolCore(x),hashObject=x=>hashObjectCore(x);function getRandomUint32Seed(){return Math.floor(4294967295*Math.random())>>>0}const root="object"==typeof globalThis?globalThis:"object"==typeof __webpack_require__.g?__webpack_require__.g:"object"==typeof self?self:void 0,kHashUnknown=Symbol.for("@esfx/equatable!~hashUnknown");let hashUnknownCore;function hashUnknown(x){return hashUnknownCore(x)}var Equatable,Comparable,StructuralEquatable,StructuralComparable,Equaler;root&&"function"==typeof root[kHashUnknown]?hashUnknownCore=root[kHashUnknown]:(hashUnknownCore=function hashUnknown(x){switch(typeof x){case"boolean":return x?1:0;case"number":return hashNumber(x);case"bigint":return hashBigInt(x);case"string":return hashString(x);case"symbol":return hashSymbol(x);case"function":return hashObject(x);case"object":return null===x?0:hashObject(x);case"undefined":return 0;default:throw new TypeError("Unsupported type: "+typeof x)}},Object.defineProperty(root,kHashUnknown,{value:hashUnknownCore})),function(Equatable){function hasInstance(value){let obj;return!(null==value)&&Equatable.equals in(obj=Object(value))&&Equatable.hash in obj}Equatable.equals=Symbol.for("@esfx/equatable:Equatable.equals"),Equatable.hash=Symbol.for("@esfx/equatable:Equatable.hash"),Equatable.name="Equatable",Equatable.hasInstance=hasInstance,Object.defineProperty(Equatable,Symbol.hasInstance,{configurable:!0,writable:!0,value:hasInstance})}(Equatable||(Equatable={})),function(Comparable){function hasInstance(value){return!(null==value)&&Comparable.compareTo in Object(value)}Comparable.compareTo=Symbol.for("@esfx/equatable:Comparable.compareTo"),Comparable.name="Comparable",Comparable.hasInstance=hasInstance,Object.defineProperty(Comparable,Symbol.hasInstance,{configurable:!0,writable:!0,value:hasInstance})}(Comparable||(Comparable={})),function(StructuralEquatable){function hasInstance(value){let obj;return!(null==value)&&StructuralEquatable.structuralEquals in(obj=Object(value))&&StructuralEquatable.structuralHash in obj}StructuralEquatable.structuralEquals=Symbol.for("@esfx/equatable:StructualEquatable.structuralEquals"),StructuralEquatable.structuralHash=Symbol.for("@esfx/equatable:StructuralEquatable.structuralHash"),StructuralEquatable.name="StructuralEquatable",StructuralEquatable.hasInstance=hasInstance,Object.defineProperty(StructuralEquatable,Symbol.hasInstance,{configurable:!0,writable:!0,value:hasInstance})}(StructuralEquatable||(StructuralEquatable={})),function(StructuralComparable){function hasInstance(value){return!(null==value)&&StructuralComparable.structuralCompareTo in Object(value)}StructuralComparable.structuralCompareTo=Symbol.for("@esfx/equatable:StructuralComparable.structuralCompareTo"),StructuralComparable.name="StructuralComparable",StructuralComparable.hasInstance=hasInstance,Object.defineProperty(StructuralComparable,Symbol.hasInstance,{configurable:!0,writable:!0,value:hasInstance})}(StructuralComparable||(StructuralComparable={})),function(Equaler){const equalerPrototype=Object.defineProperty({},Symbol.toStringTag,{configurable:!0,value:"Equaler"});function create(equalityComparison,hashGenerator=Equaler.defaultEqualer.hash){return Object.setPrototypeOf({equals:equalityComparison,hash:hashGenerator},equalerPrototype)}function combineHashes(x,y,rotate=7){if("number"!=typeof x)throw new TypeError("Integer expected: x");if("number"!=typeof y)throw new TypeError("Integer expected: y");if("number"!=typeof rotate)throw new TypeError("Integer expected: rotate");if(isNaN(x)||!isFinite(x))throw new RangeError("Argument must be a finite number value: x");if(isNaN(y)||!isFinite(y))throw new RangeError("Argument must be a finite number value: y");if(isNaN(rotate)||!isFinite(rotate))throw new RangeError("Argument must be a finite number value: rotate");for(;rotate<0;)rotate+=32;for(;rotate>=32;)rotate-=32;return(x<<rotate|x>>>32-rotate)^y}function hasInstance(value){return"object"==typeof value&&null!==value&&"function"==typeof value.equals&&"function"==typeof value.hash}Equaler.defaultEqualer=create(((x,y)=>Equatable.hasInstance(x)?x[Equatable.equals](y):Equatable.hasInstance(y)?y[Equatable.equals](x):Object.is(x,y)),(x=>Equatable.hasInstance(x)?x[Equatable.hash]():function rawHash(value){return hashUnknown(value)}(x))),Equaler.structuralEqualer=create(((x,y)=>StructuralEquatable.hasInstance(x)?x[StructuralEquatable.structuralEquals](y,Equaler.structuralEqualer):StructuralEquatable.hasInstance(y)?y[StructuralEquatable.structuralEquals](x,Equaler.structuralEqualer):Equaler.defaultEqualer.equals(x,y)),(x=>StructuralEquatable.hasInstance(x)?x[StructuralEquatable.structuralHash](Equaler.structuralEqualer):Equaler.defaultEqualer.hash(x))),Equaler.tupleEqualer=create(((x,y)=>{if(null!=x&&!Array.isArray(x)||null!=y&&!Array.isArray(y))throw new TypeError("Array expected");if(x===y)return!0;if(!x||!y||x.length!==y.length)return!1;for(let i=0;i<x.length;i++)if(!Equaler.defaultEqualer.equals(x[i],y[i]))return!1;return!0}),(x=>{if(null==x)return 0;if(!Array.isArray(x))throw new TypeError("Array expected");let hc=0;for(const item of x)hc=combineHashes(hc,Equaler.defaultEqualer.hash(item));return hc})),Equaler.tupleStructuralEqualer=create(((x,y)=>{if(null!=x&&!Array.isArray(x)||null!=y&&!Array.isArray(y))throw new TypeError("Array expected");if(x===y)return!0;if(!x||!y||x.length!==y.length)return!1;for(let i=0;i<x.length;i++)if(!Equaler.structuralEqualer.equals(x[i],y[i]))return!1;return!0}),(x=>{if(null==x)return 0;if(!Array.isArray(x))throw new TypeError("Array expected");let hc=0;for(const item of x)hc=combineHashes(hc,Equaler.structuralEqualer.hash(item));return hc})),Equaler.create=create,Equaler.combineHashes=combineHashes,Equaler.hasInstance=hasInstance,Object.defineProperty(Equaler,Symbol.hasInstance,{configurable:!0,writable:!0,value:hasInstance})}(Equaler||(Equaler={}));var Comparer;Equaler.defaultEqualer,Equaler.structuralEqualer,Equaler.tupleEqualer,Equaler.tupleEqualer,Equaler.combineHashes;!function(Comparer){const comparerProtototype=Object.defineProperty({},Symbol.toStringTag,{configurable:!0,value:"Comparer"});function create(comparison){return Object.setPrototypeOf({compare:comparison},comparerProtototype)}function hasInstance(value){return"object"==typeof value&&null!==value&&"function"==typeof value.compare}Comparer.defaultComparer=create(((x,y)=>Comparable.hasInstance(x)?x[Comparable.compareTo](y):Comparable.hasInstance(y)?-y[Comparable.compareTo](x):x<y?-1:x>y?1:0)),Comparer.structuralComparer=create(((x,y)=>StructuralComparable.hasInstance(x)?x[StructuralComparable.structuralCompareTo](y,Comparer.structuralComparer):StructuralComparable.hasInstance(y)?-y[StructuralComparable.structuralCompareTo](x,Comparer.structuralComparer):Comparer.defaultComparer.compare(x,y))),Comparer.tupleComparer=create(((x,y)=>{if(null!=x&&!Array.isArray(x)||null!=y&&!Array.isArray(y))throw new TypeError("Array expected");let r;if(r=Comparer.defaultComparer.compare(x.length,y.length))return r;for(let i=0;i<x.length;i++)if(r=Comparer.defaultComparer.compare(x[i],y[i]))return r;return 0})),Comparer.tupleStructuralComparer=create(((x,y)=>{if(null!=x&&!Array.isArray(x)||null!=y&&!Array.isArray(y))throw new TypeError("Array expected");let r;if(r=Comparer.defaultComparer.compare(x.length,y.length))return r;for(let i=0;i<x.length;i++)if(r=Comparer.structuralComparer.compare(x[i],y[i]))return r;return 0})),Comparer.create=create,Comparer.hasInstance=hasInstance,Object.defineProperty(Comparer,Symbol.hasInstance,{configurable:!0,writable:!0,value:hasInstance})}(Comparer||(Comparer={}));var _a;Comparer.defaultComparer,Comparer.structuralComparer,Comparer.tupleComparer,Comparer.tupleStructuralComparer;const internal_binarysearch_1=(exports=(module={exports:{}}).exports,Object.defineProperty(exports,"__esModule",{value:!0}),exports.binarySearch=function binarySearch(array,key,comparer){if(0===array.length)return-1;let low=0,high=array.length-1;for(;low<=high;){const middle=low+(high-low>>1),midKey=array[middle];switch(Math.sign(comparer.compare(midKey,key))){case-1:low=middle+1;break;case 0:return middle;case 1:high=middle-1}}return~low},module.exports);var exports,module;class SortedMap{constructor(...args){let iterable,comparer;if(this._keys=[],this._values=[],args.length>0){const arg0=args[0];void 0===arg0||null!=arg0&&Symbol.iterator in Object(arg0)?(iterable=arg0,args.length>1&&(comparer=args[1])):comparer=arg0}if(null!=comparer||(comparer=Comparer.defaultComparer),this._comparer="function"==typeof comparer?Comparer.create(comparer):comparer,iterable)for(const[key,value]of iterable)this.set(key,value)}get comparer(){return this._comparer}get size(){return this._keys.length}has(key){return(0,internal_binarysearch_1.binarySearch)(this._keys,key,this._comparer)>=0}get(key){const index=(0,internal_binarysearch_1.binarySearch)(this._keys,key,this._comparer);return index>=0?this._values[index]:void 0}set(key,value){const index=(0,internal_binarysearch_1.binarySearch)(this._keys,key,this._comparer);return index>=0?this._values[index]=value:(this._keys.splice(~index,0,key),this._values.splice(~index,0,value)),this}delete(key){const index=(0,internal_binarysearch_1.binarySearch)(this._keys,key,this._comparer);return index>=0&&(this._keys.splice(index,1),this._values.splice(index,1),!0)}clear(){this._keys.length=0,this._values.length=0}keys(){return this._keys.values()}values(){return this._values.values()}*entries(){for(let i=0;i<this._keys.length;i++)yield[this._keys[i],this._values[i]]}[Symbol.iterator](){return this.entries()}forEach(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");for(const[key,value]of this)callback.call(thisArg,value,key,this)}get[KeyedCollection.size](){return this.size}[KeyedCollection.has](key){return this.has(key)}[KeyedCollection.get](key){return this.get(key)}[KeyedCollection.set](key,value){this.set(key,value)}[KeyedCollection.delete](key){return this.delete(key)}[KeyedCollection.clear](){this.clear()}[KeyedCollection.keys](){return this.keys()}[KeyedCollection.values](){return this.values()}}_a=SortedMap,Object.defineProperty(_a.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"SortedMap"});class LayerInserter{constructor(layeredGraph,la,database,intGraphP){this.la=la,this.database=database,this.layeredGraph=layeredGraph,this.intGraph=intGraphP}static InsertLayers(layeredGraph,la,db,intGraphP){const li=new LayerInserter(layeredGraph,la,db,intGraphP);return li.InsertLayers(),{layeredGraph:li.nLayeredGraph,la:li.Nla.DropEmptyLayers()}}get NLayering(){return this.Nla.y}InsertLayers(){this.EditOldLayering(),this.CreateFullLayeredGraph(),this.InitNewLayering(),this.MapVirtualNodesToEdges(),this.FillUnsortedNewOddLayers(),this.WidenOriginalLayers(),this.SortNewOddLayers()}EditOldLayering(){let curVNode=this.intGraph.nodeCount;for(const list of this.database.RegularMultiedges()){let span=0;const e=list[0];if(span=2*e.LayerSpan,span>0){for(const le of e.LayerEdges)le.Target!=e.target&&(curVNode++,this.UpdateOldLayer(curVNode++,le.Target));curVNode+=(span-1)*(list.length-1)+1}}}UpdateOldLayer(replacingNode,prevNode){const x=this.la.x[prevNode],y=this.la.y[prevNode];this.la.Layers[y][x]=replacingNode}WidenOriginalLayers(){for(let i=0;i<this.la.Layers.length;i++){const layer=this.Nla.Layers[2*i];let offset=0;for(const v of this.la.Layers[i]){const e=this.virtNodesToIntEdges[v];if(null!=e){const layerOffsetInTheEdge=this.NLayering[e.source]-this.NLayering[v],list=this.database.Multiedges.get(e.source,e.target);for(const ie of list)if(ie!=e){const u=ie.LayerEdges[layerOffsetInTheEdge].Source;layer[offset]=u,this.Nla.x[u]=offset++}else layer[offset]=v,this.Nla.x[v]=offset++}else layer[offset]=v,this.Nla.x[v]=offset++}}}FillUnsortedNewOddLayers(){const c=new Array(this.Nla.Layers.length).fill(0);for(let i=this.intGraph.nodeCount;i<this.nLayeredGraph.NodeCount;i++){const layer=this.NLayering[i];layer%2==1&&(this.Nla.Layers[layer][c[layer]++]=i)}}MapVirtualNodesToEdges(){this.virtNodesToIntEdges=new Array(this.NLayering.length);for(const e of this.database.AllIntEdges())if(e.source!=e.target&&null!=e.LayerEdges)for(const le of e.LayerEdges)le.Target!=e.target&&(this.virtNodesToIntEdges[le.Target]=e)}CreateFullLayeredGraph(){this.totalNodes=this.intGraph.nodeCount;for(const list of this.database.RegularMultiedges()){let span=0,first=!0;for(const e of list)if(first&&(first=!1,span=2*e.LayerSpan),span>0){e.LayerEdges=new Array(span);for(let i=0;i<span;i++){const bT={currentVV:this.totalNodes},source=EdgePathsInserter.GetSource(bT,e,i);this.totalNodes=bT.currentVV;const target=EdgePathsInserter.GetTarget(this.totalNodes,e,i,span);e.LayerEdges[i]=new LayerEdge(source,target,e.CrossingWeight)}LayerInserter.RegisterDontStepOnVertex(this.database,e)}}this.nLayeredGraph=new ProperLayeredGraph(this.intGraph)}SortNewOddLayers(){for(let i=1;i<this.Nla.Layers.length;i+=2){const sd=new SortedMap,layer=this.Nla.Layers[i];for(const v of layer){let predecessor=-1;for(const ie of this.nLayeredGraph.InEdges(v))predecessor=ie.Source;let successor=-1;for(const ie of this.nLayeredGraph.OutEdges(v))successor=ie.Target;const x=this.Nla.x[predecessor]+this.Nla.x[successor];if(sd.has(x)){const o=sd.get(x);if("number"==typeof o){const l=new Array;l.push(o),l.push(v),sd.set(x,l)}else{o.push(v)}}else sd.set(x,v)}let c=0;for(const v of sd.values())if("number"==typeof v)layer[c++]=v;else for(const k of v)layer[c++]=k;for(let m=0;m<layer.length;m++)this.Nla.x[layer[m]]=m}}InitNewLayering(){this.Nla=new LayerArrays(new Array(this.totalNodes));for(let i=0;i<this.layeredGraph.NodeCount;i++)this.NLayering[i]=2*this.la.y[i];for(const[ip,v]of this.database.Multiedges.keyValues())if(ip.x!=ip.y&&this.la.y[ip.x]!=this.la.y[ip.y]){const top=2*this.la.y[ip.x];for(const e of v){let layer=top-1;for(const le of e.LayerEdges)le.Target!=e.target&&(this.NLayering[le.Target]=layer--)}}const newLayers=new Array(2*this.la.Layers.length-1),counts=new Array(newLayers.length).fill(0);for(const l of this.NLayering)counts[l]++;for(let i=0;i<counts.length;i++)newLayers[i]=new Array(counts[i]);this.Nla=new LayerArrays(this.NLayering),this.Nla.Layers=newLayers}static RegisterDontStepOnVertex(db,parent){if(db.Multiedges.get(parent.source,parent.target).length>1){const e=parent.LayerEdges[parent.LayerEdges.length/2];db.MultipleMiddles.add(e.Source)}}}class EdgePathsInserter{constructor(layeredGraph,la,database,intGraphP){this.virtNodesToIntEdges=new Map,this.la=la,this.database=database,this.layeredGraph=layeredGraph,this.intGraph=intGraphP}get NLayering(){return this.Nla.y}static InsertPaths(layeredGraph,la,db,intGraphP){const li=new EdgePathsInserter(layeredGraph,la,db,intGraphP);return li.InsertPaths(),{layeredGraph:li.NLayeredGraph,la:li.Nla}}InsertPaths(){this.CreateFullLayeredGraph(),this.InitNewLayering(),this.MapVirtualNodesToEdges(),this.WidenOriginalLayers()}WidenOriginalLayers(){for(let i=0;i<this.la.Layers.length;i++){const layer=this.Nla.Layers[i];let offset=0;for(const v of this.la.Layers[i]){const e=this.virtNodesToIntEdges.get(v);if(null!=e){const layerOffsetInTheEdge=this.NLayering[e.source]-this.NLayering[v],list=this.database.Multiedges.get(e.source,e.target);for(const ie of list)if(!this.EdgeIsFlat(ie))if(ie!=e){const u=ie.LayerEdges[layerOffsetInTheEdge].Source;layer[offset]=u,this.Nla.x[u]=offset++}else layer[offset]=v,this.Nla.x[v]=offset++}else layer[offset]=v,this.Nla.x[v]=offset++}}}EdgeIsFlat(ie){return this.la.y[ie.source]==this.la.y[ie.target]}MapVirtualNodesToEdges(){for(const list of this.database.RegularMultiedges())for(const e of list)if(!this.EdgeIsFlat(e))for(const le of e.LayerEdges)le.Target!=e.target&&this.virtNodesToIntEdges.set(le.Target,e)}CreateFullLayeredGraph(){let currentVV=this.layeredGraph.NodeCount;for(const[k,list]of this.database.Multiedges.keyValues())if(k.x!=k.y){let first=!0,span=0;for(const e of list){if(first)first=!1,span=e.LayerSpan;else if(e.LayerEdges=new Array(span),1==span)e.LayerEdges[0]=new LayerEdge(e.source,e.target,e.CrossingWeight);else for(let i=0;i<span;i++){const bVV={currentVV:currentVV},source=EdgePathsInserter.GetSource(bVV,e,i);currentVV=bVV.currentVV;const target=EdgePathsInserter.GetTarget(currentVV,e,i,span);e.LayerEdges[i]=new LayerEdge(source,target,e.CrossingWeight)}LayerInserter.RegisterDontStepOnVertex(this.database,e)}}this.NLayeredGraph=new ProperLayeredGraph(this.intGraph)}static GetTarget(currentVV,e,i,span){return i<span-1?currentVV:e.target}static GetSource(boxedVV,e,i){return 0==i?e.source:boxedVV.currentVV++}InitNewLayering(){this.Nla=new LayerArrays(new Array(this.NLayeredGraph.NodeCount));for(let i=0;i<this.layeredGraph.NodeCount;i++)this.NLayering[i]=this.la.y[i];for(const[k,list]of this.database.Multiedges.keyValues())if(k.x!=k.y&&this.la.y[k.x]!=this.la.y[k.y]){let layer=0,first=!0;for(const e of list){first&&(first=!1,layer=this.la.y[e.source]);let cl=layer-1;for(const le of e.LayerEdges)this.NLayering[le.Target]=cl--}}const newLayers=new Array(this.la.Layers.length),counts=new Array(newLayers.length).fill(0);for(const l of this.NLayering)counts[l]++;for(let i=0;i<counts.length;i++)newLayers[i]=new Array(counts[i]);this.Nla=new LayerArrays(this.NLayering),this.Nla.Layers=newLayers}}const RANDOM_CONSTANT=BigInt("6364136223846793005"),U32_MASK=(BigInt(1)<<BigInt(32))-BigInt(1),U64_MASK=(BigInt(1)<<BigInt(64))-BigInt(1);class index_esm_Random{constructor(initState,initSequence){this._state=BigInt(0),this._inc=(BigInt(initSequence)<<BigInt(1)|BigInt(1))&U64_MASK,this._random_b(),this._state=this._state+BigInt(initState)&U64_MASK,this._random_b()}_random_b(){const old=this._state;this._state=old*RANDOM_CONSTANT+this._inc&U64_MASK;const xorshifted=(old>>BigInt(18)^old)>>BigInt(27),rightRot=old>>BigInt(59);return(xorshifted>>rightRot|xorshifted<<(rightRot^BigInt(31)))&U32_MASK}_advance(delta){delta&=U64_MASK;let mult_acc=BigInt(1),mult_curr=RANDOM_CONSTANT,plus_acc=BigInt(0),plus_curr=this._inc;for(;delta>0;)delta&BigInt(1)&&(mult_acc=mult_acc*mult_curr&U64_MASK,plus_acc=plus_acc*mult_curr+plus_curr&U64_MASK),plus_curr=(mult_curr+BigInt(1))*plus_curr&U64_MASK,mult_curr=mult_curr*mult_curr&U64_MASK,delta>>=BigInt(1);this._state=mult_acc*this._state+plus_acc&U64_MASK}randint(bound){if(bound>U32_MASK)throw new TypeError(`Bound too large: ${bound}`);if(bound<=0)throw new TypeError(`Empty sample space for r: 0  r < ${bound}`);const bound_big=BigInt(bound),threshold=(U32_MASK^bound_big)%bound_big;for(;;){const r=this._random_b();if(r>=threshold)return Number(r%bound_big)}}random(){return Number(this._random_b())/Math.pow(2,32)}}let generator;function randomInt(max){return null==generator&&(generator=new index_esm_Random(0,0)),generator.randint(max)}function random(){return null==generator&&(generator=new index_esm_Random(0,0)),generator.random()}class OrderingMeasure{constructor(layerArraysPar,numOfCrossings,virtualVertexStart){this.numberOfCrossings=numOfCrossings,this.la=layerArraysPar,this.virtVertexStart=virtualVertexStart}LayerGroupDisbalance(l,origGroupOptSize,virtGroupOptSize){return 1==origGroupOptSize?this.LayerGroupDisbalanceWithOrigSeparators(l,virtGroupOptSize):this.LayerGroupDisbalanceWithVirtSeparators(l,origGroupOptSize)}LayerGroupDisbalanceWithVirtSeparators(l,origGroupOptSize){let ret=0;for(let i=0;i<l.length;){const r=this.CurrentOrigGroupDelta(i,l,origGroupOptSize);i=r.i,ret+=r.ret}return ret}CurrentOrigGroupDelta(i,l,origGroupOptSize){let groupSize=0,j=i;for(;j<l.length&&l[j]<this.virtVertexStart;j++)groupSize++;return i=j+1,{ret:Math.abs(origGroupOptSize-groupSize),i:i}}LayerGroupDisbalanceWithOrigSeparators(l,virtGroupOptSize){let ret=0;for(let i=0;i<l.length;){const r=this.CurrentVirtGroupDelta(i,l,virtGroupOptSize);ret+=r.ret,i=r.i}return ret}CurrentVirtGroupDelta(i,l,virtGroupOptSize){let groupSize=0,j=i;for(;j<l.length&&l[j]>=this.virtVertexStart;j++)groupSize++;return i=j+1,{ret:Math.abs(virtGroupOptSize-groupSize),i:i}}static less(a,b){return a.numberOfCrossings<b.numberOfCrossings}static greater(a,b){return a.numberOfCrossings>b.numberOfCrossings}IsPerfect(){return 0==this.numberOfCrossings}}class EdgeComparerBySource{constructor(X){this.x=X}Compare(a,b){const r=this.x[a.Source]-this.x[b.Source];return 0!=r?r:this.x[a.Target]-this.x[b.Target]}}class EdgeComparerByTarget{constructor(X){this.x=X}Compare(a,b){const r=this.x[a.Target]-this.x[b.Target];return 0!=r?r:this.x[a.Source]-this.x[b.Source]}}class PointPair{constructor(first,second){comparePointsYFirst(first,second)<0?(this.first=first,this.second=second):(this.first=second,this.second=first)}get First(){return this.first}get Second(){return this.second}get Length(){return distPP(this.first,this.second)}CompareTo(other){const cr=comparePointsYFirst(this.first,other.first);return 0!=cr?cr:comparePointsYFirst(this.second,other.second)}static equal(pair0,pair1){return pair0.first.equal(pair1.first)&&pair0.second.equal(pair1.second)}toString(){return this.first+" "+this.second}}class PointSet{constructor(){this.size_=0,this.mapOfSets=new Map}delete(point){return this.deletexy(point.x,point.y)}clear(){this.mapOfSets.clear(),this.size_=0}get size(){return this.size_}static mk(points){const ret=new PointSet;for(const p of points)ret.add(p);return ret}addxy(x,y){let m=this.mapOfSets.get(x);null==m&&this.mapOfSets.set(x,m=new Set),m.has(y)||this.size_++,m.add(y)}add(p){return this.addxy(p.x,p.y),this}deletexy(x,y){const m=this.mapOfSets.get(x);return!(null==m||!m.delete(y))&&(this.size_--,!0)}hasxy(x,y){return this.mapOfSets.has(x)&&this.mapOfSets.get(x).has(y)}has(p){return this.hasxy(p.x,p.y)}forEach(callbackfn,thisArg){for(const p of this)callbackfn(p,p,thisArg)}*entries(){for(const p of this)yield[p,p]}keys(){return this.values()}*values(){for(const p of this.mapOfSets)for(const yV of p[1])yield new point_Point(p[0],yV)}[(Symbol.toStringTag,Symbol.iterator)](){return this.values()}}function substractSets(a,b){const ret=new Set;for(const u of a)b.has(u)||ret.add(u);return ret}function uniteSets(a,b){const ret=new Set(a);for(const v of b)ret.add(v);return ret}function addRange(array,addedArray){for(const t of addedArray)array.push(t)}function setIntersection(a,b){const ret=new Set;if(a.size<b.size)for(const t of a)b.has(t)&&ret.add(t);else for(const t of b)a.has(t)&&ret.add(t);return ret}function insertRange(collection,addedArray){for(const t of addedArray)collection.add(t)}function setsAreEqual(a,b){if(a.size!=b.size)return!1;for(const u of a)if(!b.has(u))return!1;return!0}function flatMap(arr,callback){const ret=[];for(const f of arr)for(const u of callback(f))ret.push(u);return ret}function addToMap(map,key,val){let s=map.get(key);s||(s=new Set,map.set(key,s)),s.add(val)}function addToMapOfArrays(map,key,val){let s=map.get(key);s||(s=new Array,map.set(key,s)),s.push(val)}function addToPointPairMap(map,key,val){let s=map.get(key);s||(s=new Set,map.set(key,s)),s.add(val)}function removeFromPointPairMapTuple(map,key,val){!function removeFromPointPairMap(map,key,val){const s=map.get(key);s&&s.delete(val)}(map,new PointPair(key[0],key[1]),val)}function HeadOfTheCoin(){return 0==randomInt(2)}function GetCrossingCountFromStrip(bottom,properLayeredGraph,layerArrays){const topVerts=layerArrays.Layers[bottom+1],bottomVerts=layerArrays.Layers[bottom];return bottomVerts.length<=topVerts.length?function GetCrossingCountFromStripWhenBottomLayerIsShorter(bottomVerts,properLayeredGraph,layerArrays){const edges=EdgesOfStrip(bottomVerts,properLayeredGraph),comparer=new EdgeComparerBySource(layerArrays.x);edges.sort(((a,b)=>comparer.Compare(a,b)));let n=1;for(;n<bottomVerts.length;)n*=2;const tree=new Array(2*n-1).fill(0);n--;let cc=0;for(const edge of edges){let index=n+layerArrays.x[edge.Target];const ew=edge.CrossingWeight;for(tree[index]+=ew;index>0;)index%2!=0&&(cc+=ew*tree[index+1]),index=Math.floor((index-1)/2),tree[index]+=ew}return cc}(bottomVerts,properLayeredGraph,layerArrays):function GetCrossingCountFromStripWhenTopLayerIsShorter(topVerts,bottomVerts,properLayeredGraph,layerArrays){const edges=EdgesOfStrip(bottomVerts,properLayeredGraph),comparer=new EdgeComparerByTarget(layerArrays.x);edges.sort(((a,b)=>comparer.Compare(a,b)));let n=1;for(;n<topVerts.length;)n*=2;const tree=new Array(2*n-1).fill(0);n--;let cc=0;for(const edge of edges){let index=n+layerArrays.x[edge.Source];const ew=edge.CrossingWeight;for(tree[index]+=ew;index>0;)index%2!=0&&(cc+=ew*tree[index+1]),index=Math.floor((index-1)/2),tree[index]+=ew}return cc}(topVerts,bottomVerts,properLayeredGraph,layerArrays)}function EdgesOfStrip(bottomVerts,properLayeredGraph){return flatMap(bottomVerts,(v=>Array.from(properLayeredGraph.InEdges(v))))}function GetCrossingsTotal(properLayeredGraph,layerArrays){let x=0;for(let i=0;i<layerArrays.Layers.length-1;i++)x+=GetCrossingCountFromStrip(i,properLayeredGraph,layerArrays);return x}class Ordering extends Algorithm{constructor(graphPar,tryReverse,layerArraysParam,startOfVirtualNodes,hasCrossWeights,settings,cancelToken){super(cancelToken),this.tryReverse=!0,this.MaxNumberOfAdjacentExchanges=50,this.cancelToken=cancelToken,this.tryReverse=tryReverse,this.startOfVirtNodes=startOfVirtualNodes,this.layerArrays=layerArraysParam,this.layering=layerArraysParam.y,this.nOfLayers=layerArraysParam.Layers.length,this.layers=layerArraysParam.Layers,this.properLayeredGraph=graphPar,this.hasCrossWeights=hasCrossWeights,this.SugSettings=settings}get NoGainStepsBound(){return this.SugSettings.NoGainAdjacentSwapStepsBound*this.SugSettings.RepetitionCoefficientForOrdering}get SeedOfRandom(){return randomInt(100)}get MaxOfIterations(){return this.SugSettings.MaxNumberOfPassesInOrdering*this.SugSettings.RepetitionCoefficientForOrdering}static OrderLayers(graph,layerArrays,startOfVirtualNodes,settings,cancelToken){let hasCrossWeight=!1;for(const le of graph.Edges)if(1!=le.CrossingWeight){hasCrossWeight=!0;break}new Ordering(graph,!0,layerArrays,startOfVirtualNodes,hasCrossWeight,settings,cancelToken).run()}run(){if(this.Calculate(),this.tryReverse){const secondLayers=this.layerArrays.ReversedClone(),revOrdering=new Ordering(this.properLayeredGraph.ReversedClone(),!1,secondLayers,this.startOfVirtNodes,this.hasCrossWeights,this.SugSettings,this.cancelToken);if(revOrdering.run(),revOrdering.measure<this.measure){for(let j=0;j<this.nOfLayers;j++)copyTo(secondLayers.Layers[j],this.layerArrays.Layers[this.nOfLayers-1-j]);this.layerArrays.UpdateXFromLayers()}}}Calculate(){this.Init(),this.layerArraysCopy=Ordering.CloneLayers(this.layers,this.layerArraysCopy);let countOfNoGainSteps=0;this.measure=new OrderingMeasure(this.layerArraysCopy,GetCrossingsTotal(this.properLayeredGraph,this.layerArrays),this.startOfVirtNodes);for(let i=0;i<this.MaxOfIterations&&countOfNoGainSteps<this.NoGainStepsBound&&!this.measure.IsPerfect();i++){const up=i%2==0;this.LayerByLayerSweep(up),this.AdjacentExchange();const newMeasure=new OrderingMeasure(this.layerArrays.Layers,GetCrossingsTotal(this.properLayeredGraph,this.layerArrays),this.startOfVirtNodes);this.measure<newMeasure?(this.Restore(),countOfNoGainSteps++):(newMeasure<this.measure||HeadOfTheCoin())&&(countOfNoGainSteps=0,this.layerArraysCopy=Ordering.CloneLayers(this.layers,this.layerArraysCopy),this.measure=newMeasure)}}static CloneLayers(layers,layerArraysCopy){if(null==layerArraysCopy){layerArraysCopy=new Array(layers.length);for(let i=0;i<layers.length;i++)layerArraysCopy[i]=layers[i].map((i=>i))}else for(let i=0;i<layers.length;i++)copyTo(layers[i],layerArraysCopy[i]);return layerArraysCopy}Restore(){this.layerArrays.updateLayers(this.layerArraysCopy)}LayerByLayerSweep(up){if(up)for(let i=1;i<this.nOfLayers;i++)this.SweepLayer(i,!0);else for(let i=this.nOfLayers-2;i>=0;i--)this.SweepLayer(i,!1)}SweepLayer(layer,upperLayer){const l=this.layers[layer],medianValues=new Array(l.length);for(let i=0;i<medianValues.length;i++)medianValues[i]=this.WMedian(l[i],upperLayer);this.Sort(layer,medianValues);const vertices=this.layerArrays.Layers[layer];for(let i=0;i<vertices.length;i++)this.layerArrays.x[vertices[i]]=i}Sort(layerToSort,medianValues){const s=new SortedMap,vertices=this.layers[layerToSort];let i=0;for(const m of medianValues){const v=vertices[i++];if(-1!=m)if(s.has(m)){const o=s.get(m);if("number"!=typeof o){const al=o;if(HeadOfTheCoin())al.push(v);else{const j=randomInt(al.length),k=al[j];al[j]=v,al.push(k)}}else{const io=o,al=new Array;s.set(m,al),HeadOfTheCoin()?(al.push(io),al.push(v)):(al.push(v),al.push(io))}}else s.set(m,v)}const senum=s.values();for(i=0;i<vertices.length;)if(-1!=medianValues[i]){const o=senum.next().value;if("number"==typeof o)vertices[i++]=o;else{const al=o;for(const v of al){for(;-1==medianValues[i];)i++;vertices[i++]=v}}}else i++}WMedian(node,theMedianGoingDown){let edges,p;if(theMedianGoingDown?(edges=this.properLayeredGraph.OutEdges(node),p=this.properLayeredGraph.OutEdgesCount(node)):(edges=this.properLayeredGraph.InEdges(node),p=this.properLayeredGraph.InEdgesCount(node)),0==p)return-1;const parray=new Array(p);let i=0;if(theMedianGoingDown)for(const e of edges)parray[i++]=this.X[e.Target];else for(const e of edges)parray[i++]=this.X[e.Source];parray.sort(((a,b)=>a-b));const m=Math.floor(p/2);if(p%2==1)return parray[m];if(2==p)return.5*(parray[0]+parray[1]);const left=parray[m-1]-parray[0],right=parray[p-1]-parray[m];return Math.floor((parray[m-1]*left+parray[m]*right)/(left+right))}Init(){const counts=new Array(this.nOfLayers).fill(0),q=new lib_src.B;for(let i=0;i<this.properLayeredGraph.NodeCount;i++)0==this.properLayeredGraph.InEdgesCount(i)&&q.push(i);const visited=new Array(this.properLayeredGraph.NodeCount).fill(!1);for(;q.size>0;){const u=q.pop(),l=this.layerArrays.y[u];this.layerArrays.Layers[l][counts[l]]=u,this.layerArrays.x[u]=counts[l],counts[l]++;for(const v of this.properLayeredGraph.Succ(u))visited[v]||(visited[v]=!0,q.push(v))}this.X=this.layerArrays.x}AdjacentExchange(){this.InitArrays();let count=0,progress=!0;for(;progress&&count++<this.MaxNumberOfAdjacentExchanges;){progress=!1;for(let i=0;i<this.layers.length;i++)progress=this.AdjExchangeLayer(i)||progress;for(let i=this.layers.length-2;i>=0;i--)progress=this.AdjExchangeLayer(i)||progress}}AllocArrays(){const n=this.properLayeredGraph.NodeCount;this.predecessors=new Array(n),this.successors=new Array(n),this.pOrder=new Array(n),this.sOrder=new Array(n),this.hasCrossWeights&&(this.outCrossingCount=new Array(n),this.inCrossingCount=new Array(n));for(let i=0;i<n;i++){let count=this.properLayeredGraph.InEdgesCount(i);if(this.predecessors[i]=new Array(count),this.hasCrossWeights){const inCounts=this.inCrossingCount[i]=new Map;for(const le of this.properLayeredGraph.InEdges(i))inCounts.set(le.Source,le.CrossingWeight)}if(this.pOrder[i]=new Map,count=this.properLayeredGraph.OutEdgesCount(i),this.successors[i]=new Array(count),this.sOrder[i]=new Map,this.hasCrossWeights){const outCounts=this.outCrossingCount[i]=new Map;for(const le of this.properLayeredGraph.OutEdges(i))outCounts.set(le.Target,le.CrossingWeight)}}}InitArrays(){null==this.successors&&this.AllocArrays();for(let i=0;i<this.properLayeredGraph.NodeCount;i++)this.pOrder[i]=new Map,this.sOrder[i]=new Map;for(const t of this.layers)this.InitPsArraysForLayer(t)}CalcPair(u,v){const su=this.successors[u],sv=this.successors[v],pu=this.predecessors[u],pv=this.predecessors[v];if(this.hasCrossWeights){const uOutCrossCounts=this.outCrossingCount[u],vOutCrossCounts=this.outCrossingCount[v],uInCrossCounts=this.inCrossingCount[u],vInCrossCounts=this.inCrossingCount[v];return{cuv:this.CountOnArraysUV(su,sv,uOutCrossCounts,vOutCrossCounts)+this.CountOnArraysUV(pu,pv,uInCrossCounts,vInCrossCounts),cvu:this.CountOnArraysUV(sv,su,vOutCrossCounts,uOutCrossCounts)+this.CountOnArraysUV(pv,pu,vInCrossCounts,uInCrossCounts)}}return{cuv:this.CountOnArrays(su,sv)+this.CountOnArrays(pu,pv),cvu:this.CountOnArrays(sv,su)+this.CountOnArrays(pv,pu)}}InitPsArraysForLayer(layer){for(const l of layer){for(const p of this.properLayeredGraph.Pred(l)){const so=this.sOrder[p],sHasNow=so.size;this.successors[p][sHasNow]=l,so.set(l,sHasNow)}for(const s of this.properLayeredGraph.Succ(l)){const po=this.pOrder[s],pHasNow=po.size;this.predecessors[s][pHasNow]=l,po.set(l,pHasNow)}}}CountOnArrays(unbs,vnbs){let ret=0;const vl=vnbs.length-1;let j=-1,vnbsSeenAlready=0;for(const uNeighbor of unbs){const xu=this.X[uNeighbor];for(;j<vl&&this.X[vnbs[j+1]]<xu;j++)vnbsSeenAlready++;ret+=vnbsSeenAlready}return ret}CountOnArraysUV(unbs,vnbs,uCrossingCounts,vCrossingCount){let ret=0;const vl=vnbs.length-1;let j=-1,vCrossingNumberSeenAlready=0;for(const uNeib of unbs){const xu=this.X[uNeib];let vnb;for(;j<vl&&this.X[vnb=vnbs[j+1]]<xu;j++)vCrossingNumberSeenAlready+=vCrossingCount.get(vnb);ret+=vCrossingNumberSeenAlready*uCrossingCounts.get(uNeib)}return ret}AdjExchangeLayer(i){const layer=this.layers[i];return!!this.ExchangeWithGainWithNoDisturbance(layer)||(this.DisturbLayer(layer),this.ExchangeWithGainWithNoDisturbance(layer))}Swap(u,v){const left=this.X[u],right=this.X[v],ln=this.layering[u],layer=this.layers[ln];layer[left]=v,layer[right]=u,this.X[u]=right,this.X[v]=left,this.UpdateSsContainingUv(u,v),this.UpdatePsContainingUv(u,v)}UpdatePsContainingUv(u,v){if(this.successors[u].length<=this.successors[v].length)for(const a of this.successors[u]){const porder=this.pOrder[a];if(porder.has(v)){const vOffset=porder.get(v),p=this.predecessors[a];p[vOffset-1]=v,p[vOffset]=u,porder.set(v,vOffset-1),porder.set(u,vOffset)}}else for(const a of this.successors[v]){const porder=this.pOrder[a];if(porder.has(u)){const vOffset=porder.get(v),p=this.predecessors[a];p[vOffset-1]=v,p[vOffset]=u,porder.set(v,vOffset-1),porder.set(u,vOffset)}}}UpdateSsContainingUv(u,v){if(this.predecessors[u].length<=this.predecessors[v].length)for(const a of this.predecessors[u]){const sorder=this.sOrder[a];if(sorder.has(v)){const vOffset=sorder.get(v),s=this.successors[a];s[vOffset-1]=v,s[vOffset]=u,sorder.set(v,vOffset-1),sorder.set(u,vOffset)}}else for(const a of this.predecessors[v]){const sorder=this.sOrder[a];if(sorder.has(u)){const vOffset=sorder.get(v),s=this.successors[a];s[vOffset-1]=v,s[vOffset]=u,sorder.set(v,vOffset-1),sorder.set(u,vOffset)}}}DisturbLayer(layer){for(let i=0;i<layer.length-1;i++)this.AdjacentSwapToTheRight(layer,i)}ExchangeWithGainWithNoDisturbance(layer){let gain,wasGain=!1;do{gain=this.ExchangeWithGain(layer),wasGain=wasGain||gain}while(gain);return wasGain}ExchangeWithGain(layer){for(let i=0;i<layer.length-1;i++)if(this.SwapWithGain(layer[i],layer[i+1]))return this.SwapToTheLeft(layer,i),this.SwapToTheRight(layer,i+1),!0;return!1}SwapToTheLeft(layer,i){for(let j=i-1;j>=0;j--)this.AdjacentSwapToTheRight(layer,j)}SwapToTheRight(layer,i){for(let j=i;j<layer.length-1;j++)this.AdjacentSwapToTheRight(layer,j)}AdjacentSwapToTheRight(layer,i){const u=layer[i],v=layer[i+1],gain=this.SwapGain(u,v);(gain>0||0==gain&&HeadOfTheCoin())&&this.Swap(u,v)}SwapGain(u,v){const r=this.CalcPair(u,v);return r.cuv-r.cvu}UvAreOfSameKind(u,v){return u<this.startOfVirtNodes&&v<this.startOfVirtNodes||u>=this.startOfVirtNodes&&v>=this.startOfVirtNodes}NeighborsForbidTheSwap(u,v){return this.UpperNeighborsForbidTheSwap(u,v)||this.LowerNeighborsForbidTheSwap(u,v)}LowerNeighborsForbidTheSwap(u,v){let uCount,vCount;return 0!=(uCount=this.properLayeredGraph.OutEdgesCount(u))&&0!=(vCount=this.properLayeredGraph.OutEdgesCount(v))&&this.X[this.successors[u][uCount>>1]]<this.X[this.successors[v][vCount>>1]]}UpperNeighborsForbidTheSwap(u,v){const uCount=this.properLayeredGraph.InEdgesCount(u),vCount=this.properLayeredGraph.InEdgesCount(v);return 0!=uCount&&0!=vCount&&this.X[this.predecessors[u][uCount>>1]]<this.X[this.predecessors[v][vCount>>1]]}CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(layer,separatorPosition,separator){const kind=this.GetKindDelegate(separator);let leftGroupSize=0;for(let i=separatorPosition-1;i>=0&&!kind(layer[i]);i--)leftGroupSize++;let rightGroupSize=0;for(let i=separatorPosition+1;i<layer.length&&!kind(layer[i]);i++)rightGroupSize++;return leftGroupSize-rightGroupSize}IsOriginal(v){return v<this.startOfVirtNodes}IsVirtual(v){return v>=this.startOfVirtNodes}GetKindDelegate(v){return this.IsVirtual(v)?this.IsVirtual:this.IsOriginal}SwapWithGain(u,v){return this.SwapGain(u,v)>0&&(this.Swap(u,v),!0)}}class PointMap{constructor(){this.size_=0,this.mapOfMaps=new Map}deleteP(point){return this.delete(point.x,point.y)}clear(){this.mapOfMaps.clear(),this.size_=0}get size(){return this.size_}setxy(x,y,v){let m=this.mapOfMaps.get(x);null==m&&this.mapOfMaps.set(x,m=new Map),m.has(y)||this.size_++,m.set(y,v)}set(p,v){this.setxy(p.x,p.y,v)}delete(x,y){const m=this.mapOfMaps.get(x);return null!=m&&(m.delete(y)&&this.size_--,!0)}hasxy(x,y){const m=this.mapOfMaps.get(x);return null!=m&&m.has(y)}has(p){return this.hasxy(p.x,p.y)}getxy(x,y){const m=this.mapOfMaps.get(x);if(null!=m)return m.get(y)}get(p){return this.getxy(p.x,p.y)}*keys(){for(const p of this.mapOfMaps)for(const yp of p[1])yield new point_Point(p[0],yp[0])}*[Symbol.iterator](){for(const p of this.mapOfMaps)for(const yV of p[1])yield[new point_Point(p[0],yV[0]),yV[1]]}*values(){for(const p of this.mapOfMaps)for(const yV of p[1])yield yV[1]}}class MetroMapOrdering{constructor(properLayeredGraph,layerArrays,nodePositions){this.properLayeredGraph=properLayeredGraph,this.layerArrays=layerArrays,this.nodePositions=nodePositions}static UpdateLayerArrays0(properLayeredGraph,layerArrays,nodePositions){new MetroMapOrdering(properLayeredGraph,layerArrays,nodePositions).UpdateLayerArrays()}static UpdateLayerArrays1(properLayeredGraph,layerArrays){const nodePositions=MetroMapOrdering.BuildInitialNodePositions(properLayeredGraph,layerArrays);this.UpdateLayerArrays0(properLayeredGraph,layerArrays,nodePositions)}static BuildInitialNodePositions(properLayeredGraph,layerArrays){const result=new Map;for(let i=0;i<layerArrays.Layers.length;i++){let curr=0,prev=0;for(;curr<layerArrays.Layers[i].length;){for(;curr<layerArrays.Layers[i].length&&properLayeredGraph.IsVirtualNode(layerArrays.Layers[i][curr]);)curr++;for(let j=prev;j<curr;j++)result.set(layerArrays.Layers[i][j],new point_Point(i,prev));curr<layerArrays.Layers[i].length&&result.set(layerArrays.Layers[i][curr],new point_Point(i,curr)),curr++,prev=curr}}return result}UpdateLayerArrays(){let ordering=this.CreateInitialOrdering();ordering=this.BuildOrdering(ordering),this.RestoreLayerArrays(ordering)}CreateInitialOrdering(){const initialOrdering=new PointMap;for(const layer of this.layerArrays.Layers)for(const node of layer){const p=this.nodePositions.get(node);initialOrdering.hasxy(p.x,p.y)||initialOrdering.setxy(p.x,p.y,[]),initialOrdering.getxy(p.x,p.y).push(node)}return initialOrdering}BuildOrdering(initialOrdering){const result=new PointMap,inverseOrder=new Map;for(const layer of this.layerArrays.Layers)for(const node of layer){const p=this.nodePositions.get(node);result.hasxy(p.x,p.y)||(this.BuildNodeOrdering(initialOrdering.get(p),inverseOrder),result.set(p,initialOrdering.get(p)))}return result}BuildNodeOrdering(result,inverseToOrder){result.sort(this.Comparison(inverseToOrder));for(let i=0;i<result.length;i++)inverseToOrder.set(result[i],i)}firstSucc(node){for(const s of this.properLayeredGraph.Succ(node))return s}firstPred(node){for(const s of this.properLayeredGraph.Pred(node))return s}Comparison(inverseToOrder){return(node1,node2)=>{const succ1=this.firstSucc(node1),succ2=this.firstSucc(node2);let pred1=this.firstPred(node1),pred2=this.firstPred(node2);const succPoint1=this.nodePositions.get(succ1),succPoint2=this.nodePositions.get(succ2),predPoint1=this.nodePositions.get(pred1),predPoint2=this.nodePositions.get(pred2);if(!succPoint1.equal(succPoint2))return predPoint1.equal(predPoint2)?succPoint1.compareTo(succPoint2):predPoint1.compareTo(predPoint2);if(this.properLayeredGraph.IsVirtualNode(succ1)){if(!predPoint1.equal(predPoint2))return predPoint1.compareTo(predPoint2);return compareNumbers(inverseToOrder.get(succ1),inverseToOrder.get(succ2))}for(;this.nodePositions.get(pred1).equal(this.nodePositions.get(pred2))&&this.properLayeredGraph.IsVirtualNode(pred1);)pred1=this.firstPred(pred1),pred2=this.firstPred(pred2);return this.nodePositions.get(pred1).equal(this.nodePositions.get(pred2))?compareNumbers(node1,node2):this.nodePositions.get(pred1).compareTo(this.nodePositions.get(pred2))}}RestoreLayerArrays(ordering){for(const layer of this.layerArrays.Layers){let tec=0,pred=0;for(;tec<layer.length;){for(;tec<layer.length&&this.nodePositions.get(layer[pred]).equal(this.nodePositions.get(layer[tec]));)tec++;const t=ordering.get(this.nodePositions.get(layer[pred]));for(let j=pred;j<tec;j++)layer[j]=t[j-pred];pred=tec}}this.layerArrays.UpdateXFromLayers()}}class TopologicalSort{static getOrder(numberOfVertices,edges){const dag=mkGraphOnEdgesN(edges.map((([u,v])=>new IntPair(u,v))),numberOfVertices);return TopologicalSort.getOrderOnGraph(dag)}static getOrderOnGraph(graph){const visited=new Array(graph.nodeCount).fill(!1),se=new lib_src.B,order=[];let en;for(let u=0;u<graph.nodeCount;u++){if(visited[u])continue;let cu=u;visited[cu]=!0;let i=0;for(en=graph.outEdges[u];;){for(;i<en.length;i++){const v=en[i].target;visited[v]||(visited[v]=!0,se.push({edges:en,index:i+1,current_u:cu}),cu=v,en=graph.outEdges[cu],i=-1)}if(order.push(cu),!(se.length>0))break;{const t=se.pop();en=t.edges,i=t.index,cu=t.current_u}}}return order.reverse()}}class LongestPathLayering{constructor(graph){this.graph=graph}GetLayers(){const topoOrder=TopologicalSort.getOrderOnGraph(this.graph),layering=new Array(this.graph.nodeCount).fill(0);let k=this.graph.nodeCount;for(;k-- >0;){const v=topoOrder[k];for(const e of this.graph.inEdges[v]){const u=e.source,l=layering[v]+e.separation;layering[u]<l&&(layering[u]=l)}}return layering}checkTopoOrder(topoOrder){for(const e of this.graph.edges)if(edgeIsOff(e,topoOrder))return!1;return!0}}function edgeIsOff(e,topoOrder){const i=topoOrder.findIndex((x=>x==e.source)),j=topoOrder.findIndex((x=>x==e.target));return-1==i||-1==j||i>=j}class NetworkEdge{constructor(e){this.inTree=!1,this.cut=NetworkEdge.infinity,this.iedge=e}get source(){return this.iedge.source}get target(){return this.iedge.target}get separation(){return this.iedge.separation}get crossingWeight(){return this.iedge.CrossingWeight}get weight(){return this.iedge.weight}}NetworkEdge.infinity=Number.MAX_SAFE_INTEGER;class NetworkSimplex_StackStruct{constructor(v,outEnum,i,inEnum,j){this.v=v,this.outEnum=outEnum,this.i=i,this.inEnum=inEnum,this.j=j}}class NetworkSimplex{constructor(graph,cancelToken){this.layers=null,this.treeVertices=[],this.vertices=[],this.leaves=[],this.graph=function CreateGraphWithIEEdges(bg){const ieEdges=new Array;for(const e of bg.edges)ieEdges.push(new NetworkEdge(e));return mkGraphOnEdgesN(ieEdges,bg.nodeCount)}(graph),this.networkCancelToken=cancelToken;for(let i=0;i<this.graph.nodeCount;i++)this.vertices.push({inTree:!1,lim:-1,low:-1,parent:null})}get weight(){return this.graph.edges.map((e=>e.weight*(this.layers[e.source]-this.layers[e.target]))).reduce(((sum,w)=>sum+w),0)}get nodeCount(){return this.vertices.length}setLow(v,l){this.vertices[v].low=l}setLim(v,l){this.vertices[v].lim=l}setParent(v,e){this.vertices[v].parent=e}GetLayers(){return null==this.layers&&this.run(),this.layers}shiftLayerToZero(){const minLayer=Math.min(...this.layers);for(let i=0;i<this.layers.length;i++)this.layers[i]-=minLayer}addVertexToTree(v){this.vertices[v].inTree=!0}vertexInTree(v){return this.vertices[v].inTree}lim(v){return this.vertices[v].lim}low(v){return this.vertices[v].low}parent(v){return this.vertices[v].parent}feasibleTree(){for(this.initLayers();this.tightTree()<this.nodeCount;){const e=this.getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();if(null==e)break;let slack=this.slack(e);this.vertexInTree(e.source)&&(slack=-slack);for(const i of this.treeVertices)this.layers[i]+=slack}this.initCutValues()}vertexSourceTargetVal(v,treeEdge){const s=treeEdge.source,t=treeEdge.target;return this.lim(s)>this.lim(t)?this.lim(v)<=this.lim(t)&&this.low(t)<=this.lim(v)?0:1:this.lim(v)<=this.lim(s)&&this.low(s)<=this.lim(v)?1:0}incidentEdges(v){return this.graph.incidentEdges(v)}allLowCutsHaveBeenDone(v){for(const ie of this.incidentEdges(v))if(ie.inTree&&ie.cut==NetworkEdge.infinity&&ie!=this.parent(v))return!1;return!0}edgeSourceTargetVal(e,treeEdge){return this.vertexSourceTargetVal(e.source,treeEdge)-this.vertexSourceTargetVal(e.target,treeEdge)}initCutValues(){this.initLimLowAndParent();let front=new lib_src.B;for(const i of this.leaves)front.push(i);let newFront=new lib_src.B;for(;front.length>0;){for(;front.length>0;){const w=front.pop(),cutEdge=this.parent(w);if(null==cutEdge)continue;let cut=0;for(const e of this.incidentEdges(w))if(0==e.inTree){const e0Val=this.edgeSourceTargetVal(e,cutEdge);0!=e0Val&&(cut+=e0Val*e.weight)}else if(e==cutEdge)cut+=e.weight;else{const impact=cutEdge.source==e.target||cutEdge.target==e.source?1:-1;cut+=this.edgeContribution(e,w)*impact}cutEdge.cut=cut;const v=cutEdge.source==w?cutEdge.target:cutEdge.source;this.allLowCutsHaveBeenDone(v)&&newFront.push(v)}const t=front;front=newFront,newFront=t}}edgeContribution(e,w){let ret=e.cut-e.weight;for(const ie of this.incidentEdges(w))if(0==ie.inTree){const sign=this.edgeSourceTargetVal(ie,e);-1==sign?ret+=ie.weight:1==sign&&(ret-=ie.weight)}return ret}initLimLowAndParent(){this.initLowLimParentAndLeavesOnSubtree(1,0)}initLowLimParentAndLeavesOnSubtree(curLim,v){const stack=new lib_src.B;let outEnum=this.graph.outEdges[v],i=-1,inEnum=this.graph.inEdges[v],j=-1;for(stack.push(new NetworkSimplex_StackStruct(v,outEnum,i,inEnum,j)),this.vertices[v].low=curLim;stack.length>0;){const ss=stack.pop();let done;v=ss.v,outEnum=ss.outEnum,i=ss.i,inEnum=ss.inEnum,j=ss.j;do{for(done=!0;++i<outEnum.length;){const e=outEnum[i];!e.inTree||this.vertices[e.target].low>0||(stack.push(new NetworkSimplex_StackStruct(v,outEnum,i,inEnum,j)),v=e.target,this.setParent(v,e),this.setLow(v,curLim),outEnum=this.graph.outEdges[v],i=-1,inEnum=this.graph.inEdges[v],j=-1)}for(;++j<inEnum.length;){const e=inEnum[j];if(e.inTree&&!(this.vertices[e.source].low>0)){stack.push(new NetworkSimplex_StackStruct(v,outEnum,i,inEnum,j)),v=e.source,this.setLow(v,curLim),this.setParent(v,e),outEnum=this.graph.outEdges[v],i=-1,inEnum=this.graph.inEdges[v],j=-1,done=!1;break}}}while(!done);this.setLim(v,curLim++),this.lim(v)==this.low(v)&&this.leaves.push(v)}}updateLimLowLeavesAndParentsUnderNode(l){const llow=this.vertices[l].low,llim=this.vertices[l].lim;this.leaves=[];for(let i=0;i<this.nodeCount;i++)llow<=this.vertices[i].lim&&this.vertices[i].lim<=llim?this.setLow(i,0):this.low(i)==this.lim(i)&&this.leaves.push(i);this.initLowLimParentAndLeavesOnSubtree(llow,l)}slack(e){return this.layers[e.source]-this.layers[e.target]-e.separation}getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack(){let eret=null,minSlack=NetworkEdge.infinity;for(const v of this.treeVertices){for(const e of this.graph.outEdges[v]){if(this.vertexInTree(e.source)&&this.vertexInTree(e.target))continue;const slack=this.slack(e);if(slack<minSlack&&(eret=e,minSlack=slack,1==slack))return e}for(const e of this.graph.inEdges[v]){if(this.vertexInTree(e.source)&&this.vertexInTree(e.target))continue;const slack=this.slack(e);if(slack<minSlack&&(eret=e,minSlack=slack,1==slack))return e}}return eret}tightTree(){this.treeVertices=[];for(const ie of this.graph.edges)ie.inTree=!1;for(let i=1;i<this.nodeCount;i++)this.vertices[i].inTree=!1;this.vertices[0].inTree=!0,this.treeVertices.push(0);const q=new lib_src.B;for(q.push(0);q.length>0;){const v=q.pop();for(const e of this.graph.outEdges[v])this.vertexInTree(e.target)||this.layers[e.source]-this.layers[e.target]==e.separation&&(q.push(e.target),this.addVertexToTree(e.target),this.treeVertices.push(e.target),e.inTree=!0);for(const e of this.graph.inEdges[v])this.vertexInTree(e.source)||this.layers[e.source]-this.layers[e.target]==e.separation&&(q.push(e.source),this.addVertexToTree(e.source),this.treeVertices.push(e.source),e.inTree=!0)}return this.treeVertices.length}leaveEnterEdge(){let leavingEdge,enteringEdge,minCut=0;for(const e of this.graph.edges)e.inTree&&e.cut<minCut&&(minCut=e.cut,leavingEdge=e);if(null==leavingEdge)return null;let continuation=!1,minSlack=NetworkEdge.infinity;for(const f of this.graph.edges){const slack=this.slack(f);if(0==f.inTree&&-1==this.edgeSourceTargetVal(f,leavingEdge)&&(slack<minSlack||slack==minSlack&&(continuation=1==randomInt(2)))){if(minSlack=slack,enteringEdge=f,0==minSlack&&!continuation)break;continuation=!1}}if(null==enteringEdge)throw new Error;return{leaving:leavingEdge,entering:enteringEdge}}exchange(e,f){const l=this.commonPredecessorOfSourceAndTargetOfF(f);this.createPathForCutUpdates(e,f,l),this.updateLimLowLeavesAndParentsUnderNode(l),this.updateCuts(e),this.updateLayersUnderNode(l)}updateLayersUnderNode(l){const front=new lib_src.B;front.push(l);for(let i=0;i<this.nodeCount;i++)this.low(l)<=this.lim(i)&&this.lim(i)<=this.lim(l)&&i!=l&&(this.layers[i]=NetworkEdge.infinity);for(;front.length>0;){const u=front.pop();for(const oe of this.graph.outEdges[u])oe.inTree&&this.layers[oe.target]==NetworkEdge.infinity&&(this.layers[oe.target]=this.layers[u]-oe.separation,front.push(oe.target));for(const ie of this.graph.inEdges[u])ie.inTree&&this.layers[ie.source]==NetworkEdge.infinity&&(this.layers[ie.source]=this.layers[u]+ie.separation,front.push(ie.source))}}updateCuts(e){let front=new lib_src.B,newFront=new lib_src.B;for(front.push(e.source),front.push(e.target);front.length>0;){for(;front.length>0;){const w=front.pop(),cutEdge=this.parent(w);if(null==cutEdge)continue;if(cutEdge.cut!=NetworkEdge.infinity)continue;let cut=0;for(const ce of this.incidentEdges(w))if(0==ce.inTree)cut+=this.edgeSourceTargetVal(ce,cutEdge)*ce.weight;else if(ce==cutEdge)cut+=ce.weight;else{const impact=cutEdge.source==ce.target||cutEdge.target==ce.source?1:-1;cut+=this.edgeContribution(ce,w)*impact}cutEdge.cut=cut;const u=cutEdge.source==w?cutEdge.target:cutEdge.source;this.allLowCutsHaveBeenDone(u)&&newFront.push(u)}const t=front;front=newFront,newFront=t}}createPathForCutUpdates(e,f,l){let v=f.target;for(;v!=l;){const p=this.parent(v);p.cut=NetworkEdge.infinity,v=p.source==v?p.target:p.source}f.cut=NetworkEdge.infinity,e.inTree=!1,f.inTree=!0}commonPredecessorOfSourceAndTargetOfF(f){let fMin,fmax;this.lim(f.source)<this.lim(f.target)?(fMin=this.lim(f.source),fmax=this.lim(f.target)):(fMin=this.lim(f.target),fmax=this.lim(f.source));let l=f.source;for(;0==(this.low(l)<=fMin&&fmax<=this.lim(l));){const p=this.parent(l);p.cut=NetworkEdge.infinity,l=p.source==l?p.target:p.source}return l}checkCutValues(){for(const e of this.graph.edges)if(e.inTree){let cut=0;for(const f of this.graph.edges)cut+=this.edgeSourceTargetVal(f,e)*f.weight;e.cut!=cut&&console.log(dist.Qf.Format("cuts are wrong for {0}; should be {1} but is {2}",e,cut,e.cut))}}initLayers(){const lp=new LongestPathLayering(this.graph);return this.layers=lp.GetLayers()}run(){if(0==this.graph.edges.length&&0==this.graph.nodeCount)this.layers=[];else{let leaveEnter;for(this.feasibleTree();null!=(leaveEnter=this.leaveEnterEdge());)this.exchange(leaveEnter.leaving,leaveEnter.entering);this.shiftLayerToZero()}}}class NetworkSimplexForGeneralGraph{constructor(graph,cancelObject){this.graph=graph,this.Cancel=cancelObject}GetLayers(){return new NetworkSimplex(this.graph,this.Cancel).GetLayers()}ShrunkComponent(dictionary){const edges=[];for(const p of dictionary){const v=p[0],newEdgeSource=p[1];for(const e of this.graph.outEdges[v]){const pe=new PolyIntEdge(newEdgeSource,dictionary.get(e.target),e.edge);pe.separation=e.separation,pe.weight=e.weight,edges.push(pe)}}return new BasicGraph(edges,dictionary.size)}}class Anchor{constructor(labelCornersPreserveCoefficient){this.padding=0,this.alreadySitsOnASpline=!1,this.labelIsToTheLeftOfTheSpline=!1,this.labelIsToTheRightOfTheSpline=!1,this.labelCornersPreserveCoefficient=labelCornersPreserveCoefficient}toString(){return"la:ra "+this.la+" "+this.ra+" ta:ba "+this.ta+" "+this.ba+" x:y "+this.x_+" "+this.y_}get leftAnchor(){return this.la}set leftAnchor(value){this.la=Math.max(value,0)}get rightAnchor(){return this.ra}set rightAnchor(value){this.ra=Math.max(value,0)}get topAnchor(){return this.ta}set topAnchor(value){this.ta=Math.max(value,0)}get bottomAnchor(){return this.ba}set bottomAnchor(value){this.ba=Math.max(value,0)}get left(){return this.x_-this.la}get right(){return this.x_+this.ra}get top(){return this.y_+this.ta}set top(value){this.y_+=value-this.ta}get bottom(){return this.y_-this.ba}set bottom(value){this.y_+=value-this.ba}get leftTop(){return new point_Point(this.left,this.top)}get leftBottom(){return new point_Point(this.left,this.bottom)}get rightBottom(){return new point_Point(this.right,this.bottom)}get node(){return this.node_}set node(value){this.node_=value,this.polygonalBoundary_=null}get rightTop(){return new point_Point(this.right,this.top)}static mkAnchor(leftAnchor,rightAnchor,topAnchor,bottomAnchor,node,labelCornersPreserveCoefficient){const a=new Anchor(labelCornersPreserveCoefficient);return a.la=leftAnchor,a.ra=rightAnchor,a.ta=topAnchor,a.ba=bottomAnchor,a.node=node,a}get x(){return this.x_}set x(value){this.polygonalBoundary_=null,this.x_=value}get y(){return this.y_}set y(value){this.polygonalBoundary_=null,this.y_=value}get origin(){return new point_Point(this.x,this.y)}get width(){return this.la+this.ra}get height(){return this.ta+this.ba}get hasLabel(){return this.labelIsToTheLeftOfTheSpline||this.labelIsToTheLeftOfTheSpline}get LabelWidth(){if(this.labelIsToTheLeftOfTheSpline)return this.leftAnchor;if(this.labelIsToTheRightOfTheSpline)return this.rightAnchor;throw new Error}get polygonalBoundary(){return null!=this.polygonalBoundary_?this.polygonalBoundary_:this.polygonalBoundary_=Anchor.pad(this.creatPolygonalBoundaryWithoutPadding(),this.padding)}static pad(curve,padding){return 0==padding?curve:Anchor.curveIsConvex(curve)?Anchor.padConvexCurve(curve,padding):Anchor.padConvexCurve(curve.boundingBox.perimeter(),padding)}static padCorner(poly,p0,p1,p2,padding){const cornerInfo=Anchor.getPaddedCorner(p0,p1,p2,padding);poly.addPoint(cornerInfo.a),2==cornerInfo.numberOfPoints&&poly.addPoint(cornerInfo.b)}static padConvexCurve(poly,padding){const ret=new Polyline;Anchor.padCorner(ret,poly.endPoint.prev,poly.endPoint,poly.startPoint,padding),Anchor.padCorner(ret,poly.endPoint,poly.startPoint,poly.startPoint.next,padding);for(let pp=poly.startPoint;null!=pp.next.next;pp=pp.next)Anchor.padCorner(ret,pp,pp.next,pp.next.next,padding);return ret.closed=!0,ret}static getPaddedCorner(first,second,third,padding){const u=first.point,v=second.point,w=third.point,ccw=point_Point.getTriangleOrientation(u,v,w)==point_TriangleOrientation.Counterclockwise,uv=v.sub(u),uvPerp=uv.rotate((ccw?-Math.PI:Math.PI)/2).normalize(),l=uv.normalize().add(v.sub(w).normalize());if(l.length<GeomConstants.intersectionEpsilon)return{a:v.add(uvPerp.mul(padding)),b:null,numberOfPoints:1};const d=l.normalize().mul(padding),dp=d.rotate(Math.PI/2),xp=(padding-d.dot(uvPerp))/dp.dot(uvPerp);return{a:d.add(dp.mul(xp)).add(v),b:d.sub(dp.mul(xp)).add(v),numberOfPoints:2}}static*orientations(poly){yield point_Point.getTriangleOrientation(poly.endPoint.point,poly.startPoint.point,poly.startPoint.next.point),yield point_Point.getTriangleOrientation(poly.endPoint.prev.point,poly.endPoint.point,poly.startPoint.point);let pp=poly.startPoint;for(;null!=pp.next.next;)yield point_Point.getTriangleOrientation(pp.point,pp.next.point,pp.next.next.point),pp=pp.next}static curveIsConvex(poly){let orientation=point_TriangleOrientation.Collinear;for(const or of Anchor.orientations(poly))if(or!=point_TriangleOrientation.Collinear)if(orientation==point_TriangleOrientation.Collinear)orientation=or;else if(or!=orientation)return!1;return!0}creatPolygonalBoundaryWithoutPadding(){return this.hasLabel?this.labelIsToTheLeftOfTheSpline?this.polygonOnLeftLabel():this.polygonOnRightLabel():null==this.nodeBoundary?this.standardRectBoundary():Curve.polylineAroundClosedCurve(this.nodeBoundary)}get nodeBoundary(){return null==this.node?null:this.node.boundaryCurve}standardRectBoundary(){const poly=new Polyline;return poly.addPoint(this.leftTop),poly.addPoint(this.rightTop),poly.addPoint(this.rightBottom),poly.addPoint(this.leftBottom),poly.closed=!0,poly}polygonOnLeftLabel(){const t=this.left+(1-this.labelCornersPreserveCoefficient)*this.LabelWidth;return Polyline.mkClosedFromPoints([new point_Point(t,this.top),this.rightTop,this.rightBottom,new point_Point(t,this.bottom),new point_Point(this.left,this.y)])}polygonOnRightLabel(){const t=this.right-(1-this.labelCornersPreserveCoefficient)*this.LabelWidth;return Polyline.mkClosedFromPoints([new point_Point(t,this.top),new point_Point(this.right,this.y),new point_Point(t,this.bottom),this.leftBottom,this.leftTop])}move(p){this.x+=p.x,this.y+=p.y}}class XCoordsWithAlignment{constructor(layerArrays,layeredGraph,nOfOriginalVs,anchorsP,ns){this.xCoords=new Array(4),this.la=layerArrays,this.graph=layeredGraph,this.nOfOriginalVertices=nOfOriginalVs,this.nOfVertices=this.graph.NodeCount,this.markedEdges=new IntPairSet,this.h=this.la.Layers.length,this.root=new Array(this.nOfVertices),this.align=new Array(this.nOfVertices),this.anchors=anchorsP,this.nodeSep=ns}get CurrentEnumRightUp(){return(this.LR?0:1)+2*(this.BT?0:1)}IsVirtual(v){return v>=this.nOfOriginalVertices}Source(edge){return this.BT?edge.Source:edge.Target}Target(edge){return this.BT?edge.Target:edge.Source}static CalculateXCoordinates(layerArrays,layeredGraph,nOfOriginalVs,anchors,nodeSeparation){new XCoordsWithAlignment(layerArrays,layeredGraph,nOfOriginalVs,anchors,nodeSeparation).Calculate()}Calculate(){this.SortInAndOutEdges(),this.RightUpSetup(),this.CalcBiasedAlignment(),this.LeftUpSetup(),this.CalcBiasedAlignment(),this.RightDownSetup(),this.CalcBiasedAlignment(),this.LeftDownSetup(),this.CalcBiasedAlignment(),this.HorizontalBalancing()}SortInAndOutEdges(){this.FillLowMedians(),this.FillUpperMedins()}FillUpperMedins(){this.upperMedians=new Array(this.graph.NodeCount);for(let i=0;i<this.graph.NodeCount;i++)this.FillUpperMediansForNode(i)}CompareByX(a,b){return this.la.x[a]-this.la.x[b]}FillUpperMediansForNode(i){let count=this.graph.InEdgesCount(i);if(count>0){const predecessors=new Array(count);count=0;for(const e of this.graph.InEdges(i))predecessors[count++]=e.Source;predecessors.sort(((a,b)=>this.CompareByX(a,b)));const m=Math.floor(count/2);this.upperMedians[i]=2*m==count?new IntPair(predecessors[m-1],predecessors[m]):predecessors[m]}else this.upperMedians[i]=-1}FillLowMedians(){this.lowMedians=new Array(this.graph.NodeCount);for(let i=0;i<this.graph.NodeCount;i++)this.FillLowMediansForNode(i)}FillLowMediansForNode(i){let count=this.graph.OutEdgesCount(i);if(count>0){const successors=new Array(count);count=0;for(const e of this.graph.OutEdges(i))successors[count++]=e.Target;successors.sort(((a,b)=>this.CompareByX(a,b)));const m=Math.floor(count/2);this.lowMedians[i]=2*m==count?new IntPair(successors[m-1],successors[m]):successors[m]}else this.lowMedians[i]=-1}HorizontalBalancing(){let leastWidthAssignment=-1;const a=new Array(4),b=new Array(4);let leastWidth=Number.MAX_VALUE;for(let i=0;i<4;i++){const t={a:0,b:0};this.AssignmentBounds(i,t),a[i]=t.a,b[i]=t.b;const w=b[i]-a[i];w<leastWidth&&(leastWidthAssignment=i,leastWidth=w)}for(let i=0;i<4;i++){let delta;if(delta=XCoordsWithAlignment.IsLeftMostAssignment(i)?a[leastWidthAssignment]-a[i]:b[leastWidthAssignment]-b[i],this.x=this.xCoords[i],0!=delta)for(let j=0;j<this.nOfVertices;j++)this.x[j]=this.x[j]+delta}const arr=new Array(4);for(let v=0;v<this.nOfVertices;v++)arr[0]=this.xCoords[0][v],arr[1]=this.xCoords[1][v],arr[2]=this.xCoords[2][v],arr[3]=this.xCoords[3][v],arr.sort(((a,b)=>a-b)),this.anchors[v].x=(arr[1]+arr[2])/2}static IsLeftMostAssignment(i){return 0==i||2==i}AssignmentBounds(i,t){if(0==this.nOfVertices)t.a=0,t.b=0;else{this.x=this.xCoords[i],t.a=t.b=this.x[0];for(let j=1;j<this.nOfVertices;j++){const r=this.x[j];r<t.a?t.a=r:r>t.b&&(t.b=r)}}}CalcBiasedAlignment(){this.ConflictElimination(),this.Align()}LeftUpSetup(){this.LR=!1,this.BT=!0}LeftDownSetup(){this.LR=!1,this.BT=!1}RightDownSetup(){this.LR=!0,this.BT=!1}RightUpSetup(){this.LR=!0,this.BT=!0}ConflictElimination(){this.RemoveMarksFromEdges(),this.MarkConflictingEdges()}*UpperEdgeMedians(target){const medians=this.BT?this.upperMedians[target]:this.lowMedians[target];if(!("number"==typeof medians)){const ip=medians;this.LR?(yield ip.x,yield ip.y):(yield ip.y,yield ip.x)}else{const i=medians;i>=0&&(yield i)}}MarkConflictingEdges(){let i=this.LowerOf(0,this.h-1);const lowest=i,upperBound=this.UpperOf(0,this.h-1),nextBelowUpperBound=this.NextLower(upperBound);for(;this.IsBelow(i,upperBound);i=this.NextUpper(i))this.IsBelow(lowest,i)&&this.IsBelow(i,nextBelowUpperBound)&&this.ConflictsWithAtLeastOneInnerEdgeForALayer(i)}NextUpper(i){return this.BT?i+1:i-1}NextLower(i){return this.BT?i-1:i+1}UpperOf(i,j){return this.BT?Math.max(i,j):Math.min(i,j)}LowerOf(i,j){return this.BT?Math.min(i,j):Math.max(i,j)}IsBelow(i,j){return this.BT?i<j:j<i}LeftMost(pos0,pos1){return this.LR?Math.min(pos0,pos1):Math.max(pos0,pos1)}RightMost(pos0,pos1){return this.LR?Math.max(pos0,pos1):Math.min(pos0,pos1)}IsNotRightFrom(i,pos){return this.LR?i<=pos:pos<=i}IsLeftFrom(i,j){return this.LR?i<j:j<i}NextRight(i){return this.LR?i+1:i-1}NextLeft(i){return this.LR?i-1:i+1}ConflictsWithAtLeastOneInnerEdgeForALayer(layerIndex){if(layerIndex>=0&&layerIndex<this.la.Layers.length){const lowerLayer=this.la.Layers[layerIndex];let innerEdge=null,targetPos=this.LeftMost(0,lowerLayer.length-1);const lastTargetPos=this.RightMost(0,lowerLayer.length-1);for(;this.IsNotRightFrom(targetPos,lastTargetPos)&&null==innerEdge;targetPos=this.NextRight(targetPos))innerEdge=this.InnerEdgeByTarget(lowerLayer[targetPos]);if(null!=innerEdge){const positionOfInnerEdgeSource=this.Pos(this.Source(innerEdge));for(let j=this.LeftMost(0,lowerLayer.length-1);this.IsLeftFrom(j,targetPos);j=this.NextRight(j))for(const ie of this.InEdges(lowerLayer[j]))this.IsLeftFrom(positionOfInnerEdgeSource,this.Pos(this.Source(ie)))&&this.MarkEdge(ie);let innerSourcePos=this.Pos(this.Source(innerEdge));for(;this.IsNotRightFrom(targetPos,lastTargetPos);){const newInnerEdge=this.AlignmentToTheRightOfInner(lowerLayer,targetPos,positionOfInnerEdgeSource);if(targetPos=this.NextRight(targetPos),null!=newInnerEdge){const newInnerSourcePos=this.Pos(this.Source(newInnerEdge));this.MarkEdgesBetweenInnerAndNewInnerEdges(lowerLayer,innerEdge,newInnerEdge,innerSourcePos,newInnerSourcePos),innerEdge=newInnerEdge,innerSourcePos=newInnerSourcePos}}for(let k=this.NextRight(this.Pos(this.Target(innerEdge)));this.IsNotRightFrom(k,lastTargetPos);k=this.NextRight(k))for(const ie of this.InEdges(lowerLayer[k]))this.IsLeftFrom(this.Pos(this.Source(ie)),this.Pos(this.Source(innerEdge)))&&this.MarkEdge(ie)}}}InEdgeOfVirtualNode(v){return this.BT?this.graph.InEdgeOfVirtualNode(v):this.graph.OutEdgeOfVirtualNode(v)}InEdges(v){return this.BT?this.graph.InEdges(v):this.graph.OutEdges(v)}MarkEdgesBetweenInnerAndNewInnerEdges(lowerLayer,innerEdge,newInnerEdge,innerEdgeSourcePos,newInnerEdgeSourcePos){let u=this.NextRight(this.Pos(this.Target(innerEdge)));for(;this.IsLeftFrom(u,this.Pos(this.Target(newInnerEdge)));u=this.NextRight(u))for(const ie of this.InEdges(lowerLayer[u])){const ieSourcePos=this.Pos(this.Source(ie));(this.IsLeftFrom(ieSourcePos,innerEdgeSourcePos)||this.IsLeftFrom(newInnerEdgeSourcePos,ieSourcePos))&&this.MarkEdge(ie)}}AlignmentToTheRightOfInner(lowLayer,i,posInnerSource){if(1==this.NumberOfInEdges(lowLayer[i])){let ie=null;for(const e of this.InEdges(lowLayer[i]))ie=e;return this.IsInnerEdge(ie)&&this.IsLeftFrom(posInnerSource,this.Pos(ie.Source))?ie:null}return null}NumberOfInEdges(v){return this.BT?this.graph.InEdgesCount(v):this.graph.OutEdgesCount(v)}Pos(v){return this.la.x[v]}InnerEdgeByTarget(v){if(this.IsVirtual(v)){const ie=this.InEdgeOfVirtualNode(v);if(this.IsVirtual(this.Source(ie)))return ie}return null}IsInnerEdge(e){return this.IsVirtual(e.Source)&&this.IsVirtual(e.Target)}RemoveMarksFromEdges(){this.markedEdges.clear()}Align(){this.CreateBlocks(),this.AssignCoordinatesByLongestPath()}AssignCoordinatesByLongestPath(){this.x=this.xCoords[this.CurrentEnumRightUp]=new Array(this.nOfVertices);const edges=new Array;for(let v=0;v<this.nOfVertices;v++)if(v==this.root[v]){let w=v;do{const rn={neighbor:0};this.TryToGetRightNeighbor(w,rn)&&edges.push(new PolyIntEdge(v,this.root[rn.neighbor],null)),w=this.align[w]}while(w!=v)}const blockGraph=mkGraphOnEdgesN(edges,this.nOfVertices),topoSort=TopologicalSort.getOrderOnGraph(blockGraph);for(const v of topoSort)if(v==this.root[v]){let vx=0,vIsLeftMost=!0,w=v;do{const wLn={neighbor:0};this.TryToGetLeftNeighbor(w,wLn)&&(vIsLeftMost?(vx=this.x[this.root[wLn.neighbor]]+this.DeltaBetweenVertices(wLn.neighbor,w),vIsLeftMost=!1):vx=this.RightMost(vx,this.x[this.root[wLn.neighbor]]+this.DeltaBetweenVertices(wLn.neighbor,w))),w=this.align[w]}while(w!=v);this.x[v]=vx}for(const v of topoSort)if(v==this.root[v]&&0==blockGraph.inEdges[v].length){let w=v,xLeftMost=this.RightMost(-XCoordsWithAlignment.infinity,XCoordsWithAlignment.infinity);const xl=xLeftMost;do{const wRn={neighbor:0};this.TryToGetRightNeighbor(w,wRn)&&(xLeftMost=this.LeftMost(xLeftMost,this.x[this.root[wRn.neighbor]]-this.DeltaBetweenVertices(w,wRn.neighbor))),w=this.align[w]}while(w!=v);xl!=xLeftMost&&(this.x[v]=xLeftMost)}for(let v=0;v<this.nOfVertices;v++)v!=this.root[v]&&(this.x[v]=this.x[this.root[v]])}TryToGetRightNeighbor(u,t){const neighborPos=this.NextRight(this.Pos(u)),layer=this.la.Layers[this.la.y[u]];return neighborPos>=0&&neighborPos<layer.length&&(t.neighbor=layer[neighborPos],!0)}TryToGetLeftNeighbor(u,t){const neighborPos=this.NextLeft(this.Pos(u)),layer=this.la.Layers[this.la.y[u]];return neighborPos>=0&&neighborPos<layer.length&&(t.neighbor=layer[neighborPos],!0)}CreateBlocks(){for(let v=0;v<this.nOfVertices;v++)this.root[v]=this.align[v]=v;const lowBound=this.LowerOf(0,this.h-1);for(let i=this.NextLower(this.UpperOf(0,this.h-1));!this.IsBelow(i,lowBound);i=this.NextLower(i)){const layer=this.la.Layers[i];let r=this.LeftMost(-1,this.la.Layers[this.NextUpper(i)].length);const rightBound=this.RightMost(0,layer.length-1);for(let k=this.LeftMost(0,layer.length-1);this.IsNotRightFrom(k,rightBound);k=this.NextRight(k)){const vk=layer[k];for(const upperNeighborOfVk of this.UpperEdgeMedians(vk))if(!this.IsMarked(vk,upperNeighborOfVk)&&this.IsLeftFrom(r,this.Pos(upperNeighborOfVk))){this.align[upperNeighborOfVk]=vk,this.root[vk]=this.root[upperNeighborOfVk],this.align[vk]=this.root[upperNeighborOfVk],r=this.Pos(upperNeighborOfVk);break}}}}IsMarked(source,target){return this.BT?this.markedEdges.hasxy(target,source):this.markedEdges.hasxy(source,target)}MarkEdge(ie){this.markedEdges.addNN(ie.Source,ie.Target)}DeltaBetweenVertices(u,v){let sign;if(this.Pos(u)>this.Pos(v)){const t=u;u=v,v=t,sign=-1}else sign=1;return(this.anchors[u].rightAnchor+this.anchors[v].leftAnchor+this.nodeSep)*sign}}XCoordsWithAlignment.infinity=1e7;class XLayoutGraph extends BasicGraphOnEdges{constructor(graph,layeredGraph,layerArrays,edges,nov){super(),this.weightMultiplierOfOriginalOriginal=1,this.weightMultOfOneVirtual=3,this.weightMultiplierOfTwoVirtual=8,this.SetEdges(edges,nov),this.virtualVerticesStart=graph.nodeCount,this.virtualVerticesEnd=layeredGraph.NodeCount-1,this.layeredGraph=layeredGraph,this.layerArrays=layerArrays}EdgeWeightMultiplier(edge){const s=edge.source,t=edge.target;if(s<this.layeredGraph.NodeCount&&this.layerArrays.y[s]==this.layerArrays.y[t]&&this.layerArrays.x[s]==this.layerArrays.x[t]+1)return 0;let k=0,t0=-1,s0=-1;for(const intEdge of this.outEdges[s])-1==s0?s0=intEdge.target:t0=intEdge.target;s0>=this.virtualVerticesStart&&s0<=this.virtualVerticesEnd&&k++,t0>=this.virtualVerticesStart&&t0<=this.virtualVerticesEnd&&k++;return 0==k?this.weightMultiplierOfOriginalOriginal:1==k?this.weightMultOfOneVirtual:this.weightMultiplierOfTwoVirtual}SetEdgeWeights(){for(const intEdge of this.edges)intEdge.weight=intEdge.weight*this.EdgeWeightMultiplier(intEdge)}}var NodeKind,HitTestBehavior,RBColor,Behavior,VisibilityKind,SolverAlgorithm,BundlingStatus,esm_a;!function(NodeKind){NodeKind[NodeKind.Top=0]="Top",NodeKind[NodeKind.Internal=1]="Internal",NodeKind[NodeKind.Bottom=2]="Bottom"}(NodeKind||(NodeKind={}));class HierarchyCalculator{constructor(nodes,groupSplitThresholdPar){this.groupSplitThreshold=2,this.initialNodes=nodes,this.groupSplitThreshold=groupSplitThresholdPar}static Calculate(nodes,groupSplitThresholdPar=0){return new HierarchyCalculator(nodes,groupSplitThresholdPar).Calculate()}Calculate(){return this.Calc(this.initialNodes)}Calc(nodes){if(0==nodes.length)return null;if(1==nodes.length)return nodes[0];const b0=nodes[0].parallelogram;let seed1,seed0=1,area=Parallelogram.parallelogramOfTwo(b0,nodes[seed0].parallelogram).area;for(let i=2;i<nodes.length;i++){const area0=Parallelogram.parallelogramOfTwo(b0,nodes[i].parallelogram).area;area0>area&&(seed0=i,area=area0)}for(let i=0;i<nodes.length;i++)if(i!=seed0){seed1=i;break}area=Parallelogram.parallelogramOfTwo(nodes[seed0].parallelogram,nodes[seed1].parallelogram).area;for(let i=0;i<nodes.length;i++){if(i==seed0)continue;const area1=Parallelogram.parallelogramOfTwo(nodes[seed0].parallelogram,nodes[i].parallelogram).area;area1>area&&(seed1=i,area=area1)}const gr0=new Array,gr1=new Array;gr0.push(nodes[seed0]),gr1.push(nodes[seed1]);let box0=nodes[seed0].parallelogram,box1=nodes[seed1].parallelogram;for(let i=0;i<nodes.length;i++){if(i==seed0||i==seed1)continue;const box0_=Parallelogram.parallelogramOfTwo(box0,nodes[i].parallelogram),delta0=box0_.area-box0.area,box1_=Parallelogram.parallelogramOfTwo(box1,nodes[i].parallelogram),delta1=box1_.area-box1.area;gr0.length*this.groupSplitThreshold<gr1.length?(gr0.push(nodes[i]),box0=box0_):gr1.length*this.groupSplitThreshold<gr0.length?(gr1.push(nodes[i]),box1=box1_):delta0<delta1?(gr0.push(nodes[i]),box0=box0_):(gr1.push(nodes[i]),box1=box1_)}return{parallelogram:Parallelogram.parallelogramOfTwo(box0,box1),node:{children:[this.Calc(gr0),this.Calc(gr1)]},seg:void 0,leafBoxesOffset:void 0}}}class debugCurve_DebugCurve{static mkDebugCurveTWCILD(transparency,width,color,curve,label,dashArray,drawPN=!1){const r=new debugCurve_DebugCurve;return r.transparency=transparency,r.width=width,r.color=color,r.icurve=curve,r.label=label,r.dashArray=dashArray,r.drawPN=drawPN,r}static mkDebugCurveTWCI(transparency,width,color,curve){return debugCurve_DebugCurve.mkDebugCurveTWCILD(transparency,width,color,curve,null,null)}static mkDebugCurveWCI(width,color,curve){return debugCurve_DebugCurve.mkDebugCurveTWCI(255,width,color,curve)}static mkDebugCurveCI(color,curve){return debugCurve_DebugCurve.mkDebugCurveWCI(1,color,curve)}static mkDebugCurveI(curve){return debugCurve_DebugCurve.mkDebugCurveCI("Black",curve)}}debugCurve_DebugCurve.colors=["DeepSkyBlue","IndianRed","Orange","Gold","DarkRed","Plum","Red","Violet","Indigo","Yellow","OrangeRed","Tomato","Purple","SaddleBrown","Green","Navy","Aqua","Pink","Bisque","Black","BlanchedAlmond","Blue","BlueViolet","Brown","Lime","BurlyWood","Chocolate","Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","CadetBlue","Chartreuse","DarkBlue","DarkCyan","DarkGoldenrod","DarkGray","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","DarkOrange","DarkOrchid","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray","DarkTurquoise","DarkViolet","DeepPink","DimGray","DodgerBlue","Firebrick","FloralWhite","ForestGreen","Fuchsia","CodeAnalysis","Gainsboro","GhostWhite","Goldenrod","Gray","GreenYellow","Honeydew","HotPink","Ivory","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral","LightCyan","LightGoldenrodYellow","LightGray","LightGreen","LightPink","LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSteelBlue","LightYellow","LimeGreen","Linen","Magenta","Maroon","MediumAquamarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen","MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue","MintCream","MistyRose","Moccasin","NavajoWhite","OldLace","Olive","OliveDrab","Orchid","PaleGoldenrod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip","PeachPuff","Peru","PowderBlue","RosyBrown","RoyalBlue","Salmon","SandyBrown","SeaGreen","CodeAnalysis","SeaShell","Sienna","Silver","SkyBlue","SlateBlue","SlateGray","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle","Transparent","Turquoise","Aquamarine","Azure","Beige","Wheat","White","WhiteSmoke","YellowGreen","Khaki","AntiqueWhite"];class RefinerBetweenTwoLayers{constructor(topNodeP,bottomNodeP,topSiteP,layerArraysP,layeredGraphP,originalGraphP,anchorsP,layerSeparation){this.topNode=topNodeP,this.bottomNode=bottomNodeP,this.topSite=topSiteP,this.bottomSite=topSiteP.next,this.currentTopSite=topSiteP,this.currentBottomSite=topSiteP.next,this.layerArrays=layerArraysP,this.layeredGraph=layeredGraphP,this.originalGraph=originalGraphP,this.anchors=anchorsP,this.layerSeparation=layerSeparation}static Refine(topNodeP,bottomNode,topSiteP,anchors,layerArraysP,layeredGraph,originalGraph,layerSeparation){new RefinerBetweenTwoLayers(topNodeP,bottomNode,topSiteP,layerArraysP,layeredGraph,originalGraph,anchors,layerSeparation).Refine()}Refine(){for(this.Init();this.InsertSites(););}FixCorner(start,corner,end){if(start.equal(corner))return corner;const a=point_Point.ClosestPointAtLineSegment(corner,start,end);let offsetInTheChannel=corner.sub(a);const y=Math.abs(offsetInTheChannel.y),sep=this.layerSeparation/2;return y>sep&&(offsetInTheChannel=offsetInTheChannel.mul(sep/(2*y))),offsetInTheChannel.add(corner)}InsertSites(){return 0==randomInt(2)?this.CalculateNewTopSite()||this.CalculateNewBottomSite():this.CalculateNewBottomSite()||this.CalculateNewTopSite()}CalculateNewBottomSite(){const mainSeg=this.currentBottomSite.point.sub(this.currentTopSite.point);let vOfNewSite,cotan=RefinerBetweenTwoLayers.absCotan(mainSeg),someBottomCorners=!1;for(const p of this.bottomCorners()){const cornerCotan=RefinerBetweenTwoLayers.absCotan(p.sub(this.currentBottomSite.point));cornerCotan<cotan&&(cotan=cornerCotan,vOfNewSite=p,someBottomCorners=!0)}return!!someBottomCorners&&(!closeDistEps(cotan,RefinerBetweenTwoLayers.absCotan(mainSeg))&&(this.currentBottomSite=CornerSite.mkSiteSPS(this.currentTopSite,this.FixCorner(this.currentTopSite.point,vOfNewSite,this.currentBottomSite.point),this.currentBottomSite),!0))}static absCotan(mainSeg){return Math.abs(mainSeg.x/mainSeg.y)}CalculateNewTopSite(){const mainSeg=this.currentBottomSite.point.sub(this.currentTopSite.point);let vOfNewSite,cotan=RefinerBetweenTwoLayers.absCotan(mainSeg),someTopCorners=!1;for(const p of this.topCorners()){const cornerCotan=RefinerBetweenTwoLayers.absCotan(p.sub(this.currentTopSite.point));cornerCotan<cotan&&(cotan=cornerCotan,vOfNewSite=p,someTopCorners=!0)}return!!someTopCorners&&(!closeDistEps(cotan,RefinerBetweenTwoLayers.absCotan(mainSeg))&&(this.currentTopSite=CornerSite.mkSiteSPS(this.currentTopSite,this.FixCorner(this.currentTopSite.point,vOfNewSite,this.currentBottomSite.point),this.currentBottomSite),!0))}Init(){this.IsTopToTheLeftOfBottom()?(this.topCorners=()=>this.CornersToTheRightOfTop(),this.bottomCorners=()=>this.CornersToTheLeftOfBottom()):(this.topCorners=()=>this.CornersToTheLeftOfTop(),this.bottomCorners=()=>this.CornersToTheRightOfBottom())}IsTopToTheLeftOfBottom(){return this.topSite.point.x<this.topSite.next.point.x}*NodeCorners(node){for(const p of this.anchors[node].polygonalBoundary.polylinePoints())yield p.point}*CornersToTheLeftOfBottom(){const bottomPosition=this.layerArrays.x[this.bottomNode],leftMost=this.currentTopSite.point.x,rightMost=this.currentBottomSite.point.x;for(const node of this.LeftFromTheNode(this.NodeLayer(this.bottomNode),bottomPosition,NodeKind.Bottom,leftMost,rightMost))for(const p of this.NodeCorners(node))p.y>this.currentBottomSite.point.y&&RefinerBetweenTwoLayers.PossibleCorner(leftMost,rightMost,p)&&(yield p)}*CornersToTheLeftOfTop(){const topPosition=this.layerArrays.x[this.topNode],leftMost=this.currentBottomSite.point.x,rightMost=this.currentTopSite.point.x;for(const node of this.LeftFromTheNode(this.NodeLayer(this.topNode),topPosition,NodeKind.Top,leftMost,rightMost))for(const p of this.NodeCorners(node))p.y<this.currentTopSite.point.y&&RefinerBetweenTwoLayers.PossibleCorner(leftMost,rightMost,p)&&(yield p)}*CornersToTheRightOfBottom(){const bottomPosition=this.layerArrays.x[this.bottomNode],leftMost=this.currentBottomSite.point.x,rightMost=this.currentTopSite.point.x;for(const node of this.RightFromTheNode(this.NodeLayer(this.bottomNode),bottomPosition,NodeKind.Bottom,leftMost,rightMost))for(const p of this.NodeCorners(node))p.y>this.currentBottomSite.point.y&&RefinerBetweenTwoLayers.PossibleCorner(leftMost,rightMost,p)&&(yield p)}*CornersToTheRightOfTop(){const topPosition=this.layerArrays.x[this.topNode],leftMost=this.currentTopSite.point.x,rightMost=this.currentBottomSite.point.x;for(const node of this.RightFromTheNode(this.NodeLayer(this.topNode),topPosition,NodeKind.Top,leftMost,rightMost))for(const p of this.NodeCorners(node))p.y<this.currentTopSite.point.y&&RefinerBetweenTwoLayers.PossibleCorner(leftMost,rightMost,p)&&(yield p)}static PossibleCorner(leftMost,rightMost,p){return p.x>leftMost&&p.x<rightMost}NodeLayer(j){return this.layerArrays.Layers[this.layerArrays.y[j]]}IsLabel(u){return this.anchors[u].hasLabel}NodeUCanBeCrossedByNodeV(u,v){return!this.IsLabel(u)&&!this.IsLabel(v)&&!!(this.IsVirtualVertex(u)&&this.IsVirtualVertex(v)&&this.AdjacentEdgesIntersect(u,v))}AdjacentEdgesIntersect(u,v){return this.Intersect(this.IncomingEdge(u),this.IncomingEdge(v))||this.Intersect(this.OutcomingEdge(u),this.OutcomingEdge(v))}Intersect(e,m){return(this.layerArrays.x[e.Source]-this.layerArrays.x[m.Source])*(this.layerArrays.x[e.Target]-this.layerArrays.x[m.Target])<0}IncomingEdge(u){for(const le of this.layeredGraph.InEdges(u))return le;throw new Error}OutcomingEdge(u){for(const le of this.layeredGraph.OutEdges(u))return le;throw new Error}IsVirtualVertex(v){return v>=this.originalGraph.shallowNodeCount}*RightFromTheNode(layer,vPosition,nodeKind,leftMostX,rightMostX){let b=0,t=0;nodeKind==NodeKind.Bottom&&(b=Number.MAX_VALUE),nodeKind==NodeKind.Top&&(t=Number.MAX_VALUE);const v=layer[vPosition];for(let i=vPosition+1;i<layer.length;i++){const u=layer[i];if(this.NodeUCanBeCrossedByNodeV(u,v))continue;const anchor=this.anchors[u];if(anchor.left>=rightMostX)break;anchor.right>leftMostX&&(anchor.topAnchor>t+GeomConstants.distanceEpsilon?(t=anchor.topAnchor,yield u):anchor.bottomAnchor>b+GeomConstants.distanceEpsilon&&(b=anchor.bottomAnchor,yield u))}}*LeftFromTheNode(layer,vPosition,nodeKind,leftMostX,rightMostX){let b=0,t=0;nodeKind==NodeKind.Bottom&&(b=Number.MAX_VALUE),nodeKind==NodeKind.Top&&(t=Number.MAX_VALUE);const v=layer[vPosition];for(let i=vPosition-1;i>-1;i--){const u=layer[i];if(this.NodeUCanBeCrossedByNodeV(u,v))continue;const anchor=this.anchors[u];if(anchor.right<=leftMostX)break;anchor.left<rightMostX&&(anchor.topAnchor>t+GeomConstants.distanceEpsilon?(t=anchor.topAnchor,yield u):anchor.bottomAnchor>b+GeomConstants.distanceEpsilon&&(b=anchor.bottomAnchor,yield u))}}}class SmoothedPolylineCalculator{constructor(edgePathPar,anchorsP,origGraph,settings,la,layerGraph,databaseP){this.thinRightNodes=new Array,this.thinWestNodes=new Array,this.database=databaseP,this.edgePath=edgePathPar,this.anchors=anchorsP,this.layerArrays=la,this.originalGraph=origGraph,this.settings=settings,this.layeredGraph=layerGraph,this.eastHierarchy=this.BuildEastHierarchy(),this.westHierarchy=this.BuildWestHierarchy()}BuildEastHierarchy(){const boundaryAnchorsCurves=this.FindEastBoundaryAnchorCurves(),l=new Array;for(const c of boundaryAnchorsCurves)l.push(c.pNodeOverICurve());return this.thinEastHierarchy=HierarchyCalculator.Calculate(this.thinRightNodes),HierarchyCalculator.Calculate(l)}BuildWestHierarchy(){const boundaryAnchorCurves=this.FindWestBoundaryAnchorCurves(),l=new Array;for(const a of boundaryAnchorCurves)l.push(a.pNodeOverICurve());return this.thinWestHierarchy=HierarchyCalculator.Calculate(this.thinWestNodes),HierarchyCalculator.Calculate(l)}FindEastBoundaryAnchorCurves(){const ret=new Array;let uOffset=0;for(const u of this.edgePath){let westMostAnchor=null;for(const v of this.EastBoundaryNodesOfANode(u,routing_Routing.GetNodeKind(uOffset,this.edgePath))){const a=this.anchors[v];(null==westMostAnchor||westMostAnchor.origin.x>a.origin.x)&&(westMostAnchor=a),ret.push(a.polygonalBoundary)}null!=westMostAnchor&&this.thinRightNodes.push(LineSegment.mkLinePXY(westMostAnchor.origin,this.originalGraph.right,westMostAnchor.y).pNodeOverICurve()),uOffset++}return ret}FindWestBoundaryAnchorCurves(){const ret=[];let uOffset=0;for(const u of this.edgePath.nodes()){let eastMost=-1;for(const v of this.LeftBoundaryNodesOfANode(u,routing_Routing.GetNodeKind(uOffset,this.edgePath)))(-1==eastMost||this.layerArrays.x[v]>this.layerArrays.x[eastMost])&&(eastMost=v),ret.push(this.anchors[v].polygonalBoundary);if(-1!=eastMost){const a=this.anchors[eastMost];this.thinWestNodes.push(LineSegment.mkLinePXY(a.origin,this.originalGraph.left,a.origin.y).pNodeOverICurve())}uOffset++}return ret}*FillRightTopAndBottomVerts(layer,vPosition,nodeKind){let b=0,t=0;nodeKind==NodeKind.Bottom?b=Number.MAX_VALUE:nodeKind==NodeKind.Top&&(t=Number.MAX_VALUE);const v=layer[vPosition];for(let i=vPosition+1;i<layer.length;i++){const u=layer[i],anchor=this.anchors[u];anchor.topAnchor>t?this.NodeUCanBeCrossedByNodeV(u,v)||(t=anchor.topAnchor,anchor.bottomAnchor>b&&(b=anchor.bottomAnchor),yield u):anchor.bottomAnchor>b&&(this.NodeUCanBeCrossedByNodeV(u,v)||(b=anchor.bottomAnchor,anchor.topAnchor>t&&(t=anchor.topAnchor),yield u))}}*FillLeftTopAndBottomVerts(layer,vPosition,nodeKind){let b=0,t=0;nodeKind==NodeKind.Top?t=Number.MAX_VALUE:nodeKind==NodeKind.Bottom&&(b=Number.MAX_VALUE);const v=layer[vPosition];for(let i=vPosition-1;i>=0;i--){const u=layer[i],anchor=this.anchors[u];anchor.topAnchor>t+GeomConstants.distanceEpsilon?this.NodeUCanBeCrossedByNodeV(u,v)||(t=anchor.topAnchor,b=Math.max(b,anchor.bottomAnchor),yield u):anchor.bottomAnchor>b+GeomConstants.distanceEpsilon&&(this.NodeUCanBeCrossedByNodeV(u,v)||(t=Math.max(t,anchor.topAnchor),b=anchor.bottomAnchor,yield u))}}IsVirtualVertex(v){return v>=this.originalGraph.shallowNodeCount}IsLabel(u){return this.anchors[u].hasLabel}NodeUCanBeCrossedByNodeV(u,v){return!this.IsLabel(u)&&(!this.IsLabel(v)&&!!(this.IsVirtualVertex(u)&&this.IsVirtualVertex(v)&&this.EdgesIntersectSomewhere(u,v)))}EdgesIntersectSomewhere(u,v){return!this.UVAreMiddlesOfTheSameMultiEdge(u,v)&&(this.IntersectAbove(u,v)||this.IntersectBelow(u,v))}UVAreMiddlesOfTheSameMultiEdge(u,v){return!(!this.database.MultipleMiddles.has(u)||!this.database.MultipleMiddles.has(v)||this.SourceOfTheOriginalEdgeContainingAVirtualNode(u)!=this.SourceOfTheOriginalEdgeContainingAVirtualNode(v))}SourceOfTheOriginalEdgeContainingAVirtualNode(u){for(;this.IsVirtualVertex(u);)u=this.IncomingEdge(u).Source;return u}IntersectBelow(u,v){do{const eu=this.OutcomingEdge(u),ev=this.OutcomingEdge(v);if(this.Intersect(eu,ev))return!0;u=eu.Target,v=ev.Target}while(this.IsVirtualVertex(u)&&this.IsVirtualVertex(v));return u==v}IntersectAbove(u,v){do{const eu=this.IncomingEdge(u),ev=this.IncomingEdge(v);if(this.Intersect(eu,ev))return!0;u=eu.Source,v=ev.Source}while(this.IsVirtualVertex(u)&&this.IsVirtualVertex(v));return u==v}Intersect(e,m){const a=this.layerArrays.x[e.Source]-this.layerArrays.x[m.Source],b=this.layerArrays.x[e.Target]-this.layerArrays.x[m.Target];return a>0&&b<0||a<0&&b>0}IncomingEdge(u){return this.layeredGraph.InEdgeOfVirtualNode(u)}OutcomingEdge(u){return this.layeredGraph.OutEdgeOfVirtualNode(u)}EastBoundaryNodesOfANode(i,nodeKind){return this.FillRightTopAndBottomVerts(this.NodeLayer(i),this.layerArrays.x[i],nodeKind)}NodeLayer(i){return this.layerArrays.Layers[this.layerArrays.y[i]]}LeftBoundaryNodesOfANode(i,nodeKind){return this.FillLeftTopAndBottomVerts(this.NodeLayer(i),this.layerArrays.x[i],nodeKind)}getSpline(optimizeShortEdges){return this.createRefinedPolyline(optimizeShortEdges),this.createSmoothedPolyline()}get GetPolyline(){return new SmoothedPolyline(this.headSite)}LineSegIntersectBound(a,b){const l=LineSegment.mkPP(a,b);return SmoothedPolylineCalculator.CurveIntersectsHierarchy(l,this.westHierarchy)||SmoothedPolylineCalculator.CurveIntersectsHierarchy(l,this.thinWestHierarchy)||SmoothedPolylineCalculator.CurveIntersectsHierarchy(l,this.eastHierarchy)||SmoothedPolylineCalculator.CurveIntersectsHierarchy(l,this.thinEastHierarchy)}SegIntersectWestBound(a,b){return SmoothedPolylineCalculator.SegIntersectsBound(a,b,this.westHierarchy)||SmoothedPolylineCalculator.SegIntersectsBound(a,b,this.thinWestHierarchy)}SegIntersectEastBound(a,b){return SmoothedPolylineCalculator.SegIntersectsBound(a,b,this.eastHierarchy)||SmoothedPolylineCalculator.SegIntersectsBound(a,b,this.thinEastHierarchy)}TryToRemoveInflectionCorner(t){if(!t.s.next||!t.s.prev||t.s.turn==point_TriangleOrientation.Counterclockwise&&this.SegIntersectEastBound(t.s.prev,t.s.next)||t.s.turn==point_TriangleOrientation.Clockwise&&this.SegIntersectWestBound(t.s.prev,t.s.next))return t.cut=!1,void(t.s=t.s.next);const nextS=t.s.next;t.s.prev.next=nextS,nextS.prev=t.s.prev,t.s=nextS,t.cut=!0}static SegIntersectsBound(a,b,hierarchy){return SmoothedPolylineCalculator.CurveIntersectsHierarchy(LineSegment.mkPP(a.point,b.point),hierarchy)}static CurveIntersectsHierarchy(lineSeg,hierarchy){if(null==hierarchy)return!1;if(!Parallelogram.intersect(lineSeg.pNodeOverICurve().parallelogram,hierarchy.parallelogram))return!1;if(hierarchy.node.hasOwnProperty("children")){const n=hierarchy.node;return SmoothedPolylineCalculator.CurveIntersectsHierarchy(lineSeg,n.children[0])||SmoothedPolylineCalculator.CurveIntersectsHierarchy(lineSeg,n.children[1])}return null!=Curve.intersectionOne(lineSeg,hierarchy.seg,!1)}static Flat(i){return point_Point.getTriangleOrientation(i.prev.point,i.point,i.next.point)==point_TriangleOrientation.Collinear}Reverse(){const ret=new SmoothedPolylineCalculator(this.edgePath,this.anchors,this.originalGraph,this.settings,this.layerArrays,this.layeredGraph,this.database);let site=this.headSite,v=null;for(;null!=site;)ret.headSite=site.clone(),ret.headSite.next=v,null!=v&&(v.prev=ret.headSite),v=ret.headSite,site=site.next;return ret}createRefinedPolyline(optimizeShortEdges){this.CreateInitialListOfSites();let bottomSite,topSite=this.headSite;for(let i=0;i<this.edgePath.count;i++)bottomSite=topSite.next,this.RefineBeetweenNeighborLayers(topSite,this.EdgePathNode(i),this.EdgePathNode(i+1)),topSite=bottomSite;this.TryToRemoveInflections(),optimizeShortEdges&&this.OptimizeShortPath()}RefineBeetweenNeighborLayers(topSite,topNode,bottomNode){RefinerBetweenTwoLayers.Refine(topNode,bottomNode,topSite,this.anchors,this.layerArrays,this.layeredGraph,this.originalGraph,this.settings.LayerSeparation)}CreateInitialListOfSites(){let currentSite=this.headSite=CornerSite.mkSiteP(this.EdgePathPoint(0));for(let i=1;i<=this.edgePath.count;i++)currentSite=CornerSite.mkSiteSP(currentSite,this.EdgePathPoint(i))}get TailSite(){let s=this.headSite;for(;null!=s.next;)s=s.next;return s}OptimizeForThreeSites(){const top=this.EdgePathNode(0),bottom=this.EdgePathNode(2),a=this.anchors[top],b=this.anchors[bottom];if(closeDistEps(a.x,b.x))return;const t={ax:a.x,bx:b.x,sign:0};if(!this.FindLegalPositions(a,b,t))return;const ratio=(a.y-b.y)/(a.bottom-b.top),xc=.5*(t.ax+t.bx),half=t.sign*(.5*(t.ax-t.bx));t.ax=xc+ratio*(half*t.sign),t.bx=xc-ratio*(half*t.sign),this.headSite.point=new point_Point(t.ax,a.y);const ms=this.headSite.next,mY=ms.point.y;ms.point=new point_Point(this.MiddlePos(t.ax,t.bx,a,b,mY),mY),ms.next.point=new point_Point(t.bx,b.y);this.anchors[this.EdgePathNode(1)].x=ms.point.x}OptimizeForTwoSites(){const top=this.EdgePathNode(0),bottom=this.EdgePathNode(1),a=this.anchors[top],b=this.anchors[bottom];if(closeDistEps(a.x,b.x))return;const t={ax:a.x,bx:b.x,sign:0};if(!this.FindPositions(a,b,t))return;const ratio=(a.y-b.y)/(a.bottom-b.top),xc=.5*(t.ax+t.bx),half=t.sign*(.5*(t.ax-t.bx));t.ax=xc+ratio*(half*t.sign),t.bx=xc-ratio*(half*t.sign),this.headSite.point=new point_Point(t.ax,a.y),this.headSite.next.point=new point_Point(t.bx,b.y)}FindLegalPositions(a,b,t){return!!this.FindPositions(a,b,t)&&this.PositionsAreLegal(t.ax,t.bx,t.sign,a,b,this.EdgePathNode(1))}FindPositions(a,b,t){let overlapMax,overlapMin;if(t.ax<t.bx?(t.sign=1,overlapMin=Math.max(t.ax,b.left),overlapMax=Math.min(a.right,t.bx)):(t.sign=-1,overlapMin=Math.max(a.left,t.bx),overlapMax=Math.min(b.right,t.ax)),overlapMin<=overlapMax)t.bx=.5*(overlapMin+overlapMax),t.ax=.5*(overlapMin+overlapMax);else{if(this.OriginToOriginSegCrossesAnchorSide(a,b))return!1;1==t.sign?(t.ax=a.right-.1*a.rightAnchor,t.bx=b.left):(t.ax=a.left+.1*a.leftAnchor,t.bx=b.right)}return!0}OriginToOriginSegCrossesAnchorSide(a,b){const seg=LineSegment.mkPP(a.origin,b.origin);return a.x<b.x&&Curve.CurvesIntersect(seg,LineSegment.mkPP(a.rightBottom,a.rightTop))||Curve.CurvesIntersect(seg,LineSegment.mkPP(b.leftBottom,a.leftTop))||a.x>b.x&&Curve.CurvesIntersect(seg,LineSegment.mkPP(a.leftBottom,a.leftTop))||Curve.CurvesIntersect(seg,LineSegment.mkPP(b.rightBottom,a.rightTop))}OptimizeShortPath(){this.edgePath.count>2||(2==this.edgePath.count&&null!=this.headSite.next.next&&null==this.headSite.next.next.next&&null==this.anchors[this.EdgePathNode(1)].node?this.OptimizeForThreeSites():1==this.edgePath.count&&this.OptimizeForTwoSites())}PositionsAreLegal(sax,sbx,sign,a,b,middleNodeIndex){if(!closeDistEps(sax,sbx)&&(sax-sbx)*sign>0)return!1;const mAnchor=this.anchors[middleNodeIndex],mx=this.MiddlePos(sax,sbx,a,b,mAnchor.y);return!!this.MiddleAnchorLegal(mx,middleNodeIndex,mAnchor)&&!this.LineSegIntersectBound(new point_Point(sax,a.bottom),new point_Point(sbx,b.top))}MiddleAnchorLegal(mx,middleNodeIndex,mAnchor){const mLayer=this.NodeLayer(middleNodeIndex),pos=this.layerArrays.x[middleNodeIndex],shift=mx-mAnchor.x;if(pos>0){if(this.anchors[mLayer[pos-1]].right>shift+mAnchor.left)return!1}if(pos<mLayer.length-1){if(this.anchors[mLayer[pos+1]].left<shift+mAnchor.right)return!1}return!0}MiddlePos(sax,sbx,a,b,mY){const u=a.y-mY,l=mY-b.y;return(sax*u+sbx*l)/(u+l)}TryToRemoveInflections(){if(this.TurningAlwaySameDirection())return;let progress=!0;for(;progress;){progress=!1;for(const t={s:this.headSite,cut:!1};t.s;)this.TryToRemoveInflectionCorner(t),progress=t.cut||progress}}TurningAlwaySameDirection(){let sign=0;for(let s=this.headSite.next;null!=s&&null!=s.next;s=s.next){const nsign=s.turn;if(0==sign)nsign>0?sign=1:nsign<0&&(sign=-1);else if(sign*nsign<0)return!1}return!0}EdgePathPoint(i){return this.anchors[this.EdgePathNode(i)].origin}EdgePathNode(i){return i==this.edgePath.count?this.edgePath.LayerEdges[this.edgePath.count-1].Target:this.edgePath.LayerEdges[i].Source}createSmoothedPolyline(){this.RemoveVerticesWithNoTurns();let curve=new Curve;const a=this.headSite,t=Curve.findCorner(a);return null!=t?(this.createFilletCurve(curve,{a:a,b:t.b,c:t.c}),curve=this.ExtendCurveToEndpoints(curve)):curve.addSegment(LineSegment.mkPP(this.headSite.point,this.TailSite.point)),curve}curveIsLegal(curve){return!0}RemoveVerticesWithNoTurns(){for(;this.RemoveVerticesWithNoTurnsOnePass(););}RemoveVerticesWithNoTurnsOnePass(){let ret=!1;for(let s=this.headSite;null!=s.next&&null!=s.next.next;s=s.next)SmoothedPolylineCalculator.Flat(s.next)&&(ret=!0,s.next=s.next.next,s.next.prev=s);return ret}ExtendCurveToEndpoints(curve){let p=this.headSite.point;if(!point_Point.closeDistEps(p,curve.start)){const nc=new Curve;nc.addSegs([LineSegment.mkPP(p,curve.start),curve]),curve=nc}return p=this.TailSite.point,point_Point.closeDistEps(p,curve.end)||curve.addSegment(LineSegment.mkPP(curve.end,p)),curve}createFilletCurve(curve,t){for(;this.AddSmoothedCorner(t.a,t.b,t.c,curve),t.a=t.b,t.b=t.c,null!=t.b.next;)t.c=t.b.next}AddSmoothedCorner(a,b,c,curve){let seg,k=.5;do{seg=Curve.createBezierSeg(k,k,a,b,c),b.previouisBezierCoefficient=k,k/=2}while(this.BezierSegIntersectsBoundary(seg));if(k*=2,k<.5){k=.5*(k+2*k);const nseg=Curve.createBezierSeg(k,k,a,b,c);this.BezierSegIntersectsBoundary(nseg)||(b.nextBezierCoefficient=k,b.previouisBezierCoefficient=k,seg=nseg)}curve.segs.length>0&&!point_Point.closeDistEps(curve.end,seg.start)&&curve.addSegment(LineSegment.mkPP(curve.end,seg.start)),curve.addSegment(seg)}BezierSegIntersectsBoundary(seg){return point_Point.signedDoubledTriangleArea(seg.B(0),seg.B(1),seg.B(2))<0?this.BezierSegIntersectsTree(seg,this.thinWestHierarchy)||this.BezierSegIntersectsTree(seg,this.westHierarchy):this.BezierSegIntersectsTree(seg,this.thinEastHierarchy)||this.BezierSegIntersectsTree(seg,this.eastHierarchy)}BezierSegIntersectsTree(seg,tree){if(null==tree)return!1;if(Parallelogram.intersect(seg.pNodeOverICurve().parallelogram,tree.parallelogram)){if(tree.node.hasOwnProperty("children")){const n=tree.node;return this.BezierSegIntersectsTree(seg,n.children[0])||this.BezierSegIntersectsTree(seg,n.children[1])}return SmoothedPolylineCalculator.BezierSegIntersectsBoundary(seg,tree.seg)}return!1}static BezierSegIntersectsBoundary(seg,ic){for(const x of Curve.getAllIntersections(seg,ic,!1)){if(!(ic instanceof Curve))return!0;{const c=ic;if(Curve.realCutWithClosedCurve(x,c,!1))return!0}}return!1}}class Shape{constructor(boundaryCurve=null){this.parents=new Set,this.children=new Set,this.ports=new Set,this.BoundaryCurve=boundaryCurve}get Parents(){return Array.from(this.parents.values())}get Children(){return Array.from(this.children.values())}get BoundaryCurve(){return this.boundaryCurve}set BoundaryCurve(value){this.boundaryCurve=value}get BoundingBox(){return this.BoundaryCurve.boundingBox}get Ports(){return this.ports}static mkShape(){return new Shape(null)}get IsGroup(){return this.children.size>0}*Descendants(){const q=new src.o;for(const shape of this.Children)q.enqueue(shape);for(;q.length>0;){const sh=q.dequeue();yield sh;for(const shape of sh.Children)q.enqueue(shape)}}*Ancestors(){const q=new src.o;for(const shape of this.Parents)q.enqueue(shape);for(;q.length>0;){const sh=q.dequeue();yield sh;for(const shape of sh.Parents)q.enqueue(shape)}}AddParent(shape){this.parents.add(shape),shape.children.add(this)}AddChild(shape){shape.parents.add(this),this.children.add(shape)}RemoveChild(shape){this.children.delete(shape),shape.parents.delete(this)}RemoveParent(shape){this.parents.delete(shape),shape.children.delete(this)}ToString(){return this.UserData?this.UserData.toString():"null"}}function CreateRectNodeOnArrayOfRectNodes(nodes){if(0==nodes.length)return null;if(1==nodes.length)return nodes[0];const t={b0:nodes[0].irect,seed0:1},seed1=function ChooseSeeds(nodes,t){let seed1,area=areaoftwo(t.b0,nodes[t.seed0].irect);for(let i=2;i<nodes.length;i++){const area0=areaoftwo(t.b0,nodes[i].irect);area0>area&&(t.seed0=i,area=area0)}for(let i=0;i<nodes.length;i++)if(i!=t.seed0){seed1=i;break}area=nodes[t.seed0].irect.add_rect(nodes[seed1].irect).area;for(let i=0;i<nodes.length;i++){if(i==t.seed0)continue;const area1=nodes[t.seed0].irect.add_rect(nodes[i].irect).area;area1>area&&(seed1=i,area=area1)}return seed1}(nodes,t),gr0=[],gr1=[];gr0.push(nodes[t.seed0]),gr1.push(nodes[seed1]);const p={box0:nodes[t.seed0].irect,box1:nodes[seed1].irect};!function DivideNodes(nodes,seed0,seed1,gr0,gr1,t){for(let i=0;i<nodes.length;i++){if(i==seed0||i==seed1)continue;const box0_=t.box0.add_rect(nodes[i].irect),delta0=box0_.area-t.box0.area,box1_=t.box1.add_rect(nodes[i].irect),delta1=box1_.area-t.box1.area;2*gr0.length<gr1.length?(gr0.push(nodes[i]),t.box0=box0_):2*gr1.length<gr0.length?(gr1.push(nodes[i]),t.box1=box1_):delta0<delta1?(gr0.push(nodes[i]),t.box0=box0_):delta1<delta0?(gr1.push(nodes[i]),t.box1=box1_):t.box0.area<t.box1.area?(gr0.push(nodes[i]),t.box0=box0_):(gr1.push(nodes[i]),t.box1=box1_)}}(nodes,t.seed0,seed1,gr0,gr1,p);const ret=mkRectangleNodeWithCount(nodes.length);return ret.irect=p.box0.add_rect(p.box1),ret.Left=CreateRectNodeOnArrayOfRectNodes(gr0),ret.Right=CreateRectNodeOnArrayOfRectNodes(gr1),ret}function areaoftwo(a,b){return a.add_rect(b).area}function CreateRectangleNodeOnData(dataEnumeration,rectangleDelegate){if(null==dataEnumeration||null==rectangleDelegate)return null;return CreateRectNodeOnArrayOfRectNodes(Array.from(dataEnumeration).map((d=>mkRectangleNode(d,rectangleDelegate(d)))))}function mkRectangleNodeWithCount(count){const r=new RectangleNode;return r.Count=count,r}function mkRectangleNode(data,rect){const r=new RectangleNode;return r.UserData=data,r.irect=rect,r.Count=1,r}function VisitTreeStatic(rectangleNode,hitTest,hitRectangle){return rectangleNode.irect.intersects_rect(hitRectangle)?hitTest(rectangleNode.UserData)==HitTestBehavior.Continue?null!=rectangleNode.Left?VisitTreeStatic(rectangleNode.Left,hitTest,hitRectangle)==HitTestBehavior.Continue&&VisitTreeStatic(rectangleNode.Right,hitTest,hitRectangle)==HitTestBehavior.Continue?HitTestBehavior.Continue:HitTestBehavior.Stop:HitTestBehavior.Continue:HitTestBehavior.Stop:HitTestBehavior.Continue}!function(HitTestBehavior){HitTestBehavior[HitTestBehavior.Continue=0]="Continue",HitTestBehavior[HitTestBehavior.Stop=1]="Stop"}(HitTestBehavior||(HitTestBehavior={}));class RectangleNode{toString(){return this.IsLeaf?this.Count.toString()+" "+this.UserData:this.Count.toString()}get IsLeaf(){return null==this.left}get Left(){return this.left}set Left(value){null!=this.left&&this.left.Parent==this&&(this.left.Parent=null),this.left=value,null!=this.left&&(this.left.Parent=this)}get Right(){return this.right}set Right(value){null!=this.right&&this.right.Parent==this&&(this.right.Parent=null),this.right=value,null!=this.right&&(this.right.Parent=this)}get IsLeftChild(){return this==this.Parent.Left}FirstHitNodePF(point,hitTestForPointDelegate){var _a;return this.irect.contains_point(point)?this.IsLeaf?null!=hitTestForPointDelegate?hitTestForPointDelegate(point,this.UserData)==HitTestBehavior.Stop?this:null:this:null!==(_a=this.Left.FirstHitNodePF(point,hitTestForPointDelegate))&&void 0!==_a?_a:this.Right.FirstHitNodePF(point,hitTestForPointDelegate):null}FirstIntersectedNode(r){var _a;return r.intersects_rect(this.irect)?this.IsLeaf?this:null!==(_a=this.Left.FirstIntersectedNode(r))&&void 0!==_a?_a:this.Right.FirstIntersectedNode(r):null}FirstHitNodeWithPredicate(point,hitTest){var _a;return this.irect.contains_point(point)?this.IsLeaf?hitTest(point,this.UserData)==HitTestBehavior.Stop?this:null:null!==(_a=this.Left.FirstHitNodeWithPredicate(point,hitTest))&&void 0!==_a?_a:this.Right.FirstHitNodeWithPredicate(point,hitTest):null}FirstHitNode(point){var _a;return this.irect.contains_point(point)?this.IsLeaf?this:null!==(_a=this.Left.FirstHitNode(point))&&void 0!==_a?_a:this.Right.FirstHitNode(point):null}*AllHitItems(rectanglePar,hitTestAccept){const stack=new lib_src.B;for(stack.push(this);stack.size>0;){const node=stack.pop();node.irect.intersects_rect(rectanglePar)&&(node.IsLeaf?(null==hitTestAccept||hitTestAccept(node.UserData))&&(yield node.UserData):(stack.push(node.left),stack.push(node.right)))}}*AllHitItems_(point){const stack=new lib_src.B;for(stack.push(this);stack.size>0;){const node=stack.pop();node.irect.contains_point(point)&&(node.IsLeaf?yield node.UserData:(stack.push(node.left),stack.push(node.right)))}}VisitTree(hitTest,hitRectangle){VisitTreeStatic(this,hitTest,hitRectangle)}Clone(){const ret=mkRectangleNodeWithCount(this.Count);return ret.UserData=this.UserData,ret.irect=this.irect,null!=this.Left&&(ret.Left=this.Left.Clone()),null!=this.Right&&(ret.Right=this.Right.Clone()),ret}*GetNodeItemsIntersectingRectangle(rectanglePar){for(const n of this.GetLeafRectangleNodesIntersectingRectangle(rectanglePar))yield n.UserData}*GetLeafRectangleNodesIntersectingRectangle(rectanglePar){const stack=new lib_src.B;for(stack.push(this);stack.size>0;){const node=stack.pop();node.irect.intersects_rect(rectanglePar)&&(node.IsLeaf?yield node:(stack.push(node.left),stack.push(node.right)))}}*GetAllLeaves(){for(const n of this.GetAllLeafNodes())yield n.UserData}*GetAllLeafNodes(){for(const p of this.EnumRectangleNodes(!0))yield p}*EnumRectangleNodes(leafOnly){const stack=new lib_src.B;for(stack.push(this);stack.size>0;){const node=stack.pop();!node.IsLeaf&&leafOnly||(yield node),node.IsLeaf||(stack.push(node.left),stack.push(node.right))}}TraverseHierarchy(node,visitor){visitor(node),null!=node.Left&&this.TraverseHierarchy(node.Left,visitor),null!=node.Right&&this.TraverseHierarchy(node.Right,visitor)}}function mkRTree(rectsAndData){return new RTree(CreateRectNodeOnArrayOfRectNodes(rectsAndData.map((([k,v])=>mkRectangleNode(v,k)))))}function UpdateParent(parent){for(let node=parent.Parent;null!=node;node=node.Parent)node.Count--,node.irect=node.Left.irect.add_rect(node.Right.irect)}function Balanced(rectangleNode){return 2*rectangleNode.Left.Count>=rectangleNode.Right.Count&&2*rectangleNode.Right.Count>=rectangleNode.Left.Count}function NumberOfIntersectedIsLessThanBoundOnNode(node,rect,t,conditionFunc){return!node.irect.intersects_rect(rect)||(node.IsLeaf?!conditionFunc(node.UserData)||0!=--t.bound:NumberOfIntersectedIsLessThanBoundOnNode(node.Left,rect,t,conditionFunc)&&NumberOfIntersectedIsLessThanBoundOnNode(node.Right,rect,t,conditionFunc))}class RTree{constructor(rootNode){this._rootNode=rootNode}Clear(){this.RootNode=null}NumberOfIntersectedIsLessThanBound(rect,bound,conditionFunc){return NumberOfIntersectedIsLessThanBoundOnNode(this._rootNode,rect,{bound:bound},conditionFunc)}get RootNode(){return this._rootNode}set RootNode(value){this._rootNode=value}*GetAllLeaves(){if(null!=this._rootNode&&this.Count>0)for(const l of this._rootNode.GetAllLeaves())yield l}get Count(){return null==this._rootNode?0:this._rootNode.Count}Add(key,value){this.AddNode(mkRectangleNode(value,key))}AddNode(node){null==this._rootNode?this._rootNode=node:this.Count<=2?this._rootNode=CreateRectNodeOnArrayOfRectNodes(Array.from(this._rootNode.GetAllLeafNodes()).concat([node])):this.AddNodeToTreeRecursive(node,this._rootNode)}Rebuild(){this._rootNode=CreateRectNodeOnArrayOfRectNodes(Array.from(this._rootNode.GetAllLeafNodes()))}AddNodeToTreeRecursive(newNode,existingNode){if(existingNode.IsLeaf)existingNode.Left=mkRectangleNode(existingNode.UserData,existingNode.irect),existingNode.Right=newNode,existingNode.Count=2;else{let leftBox,rightBox;if(existingNode.Count++,2*existingNode.Left.Count<existingNode.Right.Count)this.AddNodeToTreeRecursive(newNode,existingNode.Left),existingNode.Left.irect=existingNode.Left.irect.add_rect(newNode.irect);else if(2*existingNode.Right.Count<existingNode.Left.Count)this.AddNodeToTreeRecursive(newNode,existingNode.Right),existingNode.Right.irect=existingNode.Right.irect.add_rect(newNode.irect);else{leftBox=existingNode.Left.irect.add_rect(newNode.irect);const delLeft=leftBox.area-existingNode.Left.irect.area;rightBox=existingNode.Right.irect.add_rect(newNode.irect);const delRight=rightBox.area-existingNode.Right.irect.area;delLeft<delRight?(this.AddNodeToTreeRecursive(newNode,existingNode.Left),existingNode.Left.irect=leftBox):delLeft>delRight?(this.AddNodeToTreeRecursive(newNode,existingNode.Right),existingNode.Right.irect=rightBox):leftBox.area<rightBox.area?(this.AddNodeToTreeRecursive(newNode,existingNode.Left),existingNode.Left.irect=leftBox):(this.AddNodeToTreeRecursive(newNode,existingNode.Right),existingNode.Right.irect=rightBox)}}existingNode.irect=existingNode.Left.irect.add_rect(existingNode.Right.irect)}GetAllIntersecting(queryRegion){return null==this._rootNode||0==this.Count?[]:Array.from(this._rootNode.GetNodeItemsIntersectingRectangle(queryRegion))}OneIntersecting(queryRegion){if(null==this._rootNode||0==this.Count)return;const ret=this._rootNode.FirstIntersectedNode(queryRegion);return null!=ret?{intersectedLeaf:ret.UserData}:void 0}GetAllLeavesIntersectingRectangle(queryRegion){return null==this._rootNode||0==this.Count?[]:this._rootNode.GetLeafRectangleNodesIntersectingRectangle(queryRegion)}IsIntersecting(queryRegion){if(null==this._rootNode||0==this.Count)return!1;for(const n of this._rootNode.GetNodeItemsIntersectingRectangle(queryRegion))return!0;return!1}Contains(rectangle,userData){if(null==this._rootNode)return!1;for(const node of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(rectangle))if(node.UserData==userData)return!0;return!1}Remove(rectangle,userData){if(null==this._rootNode)return;let ret;for(const node of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(rectangle))node.UserData==userData&&(ret=node);return null!=ret?(1==this.RootNode.Count?this.RootNode=null:this.RemoveLeaf(ret),ret.UserData):void 0}RemoveLeaf(leaf){const unbalancedNode=function FindTopUnbalancedNode(node){for(let parent=node.Parent;null!=parent;parent=parent.Parent)if(!Balanced(parent))return parent;return null}(leaf);if(null!=unbalancedNode)!function RebuildUnderNodeWithoutLeaf(nodeForRebuild,leaf){const t=new Array;for(const n of nodeForRebuild.GetAllLeafNodes())n!=leaf&&t.push(n);const newNode=CreateRectNodeOnArrayOfRectNodes(t);nodeForRebuild.Count=newNode.Count,nodeForRebuild.Left=newNode.Left,nodeForRebuild.Right=newNode.Right,nodeForRebuild.irect=newNode.Left.irect.add_rect(newNode.Right.irect)}(unbalancedNode,leaf),UpdateParent(unbalancedNode);else{const parent=leaf.Parent;null==parent?this._rootNode=new RectangleNode:(!function TransferFromSibling(parent,sibling){parent.UserData=sibling.UserData,parent.Left=sibling.Left,parent.Right=sibling.Right,parent.Count--,parent.irect=sibling.irect}(parent,leaf.IsLeftChild?parent.Right:parent.Left),UpdateParent(parent))}}UnbalancedNode(node){for(let parent=node.Parent;null!=parent;parent=parent.Parent)if(!Balanced(parent))return parent;return null}}class Port{}class FloatingPort extends Port{constructor(curve,location){super(),this.curve=this.curve,this.location=location.clone()}get Location(){return this.location}set Location(value){this.location=value}Translate(delta){this.location=this.location.add(delta)}get Curve(){return this.curve}set Curve(value){this.curve=value}}class RelativeFloatingPort extends FloatingPort{constructor(curveDelegate,centerDelegate,locationOffset){super(null,centerDelegate().add(locationOffset)),this.LocationOffset=locationOffset,this.CurveDelegate=curveDelegate,this.CenterDelegate=centerDelegate}static mk(boundaryDelegate,centerDelegate){return new RelativeFloatingPort(boundaryDelegate,centerDelegate,new point_Point(0,0))}get CenterDelegate(){return this.centerDelegate}set CenterDelegate(value){this.centerDelegate=value}get CurveDelegate(){return this.curveDelegate}set CurveDelegate(value){this.curveDelegate=value}get LocationOffset(){return this.locationOffset}set LocationOffset(value){this.locationOffset=value}get Location(){return this.CenterDelegate().add(this.LocationOffset)}get Curve(){return this.CurveDelegate()}}class RBNode{constructor(color,item,parent,left,right){this.color=color,void 0!==item&&(this.item=item),void 0!==parent&&(this.parent=parent),void 0!==left&&(this.left=left),void 0!==right&&(this.right=right)}toString(){return this.item.toString()}}!function(RBColor){RBColor[RBColor.Red=0]="Red",RBColor[RBColor.Black=1]="Black"}(RBColor||(RBColor={}));class RBTree{constructor(comparer){this.comparer=comparer,this.count=0,this.root=this.nil=new RBNode(RBColor.Black)}[Symbol.iterator](){return this.allNodes()}clear(){this.root=this.nil=new RBNode(RBColor.Black)}toNull(y){return y!=this.nil?y:null}isEmpty(){return this.root==this.nil}getComparer(){return this.comparer}getRoot(){return this.root}find(i,x=this.root){let compareResult;for(;x!=this.nil&&0!=(compareResult=this.comparer(i,x.item));)x=compareResult<0?x.left:x.right;return this.toNull(x)}findFirst(predicate,n=this.root){if(n==this.nil)return null;let good=null;for(;n!=this.nil;)n=predicate(n.item)?(good=n).left:n.right;return good}findLast(predicate,n=this.root){if(n==this.nil)return null;let good=null;for(;n!=this.nil;)n=predicate(n.item)?(good=n).right:n.left;return good}treeMinimum(x=this.root){for(;x.left!=this.nil;)x=x.left;return this.toNull(x)}treeMaximum(x=this.root){for(;x.right!=this.nil;)x=x.right;return this.toNull(x)}next(x){if(x.right!=this.nil)return this.treeMinimum(x.right);let y=x.parent;for(;y!=this.nil&&x==y.right;)x=y,y=y.parent;return this.toNull(y)}previous(x){if(x.left!=this.nil)return this.treeMaximum(x.left);let y=x.parent;for(;y!=this.nil&&x==y.left;)x=y,y=y.parent;return this.toNull(y)}leftRotate(x){const y=x.right;x.right=y.left,y.left!=this.nil&&(y.left.parent=x),y.parent=x.parent,x.parent==this.nil?this.root=y:x==x.parent.left?x.parent.left=y:x.parent.right=y,y.left=x,x.parent=y}rightRotate(x){const y=x.left;x.left=y.right,y.right!=this.nil&&(y.right.parent=x),y.parent=x.parent,x.parent==this.nil?this.root=y:x==x.parent.right?x.parent.right=y:x.parent.left=y,y.right=x,x.parent=y}deleteFixup(x){for(;x!=this.root&&x.color==RBColor.Black;)if(x==x.parent.left){let w=x.parent.right;w.color==RBColor.Red&&(w.color=RBColor.Black,x.parent.color=RBColor.Red,this.leftRotate(x.parent),w=x.parent.right),w.left.color==RBColor.Black&&w.right.color==RBColor.Black?(w.color=RBColor.Red,x=x.parent):(w.right.color==RBColor.Black&&(w.left.color=RBColor.Black,w.color=RBColor.Red,this.rightRotate(w),w=x.parent.right),w.color=x.parent.color,x.parent.color=RBColor.Black,w.right.color=RBColor.Black,this.leftRotate(x.parent),x=this.root)}else{let w=x.parent.left;w.color==RBColor.Red&&(w.color=RBColor.Black,x.parent.color=RBColor.Red,this.rightRotate(x.parent),w=x.parent.left),w.right.color==RBColor.Black&&w.left.color==RBColor.Black?(w.color=RBColor.Red,x=x.parent):(w.left.color==RBColor.Black&&(w.right.color=RBColor.Black,w.color=RBColor.Red,this.leftRotate(w),w=x.parent.left),w.color=x.parent.color,x.parent.color=RBColor.Black,w.left.color=RBColor.Black,this.rightRotate(x.parent),x=this.root)}x.color=RBColor.Black}deleteSubTree(z){let y;if(z.left==this.nil||z.right==this.nil)y=z;else for(y=z.right;y.left!=this.nil;)y=y.left;const x=y.left!=this.nil?y.left:y.right;return x.parent=y.parent,y.parent==this.nil?this.root=x:y==y.parent.left?y.parent.left=x:y.parent.right=x,y!=z&&(z.item=y.item),y.color==RBColor.Black&&this.deleteFixup(x),this.toNull(z)}deleteNodeInternal(x){this.count--,this.deleteSubTree(x)}remove(i){const n=this.find(i);return null!=n?(this.count--,this.deleteSubTree(n)):null}insert(v){const x=this.treeInsert(v);return this.insertPrivate(x),this.toNull(x)}treeInsert(z){let y=this.nil,x=this.root,compareRes=0;for(;x!=this.nil;)y=x,compareRes=this.comparer(z,x.item),x=compareRes<0?x.left:x.right;const nz=new RBNode(RBColor.Black,z,y,this.nil,this.nil);return y==this.nil?this.root=nz:compareRes<0?y.left=nz:y.right=nz,this.toNull(nz)}insertPrivate(x){for(this.count++,x.color=RBColor.Red;x!=this.root&&x.parent.color==RBColor.Red;)if(x.parent==x.parent.parent.left){const y=x.parent.parent.right;y.color==RBColor.Red?(x.parent.color=RBColor.Black,y.color=RBColor.Black,x.parent.parent.color=RBColor.Red,x=x.parent.parent):(x==x.parent.right&&(x=x.parent,this.leftRotate(x)),x.parent.color=RBColor.Black,x.parent.parent.color=RBColor.Red,this.rightRotate(x.parent.parent))}else{const y=x.parent.parent.left;y.color==RBColor.Red?(x.parent.color=RBColor.Black,y.color=RBColor.Black,x.parent.parent.color=RBColor.Red,x=x.parent.parent):(x==x.parent.left&&(x=x.parent,this.rightRotate(x)),x.parent.color=RBColor.Black,x.parent.parent.color=RBColor.Red,this.leftRotate(x.parent.parent))}this.root.color=RBColor.Black}*allNodes(){if(this.isEmpty())return;let c=this.treeMinimum();for(;null!=c;)yield c.item,c=this.next(c)}toString(){let ret="{",i=0;for(const node of this.allNodes())ret+=node.toString(),i!=this.count-1&&(ret+="\n"),i++;return ret+"}"}}class BinaryHeapWithComparer{constructor(compare){this.heapSize=0,this.A=[],this.compare=compare}Enqueue(element){let i=this.heapSize+1;this.A[i]=element,this.heapSize++;let son,parent,j=i>>1;for(;i>1&&this.Less(son=this.A[i],parent=this.A[j]);)this.A[j]=son,this.A[i]=parent,i=j,j=i>>1}Dequeue(){if(this.heapSize<1)throw new Error;const ret=this.A[1],candidate=this.A[this.heapSize];return this.heapSize--,this.ChangeMinimum(candidate),ret}ChangeMinimum(candidate){this.A[1]=candidate;let j=1,i=2,done=!1;for(;i<this.heapSize&&!done;){done=!0;const leftSon=this.A[i],rigthSon=this.A[i+1];this.compare(leftSon,rigthSon)<0?this.compare(leftSon,candidate)<0&&(this.A[j]=leftSon,this.A[i]=candidate,done=!1,j=i,i=j<<1):this.compare(rigthSon,candidate)<0&&(this.A[j]=rigthSon,this.A[i+1]=candidate,done=!1,j=i+1,i=j<<1)}if(i==this.heapSize){const leftSon=this.A[i];this.compare(leftSon,candidate)<0&&(this.A[j]=leftSon,this.A[i]=candidate)}}get Count(){return this.heapSize}Less(a,b){return this.compare(a,b)<0}GetMinimum(){return this.A[1]}}class SweepEvent{}class VertexEvent extends SweepEvent{constructor(p){super(),this.Vertex=p}get Site(){return this.Vertex.point}get Polyline(){return this.Vertex.polyline}}class LowestVertexEvent extends VertexEvent{constructor(p){super(p)}}class ObstacleSideComparer{constructor(lineSweeper){this.lineSweeper=lineSweeper}Compare(a,b){switch(point_Point.getTriangleOrientation(b.Start,b.End,this.x)){case point_TriangleOrientation.Collinear:return 0;case point_TriangleOrientation.Clockwise:return 1;default:return-1}}SetOperand(side){this.x=this.IntersectionOfSideAndSweepLine(side)}IntersectionOfSideAndSweepLine(obstacleSide){const den=obstacleSide.Direction.dot(this.lineSweeper.SweepDirection),t=(this.lineSweeper.Z-obstacleSide.Start.dot(this.lineSweeper.SweepDirection))/den;return obstacleSide.Start.add(obstacleSide.Direction.mul(t))}}class PortObstacleEvent extends SweepEvent{constructor(site){super(),this.site=site}get Site(){return this.site}}class LineSweeperBase{constructor(obstacles,sweepDirection){this.PreviousZ=Number.NEGATIVE_INFINITY,this.z=Number.NEGATIVE_INFINITY,this.Obstacles=null!=obstacles?obstacles:[],this.SweepDirection=sweepDirection,this.DirectionPerp=sweepDirection.rotate(-Math.PI/2),this.EventQueue=new BinaryHeapWithComparer(((a,b)=>this.Compare(a,b))),this.ObstacleSideComparer=new ObstacleSideComparer(this),this.LeftObstacleSideTree=new RBTree(((a,b)=>this.ObstacleSideComparer.Compare(a,b))),this.RightObstacleSideTree=new RBTree(((a,b)=>this.ObstacleSideComparer.Compare(a,b)))}get EventQueue(){return this.eventQueue}set EventQueue(value){this.eventQueue=value}get DirectionPerp(){return this.directionPerp}set DirectionPerp(value){this.directionPerp=value}get Z(){return this.z}set Z(value){value>this.z+GeomConstants.tolerance&&(this.PreviousZ=this.z),this.z=value}GetZS(eve){return this.SweepDirection.dot(eve.Site)}GetZP(point){return this.SweepDirection.dot(point)}SegmentIsNotHorizontal(a,b){return Math.abs(a.sub(b).dot(this.SweepDirection))>GeomConstants.distanceEpsilon}RemoveLeftSide(side){this.ObstacleSideComparer.SetOperand(side),this.LeftObstacleSideTree.remove(side)}RemoveRightSide(side){this.ObstacleSideComparer.SetOperand(side),this.RightObstacleSideTree.remove(side)}InsertLeftSide(side){this.ObstacleSideComparer.SetOperand(side),this.LeftObstacleSideTree.insert(side)}InsertRightSide(side){this.ObstacleSideComparer.SetOperand(side),this.RightObstacleSideTree.insert(side)}FindFirstObstacleSideToTheLeftOfPoint(point){const node=this.RightObstacleSideTree.findLast((s=>point_Point.pointToTheRightOfLineOrOnLine(point,s.Start,s.End)));return null==node?null:node.item}FindFirstObstacleSideToToTheRightOfPoint(point){const node=this.LeftObstacleSideTree.findFirst((s=>!point_Point.pointToTheRightOfLineOrOnLine(point,s.Start,s.End)));return null==node?null:node.item}EnqueueEvent(eve){this.eventQueue.Enqueue(eve)}InitQueueOfEvents(){for(const obstacle of this.Obstacles)this.EnqueueLowestPointsOnObstacles(obstacle);if(null!=this.Ports)for(const point of this.Ports.values())this.EnqueueEvent(new PortObstacleEvent(point))}EnqueueLowestPointsOnObstacles(poly){const candidate=this.GetLowestPoint(poly);this.EnqueueEvent(new LowestVertexEvent(candidate))}GetLowestPoint(poly){let candidate=poly.startPoint,pp=poly.startPoint.next;for(;null!=pp;pp=pp.next)this.Less(pp.point,candidate.point)&&(candidate=pp);return candidate}Compare(a,b){const aSite=a.Site,bSite=b.Site;return this.ComparePoints(aSite,bSite)}Less(a,b){return this.ComparePoints(a,b)<0}ComparePoints(aSite,bSite){let aProjection=this.SweepDirection.dot(aSite),bProjection=this.SweepDirection.dot(bSite);return aProjection<bProjection?-1:aProjection>bProjection?1:(aProjection=this.directionPerp.dot(aSite),bProjection=this.directionPerp.dot(bSite),aProjection<bProjection?-1:aProjection>bProjection?1:0)}}class VisibilityEdge{constructor(s,t,weight=1){this.LengthMultiplier=1,(VisibilityEdge.closeuv(s,t)||VisibilityEdge.closeuv(t,s))&&console.log(s),this.Source=s,this.Target=t,this.Weight=weight}static closeuv(s,t){return point_Point.closeDistEps(s.point,VisibilityEdge.u,.1)&&point_Point.closeDistEps(t.point,VisibilityEdge.v,.1)}get SourcePoint(){return this.Source.point}get TargetPoint(){return this.Target.point}get Length(){return this.SourcePoint.sub(this.TargetPoint).length*this.LengthMultiplier}toString(){return dist.Qf.Format("{0}->{1} ({2})",this.Source,this.Target,this.Weight)}ReversedClone(){return new VisibilityEdge(this.Target,this.Source)}Clone(){return new VisibilityEdge(this.Source,this.Target)}}VisibilityEdge.u=new point_Point(545.833,840.458),VisibilityEdge.v=new point_Point(606.1667261889578,786.2917261889578),VisibilityEdge.DefaultWeight=1;class TollFreeVisibilityEdge extends VisibilityEdge{static constructorVV(source,target){return new TollFreeVisibilityEdge(source,target,0)}constructor(source,target,weight=0){super(source,target,weight)}}class VisibilityVertex{constructor(point){this._inEdges=new Array,this._outEdges=new RBTree(((a,b)=>this.Compare(a,b))),this.point=point}get InEdges(){return this._inEdges}get OutEdges(){return this._outEdges}get Degree(){return this._inEdges.length+this.OutEdges.count}InEdgesLength(){return this._inEdges.length}addInEdge(e){this._inEdges.push(e)}get IsTerminal(){return this._isTerminal}set IsTerminal(value){this._isTerminal=value}get IsShortestPathTerminal(){return this._isShortestPathTerminal}set IsShortestPathTerminal(value){this._isShortestPathTerminal=value}toString(){return this.point.toString()}RemoveOutEdge(edge){this.OutEdges.remove(edge)}RemoveInEdge(edge){const i=this._inEdges.indexOf(edge);if(-1==i)return;const last=this._inEdges.length-1;i!=last&&(this._inEdges[i]=this._inEdges[last]),this._inEdges.pop()}static FindFirst(tree,targetPoint){return VisibilityVertex.FindFirst_t(tree.root,tree,targetPoint)}static FindFirst_t(n,tree,targetPoint){if(n==tree.nil)return null;let ret=null;for(;n!=tree.nil;)n=n.item.TargetPoint.compareTo(targetPoint)>=0?(ret=n).left:n.right;return ret}get(target){let node=VisibilityVertex.FindFirst(this.OutEdges,target.point);return null!=node&&node.item.Target==target?node.item:(node=VisibilityVertex.FindFirst(target.OutEdges,this.point),null!=node&&node.item.Target==this?node.item:null)}Compare(a,b){return a.TargetPoint.compareTo(b.TargetPoint)}ClearEdges(){this._outEdges.clear(),this._inEdges=[]}}class VisibilityGraph{constructor(){this._prevEdgesMap=new Map,this.visVertexToId=new Map,this.VertexFactory=p=>new VisibilityVertex(p),this.pointToVertexMap=new PointMap}*edges_(){for(const u of this.pointToVertexMap.values())for(const e of u.OutEdges)yield e}get Edges(){return this.edges_()}ClearPrevEdgesTable(){this._prevEdgesMap.clear()}ShrinkLengthOfPrevEdge(v,lengthMultiplier){this._prevEdgesMap.get(v).LengthMultiplier=lengthMultiplier}PreviosVertex(v){const prev=this._prevEdgesMap.get(v);return prev?prev.Source==v?prev.Target:prev.Source:null}SetPreviousEdge(v,e){this._prevEdgesMap.set(v,e)}AddHole(polyline){let p=polyline.startPoint;for(;p!=polyline.endPoint;)this.AddEdgePlPl(p,p.next),p=p.next;this.AddEdgePlPl(polyline.endPoint,polyline.startPoint)}static*OrientHolesClockwise(holes){for(const poly of holes)for(let p=poly.startPoint;;p=p.next){const orientation=point_Point.getTriangleOrientation(p.point,p.next.point,p.next.next.point);if(orientation!=point_TriangleOrientation.Collinear){yield orientation==point_TriangleOrientation.Clockwise?poly:poly.reverse();break}}}AddVertexP(point){const currentVertex=this.pointToVertexMap.get(point);if(currentVertex)return currentVertex;const newVertex=this.VertexFactory(point);return this.pointToVertexMap.set(point,newVertex),newVertex}AddVertexV(vertex){this.pointToVertexMap.set(vertex.point,vertex)}ContainsVertex(point){return this.pointToVertexMap.has(point)}static AddEdgeVV(source,target){let visEdge;if(visEdge=source.get(target))return visEdge;if(source==target)throw new Error("Self-edges are not allowed");const edge=new VisibilityEdge(source,target);return source.OutEdges.insert(edge),target.InEdges.push(edge),edge}AddEdgePlPl(source,target){this.AddEdgePP(source.point,target.point)}static AddEdge(edge){edge.Source.OutEdges.insert(edge),edge.Target.addInEdge(edge)}AddEdgeF(source,target,edgeCreator){let sourceV=this.FindVertex(source),targetV=null;if(null!=sourceV&&(targetV=this.FindVertex(target),null!=targetV)){const edge=sourceV.get(targetV);if(edge)return edge}null==sourceV?(sourceV=this.AddVertexP(source),targetV=this.AddVertexP(target)):null==targetV&&(targetV=this.AddVertexP(target));const edge=edgeCreator(sourceV,targetV);return sourceV.OutEdges.insert(edge),targetV.addInEdge(edge),edge}AddEdgePP(source,target){return this.AddEdgeF(source,target,((a,b)=>new VisibilityEdge(a,b)))}FindVertex(point){return this.pointToVertexMap.get(point)}Vertices(){return this.pointToVertexMap.values()}RemoveVertex(vertex){for(const edge of vertex.OutEdges)edge.Target.RemoveInEdge(edge);for(const edge of vertex.InEdges)edge.Source.RemoveOutEdge(edge);this.pointToVertexMap.deleteP(vertex.point)}FindEdgePP(source,target){const sourceV=this.FindVertex(source);if(null==sourceV)return null;const targetV=this.FindVertex(target);return null==targetV?null:sourceV.get(targetV)}static RemoveEdge(edge){edge.Source.RemoveOutEdge(edge),edge.Target.RemoveInEdge(edge)}ClearEdges(){for(const visibilityVertex of this.Vertices())visibilityVertex.ClearEdges()}}class ConeSide{constructor(){this.Removed=!1}}class BrokenConeSide extends ConeSide{constructor(start,end,coneSide){super(),this.start=start,this.EndVertex=end,this.ConeSide=coneSide}get Start(){return this.start}get End(){return this.EndVertex.point}get Direction(){return this.End.sub(this.Start)}toString(){return"BrokenConeSide: "+this.Start+","+this.End}}class Cone{constructor(apex,coneSweeper){this.apex=apex,this.coneSweeper=coneSweeper}get Removed(){return this.removed}set Removed(value){this.removed=value}get Apex(){return this.apex}set Apex(value){this.apex=value}get RightSideDirection(){return this.coneSweeper.ConeRightSideDirection}get LeftSideDirection(){return this.coneSweeper.ConeLeftSideDirection}get RightSide(){return this.rightSide}set RightSide(value){this.rightSide=value,this.rightSide.Cone=this}get LeftSide(){return this.leftSide}set LeftSide(value){this.leftSide=value,this.leftSide.Cone=this}}class ConeClosureEvent extends SweepEvent{constructor(site,cone){super(),this.site=site,this.coneToClose=cone}get ConeToClose(){return this.coneToClose}get Site(){return this.site}toString(){return"ConeClosureEvent "+this.site}}class ConeLeftSide extends ConeSide{constructor(cone){super(),this.Cone=cone}get Start(){return this.Cone.Apex}get Direction(){return this.Cone.LeftSideDirection}toString(){return"ConeLeftSide "+this.Start+" "+this.Direction}}class ConeRightSide extends ConeSide{constructor(cone){super(),this.Cone=cone}get Start(){return this.Cone.Apex}get Direction(){return this.Cone.RightSideDirection}toString(){return"ConeRightSide "+this.Start+" "+this.Direction}}class ConeSideComparer{constructor(coneSweeper){this.coneSweeper=coneSweeper}SetOperand(activeElement){this.x=this.IntersectionOfSegmentAndSweepLine(activeElement)}Compare(a,b){const bIsBrokenConeSide=b instanceof BrokenConeSide;return a instanceof BrokenConeSide?bIsBrokenConeSide?this.CompareBrokenSides(a,b):this.CompareObstacleSideAndConeSide(b):bIsBrokenConeSide?this.CompareConeSideAndObstacleSide(a,b):ConeSideComparer.CompareNotIntersectingSegs(a,b)}static CompareNotIntersectingSegs(a,b){switch(point_Point.getTriangleOrientation(a.Start,b.Start,b.Start.add(b.Direction))){case point_TriangleOrientation.Counterclockwise:return-1;case point_TriangleOrientation.Clockwise:return 1;default:return 0}}CompareObstacleSideAndConeSide(coneSide){const orientation=point_Point.getTriangleOrientation(this.x,coneSide.Start,coneSide.Start.add(coneSide.Direction));return orientation==point_TriangleOrientation.Counterclockwise?-1:orientation==point_TriangleOrientation.Clockwise?1:coneSide instanceof ConeLeftSide?-1:1}CompareConeSideAndObstacleSide(coneSide,brokenConeSide){const orientation=point_Point.getTriangleOrientation(this.x,brokenConeSide.start,brokenConeSide.End);return orientation==point_TriangleOrientation.Counterclockwise?-1:orientation==point_TriangleOrientation.Clockwise||coneSide instanceof ConeLeftSide?1:-1}IntersectionOfSegmentAndSweepLine(obstacleSide){const den=obstacleSide.Direction.dot(this.coneSweeper.SweepDirection),t=(this.coneSweeper.Z-obstacleSide.Start.dot(this.coneSweeper.SweepDirection))/den;return obstacleSide.Start.add(obstacleSide.Direction.mul(t))}CompareBrokenSides(aObst,bObst){return aObst.EndVertex==bObst.EndVertex?ConeSideComparer.CompareNotIntersectingSegs(aObst.ConeSide,bObst.ConeSide):point_Point.getTriangleOrientation(this.x,bObst.start,bObst.EndVertex.point)==point_TriangleOrientation.Counterclockwise?-1:1}}class LeftIntersectionEvent extends SweepEvent{constructor(coneLeftSide,intersectionPoint,endVertex){super(),this.coneLeftSide=coneLeftSide,this.intersectionPoint=intersectionPoint,this.endVertex=endVertex}get EndVertex(){return this.endVertex}get Site(){return this.intersectionPoint}toString(){return"LeftIntersectionEvent "+this.intersectionPoint}}class SegmentBase{get Direction(){return this.End.sub(this.Start)}toString(){return this.Start+" "+this.End}}class ObstacleSide extends SegmentBase{constructor(startVertex){super(),this.Init(startVertex)}Init(sv){this.StartVertex=sv}get Polyline(){return this.StartVertex.polyline}get Start(){return this.StartVertex.point}get End(){return this.EndVertex.point}}class LeftObstacleSide extends ObstacleSide{constructor(startVertex){super(startVertex),this.end=startVertex.nextOnPolyline.point}get End(){return this.end}get EndVertex(){return this.StartVertex.nextOnPolyline}}class LeftVertexEvent extends VertexEvent{constructor(p){super(p)}}class RightIntersectionEvent extends SweepEvent{constructor(coneRightSide,intersectionPoint,endVertex){super(),this.coneRightSide=coneRightSide,this.intersectionPoint=intersectionPoint,this.endVertex=endVertex}get EndVertex(){return this.endVertex}set EndVertex(value){this.endVertex=value}get Site(){return this.intersectionPoint}toString(){return"RightIntersectionEvent "+this.intersectionPoint}}class RightObstacleSide extends ObstacleSide{constructor(startVertex){super(startVertex),this.end=startVertex.prevOnPolyline.point}get End(){return this.end}get EndVertex(){return this.StartVertex.prevOnPolyline}}class RightVertexEvent extends VertexEvent{constructor(p){super(p)}}class LineSweeper extends LineSweeperBase{constructor(obstacles,direction,coneRsDir,coneLsDir,visibilityGraph,ports,borderPolyline){super(obstacles,direction),this.visibilityGraph=visibilityGraph,this.ConeRightSideDirection=coneRsDir,this.ConeLeftSideDirection=coneLsDir,this.coneSideComparer=new ConeSideComparer(this),this.leftConeSides=new RBTree(((a,b)=>this.coneSideComparer.Compare(a,b))),this.rightConeSides=new RBTree(((a,b)=>this.coneSideComparer.Compare(a,b))),this.Ports=ports,this.BorderPolyline=borderPolyline,this.PortEdgesCreator=(a,b)=>new TollFreeVisibilityEdge(a,b,0)}static Sweep(obstacles,direction,coneAngle,visibilityGraph,ports,borderPolyline){new LineSweeper(obstacles,direction,direction.rotate(-coneAngle/2),direction.rotate(coneAngle/2),visibilityGraph,ports,borderPolyline).Calculate()}Calculate(){for(LineSweeper.debCount++,this.InitQueueOfEvents();this.EventQueue.Count>0;)this.ProcessEvent(this.EventQueue.Dequeue());null!=this.BorderPolyline&&this.CloseRemainingCones(),this.CreatePortEdges()}CreatePortEdges(){if(null!=this.portEdgesGraph)for(const edge of this.portEdgesGraph.Edges)this.visibilityGraph.AddEdgeF(edge.SourcePoint,edge.TargetPoint,this.PortEdgesCreator)}CloseRemainingCones(){if(0==this.leftConeSides.count)return;let p=this.BorderPolyline.startPoint,steps=this.leftConeSides.count;do{const cone=this.leftConeSides.treeMinimum().item.Cone;p=this.FindPolylineSideIntersectingConeRightSide(p,cone),p=this.GetPolylinePointInsideOfConeAndRemoveCones(p,cone),steps--}while(this.leftConeSides.count>0&&steps>0)}GetPolylinePointInsideOfConeAndRemoveCones(p,cone){const pn=p.nextOnPolyline,insidePoint=LineSweeper.FindInsidePoint(p.point,pn.point,cone);return point_Point.closeDistEps(insidePoint,p.point)?(this.AddEdgeAndRemoveCone(cone,p.point),this.AddEdgesAndRemoveRemainingConesByPoint(p.point)):point_Point.closeDistEps(insidePoint,pn.point)?(this.AddEdgeAndRemoveCone(cone,pn.point),this.AddEdgesAndRemoveRemainingConesByPoint(pn.point),p=pn):(p=LineSweeper.InsertPointIntoPolylineAfter(this.BorderPolyline,p,insidePoint),this.AddEdgeAndRemoveCone(cone,p.point),this.AddEdgesAndRemoveRemainingConesByPoint(p.point)),p}static FindInsidePoint(leftPoint,rightPoint,cone){return LineSweeper.FindInsidePointBool(leftPoint,rightPoint,cone.Apex,cone.Apex.add(cone.LeftSideDirection),cone.Apex.add(cone.RightSideDirection))}static FindInsidePointBool(leftPoint,rightPoint,apex,leftSideConePoint,rightSideConePoint){if(point_Point.closeDistEps(leftPoint,rightPoint))return leftPoint;if(point_Point.PointIsInsideCone(leftPoint,apex,leftSideConePoint,rightSideConePoint))return leftPoint;if(point_Point.PointIsInsideCone(rightPoint,apex,leftSideConePoint,rightSideConePoint))return rightPoint;const m=point_Point.middle(leftPoint,rightPoint);return point_Point.pointToTheLeftOfLine(m,apex,leftSideConePoint)?LineSweeper.FindInsidePointBool(m,rightPoint,apex,leftSideConePoint,rightSideConePoint):LineSweeper.FindInsidePointBool(leftPoint,m,apex,leftSideConePoint,rightSideConePoint)}AddEdgesAndRemoveRemainingConesByPoint(point){const conesToRemove=new Array;for(const leftConeSide of this.leftConeSides){if(!point_Point.PointToTheRightOfLineOrOnLine(point,leftConeSide.Start,leftConeSide.Start.add(leftConeSide.Direction)))break;conesToRemove.push(leftConeSide.Cone)}for(const cone of conesToRemove)this.AddEdgeAndRemoveCone(cone,point)}FindPolylineSideIntersectingConeRightSide(p,cone){const startPoint=p,a=cone.Apex,b=cone.Apex.add(this.ConeRightSideDirection);let pSign=LineSweeper.GetSign(p,a,b);for(;;){const pn=p.nextOnPolyline,pnSigh=LineSweeper.GetSign(pn,a,b);if(pnSigh-pSign>0)return p;if(pSign=pnSigh,(p=pn)==startPoint)throw new Error("cannod decide if the polyline intersects the cone!")}}static GetSign(p,a,b){const d=point_Point.signedDoubledTriangleArea(a,b,p.point);return d<0?1:d>0?-1:0}AddEdgeAndRemoveCone(cone,p){null!=this.Ports&&this.Ports.has(cone.Apex)?this.CreatePortEdge(cone,p):this.visibilityGraph.AddEdgePP(cone.Apex,p),this.RemoveCone(cone)}CreatePortEdge(cone,p){null==this.portEdgesGraph&&(this.portEdgesGraph=new VisibilityGraph);const coneApexVert=this.portEdgesGraph.FindVertex(cone.Apex),edgesToFix=null!=coneApexVert?Array.from(coneApexVert.InEdges).concat(Array.from(coneApexVert.OutEdges.allNodes())):null;if(edgesToFix)for(const edge of edgesToFix){const otherPort=(edge.Target==coneApexVert?edge.Source:edge.Target).point;VisibilityGraph.RemoveEdge(edge),this.portEdgesGraph.AddEdgePP(otherPort,p)}this.portEdgesGraph.AddEdgePP(cone.Apex,p)}static InsertPointIntoPolylineAfter(borderPolyline,insertAfter,pointToInsert){let np;return null!=insertAfter.next?(np=PolylinePoint.mkFromPoint(pointToInsert),np.prev=insertAfter,np.next=insertAfter.next,insertAfter.next.prev=np,insertAfter.next=np):(np=PolylinePoint.mkFromPoint(pointToInsert),np.prev=insertAfter,insertAfter.next=np,borderPolyline.endPoint=np),np.polyline=borderPolyline,borderPolyline.setInitIsRequired(),np}ProcessEvent(p){5682==LineSweeper.debCount&&(p.Site.sub(new point_Point(616.167,807.958)).length<.1||p.Site.sub(new point_Point(525.8332738110422,807.9582738110422)).length<.1)&&console.log(this);if(p instanceof VertexEvent)this.ProcessVertexEvent(p);else{if(p instanceof RightIntersectionEvent)this.ProcessRightIntersectionEvent(p);else{if(p instanceof LeftIntersectionEvent)this.ProcessLeftIntersectionEvent(p);else{p instanceof ConeClosureEvent?p.ConeToClose.Removed||this.RemoveCone(p.ConeToClose):this.ProcessPortObstacleEvent(p),this.Z=this.GetZS(p)}}}}ProcessPortObstacleEvent(portObstacleEvent){this.Z=this.GetZS(portObstacleEvent),this.GoOverConesSeeingVertexEvent(portObstacleEvent),this.CreateConeOnVertex(portObstacleEvent)}ProcessLeftIntersectionEvent(leftIntersectionEvent){if(0==leftIntersectionEvent.coneLeftSide.Removed)if(Math.abs(leftIntersectionEvent.EndVertex.point.sub(leftIntersectionEvent.Site).dot(this.SweepDirection))<GeomConstants.distanceEpsilon)this.RemoveCone(leftIntersectionEvent.coneLeftSide.Cone);else{this.RemoveSegFromLeftTree(leftIntersectionEvent.coneLeftSide),this.Z=this.GetZP(leftIntersectionEvent.Site);const leftSide=new BrokenConeSide(leftIntersectionEvent.Site,leftIntersectionEvent.EndVertex,leftIntersectionEvent.coneLeftSide);this.InsertToTree(this.leftConeSides,leftSide),leftIntersectionEvent.coneLeftSide.Cone.LeftSide=leftSide,this.LookForIntersectionOfObstacleSideAndLeftConeSide(leftIntersectionEvent.Site,leftIntersectionEvent.EndVertex),this.TryCreateConeClosureForLeftSide(leftSide)}else this.Z=this.GetZP(leftIntersectionEvent.Site)}TryCreateConeClosureForLeftSide(leftSide){if(leftSide.Cone.RightSide instanceof ConeRightSide){const coneRightSide=leftSide.Cone.RightSide;point_Point.getTriangleOrientation(coneRightSide.Start,coneRightSide.Start.add(coneRightSide.Direction),leftSide.EndVertex.point)==point_TriangleOrientation.Clockwise&&this.CreateConeClosureEvent(leftSide,coneRightSide)}}CreateConeClosureEvent(brokenConeSide,otherSide){const x=point_Point.RayIntersectsRayInteriors(brokenConeSide.start,brokenConeSide.Direction,otherSide.Start,otherSide.Direction),cc=new ConeClosureEvent(x,brokenConeSide.Cone);this.EnqueueEvent(cc)}ProcessRightIntersectionEvent(rightIntersectionEvent){if(0==rightIntersectionEvent.coneRightSide.Removed){this.RemoveSegFromRightTree(rightIntersectionEvent.coneRightSide),this.Z=this.GetZP(rightIntersectionEvent.Site);const rightSide=new BrokenConeSide(rightIntersectionEvent.Site,rightIntersectionEvent.EndVertex,rightIntersectionEvent.coneRightSide);this.InsertToTree(this.rightConeSides,rightSide),rightIntersectionEvent.coneRightSide.Cone.RightSide=rightSide,this.LookForIntersectionOfObstacleSideAndRightConeSide(rightIntersectionEvent.Site,rightIntersectionEvent.EndVertex),this.TryCreateConeClosureForRightSide(rightSide)}else this.Z=this.GetZP(rightIntersectionEvent.Site)}TryCreateConeClosureForRightSide(rightSide){if(rightSide.Cone.LeftSide instanceof ConeLeftSide){const coneLeftSide=rightSide.Cone.LeftSide;point_Point.getTriangleOrientation(coneLeftSide.Start,coneLeftSide.Start.add(coneLeftSide.Direction),rightSide.EndVertex.point)==point_TriangleOrientation.Counterclockwise&&this.CreateConeClosureEvent(rightSide,coneLeftSide)}}RemoveConesClosedBySegment(leftPoint,rightPoint){this.CloseConesCoveredBySegment(leftPoint,rightPoint,this.GetZP(leftPoint)>this.GetZP(rightPoint)?this.leftConeSides:this.rightConeSides)}CloseConesCoveredBySegment(leftPoint,rightPoint,tree){let node=tree.findFirst((s=>point_Point.getTriangleOrientation(s.Start,s.Start.add(s.Direction),leftPoint)==point_TriangleOrientation.Counterclockwise));if(null==node)return;if(!point_Point.IntervalIntersectsRay(leftPoint,rightPoint,node.item.Start,node.item.Direction))return;const conesToRemove=new Array;do{conesToRemove.push(node.item.Cone),node=tree.next(node)}while(null!=node&&null!=point_Point.IntervalIntersectsRay(leftPoint,rightPoint,node.item.Start,node.item.Direction));for(const cone of conesToRemove)this.RemoveCone(cone)}ProcessVertexEvent(vertexEvent){this.Z=this.GetZS(vertexEvent),this.GoOverConesSeeingVertexEvent(vertexEvent),this.AddConeAndEnqueueEvents(vertexEvent)}static Diamond(p){return curveFactory_CurveFactory.CreateDiamond(2,2,p)}AddConeAndEnqueueEvents(vertexEvent){if(vertexEvent instanceof LeftVertexEvent){const nextPoint=vertexEvent.Vertex.nextOnPolyline;this.CloseConesAddConeAtLeftVertex(vertexEvent,nextPoint)}else{if(vertexEvent instanceof RightVertexEvent){const nextPoint=vertexEvent.Vertex.prevOnPolyline;this.CloseConesAddConeAtRightVertex(vertexEvent,nextPoint)}else this.CloseConesAddConeAtLeftVertex(vertexEvent,vertexEvent.Vertex.nextOnPolyline),this.CloseConesAddConeAtRightVertex(vertexEvent,vertexEvent.Vertex.prevOnPolyline)}}CloseConesAddConeAtRightVertex(rightVertexEvent,nextVertex){const prevSite=rightVertexEvent.Vertex.nextOnPolyline.point;this.directionPerp.dot(rightVertexEvent.Site.sub(prevSite))>GeomConstants.distanceEpsilon&&this.RemoveConesClosedBySegment(prevSite,rightVertexEvent.Vertex.point),this.directionPerp.dot(nextVertex.point.sub(rightVertexEvent.Site))>GeomConstants.distanceEpsilon&&this.RemoveConesClosedBySegment(rightVertexEvent.Site,nextVertex.point);const site=rightVertexEvent.Site,coneLp=site.add(this.ConeLeftSideDirection),coneRp=site.add(this.ConeRightSideDirection),nextSite=nextVertex.point;this.GetZP(site.sub(prevSite))>GeomConstants.distanceEpsilon&&this.RemoveRightSide(new RightObstacleSide(rightVertexEvent.Vertex.nextOnPolyline)),this.GetZP(site.sub(nextVertex.point))>GeomConstants.distanceEpsilon&&this.RemoveLeftSide(new LeftObstacleSide(nextVertex)),this.GetZP(nextSite)+GeomConstants.distanceEpsilon<this.GetZS(rightVertexEvent)&&this.CreateConeOnVertex(rightVertexEvent),point_Point.PointToTheRightOfLineOrOnLine(nextSite,site,coneLp)?point_Point.PointToTheLeftOfLineOrOnLine(nextSite,site,coneRp)?this.CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent,nextVertex):(this.GetZP(nextSite.sub(site))>GeomConstants.distanceEpsilon&&(this.LookForIntersectionOfObstacleSideAndLeftConeSide(rightVertexEvent.Site,nextVertex),this.InsertRightSide(new RightObstacleSide(rightVertexEvent.Vertex))),this.EnqueueRightVertexEvent(new RightVertexEvent(nextVertex))):(this.CreateConeOnVertex(rightVertexEvent),point_Point.PointToTheLeftOfLineOrOnLine(nextSite.add(this.DirectionPerp),nextSite,site)&&this.EnqueueRightVertexEvent(new RightVertexEvent(nextVertex)))}CaseToTheLeftOfLineOrOnLineConeRp(rightVertexEvent,nextVertex){this.EnqueueRightVertexEvent(new RightVertexEvent(nextVertex));const cone=new Cone(rightVertexEvent.Vertex.point,this),obstacleSideSeg=new BrokenConeSide(cone.Apex,nextVertex,new ConeLeftSide(cone));cone.LeftSide=obstacleSideSeg,cone.RightSide=new ConeRightSide(cone);const rnode=this.InsertToTree(this.rightConeSides,cone.RightSide);this.LookForIntersectionWithConeRightSide(rnode);const lnode=this.InsertToTree(this.leftConeSides,cone.LeftSide);this.FixConeLeftSideIntersections(obstacleSideSeg,lnode),this.GetZP(nextVertex.point.sub(rightVertexEvent.Site))>GeomConstants.distanceEpsilon&&this.InsertRightSide(new RightObstacleSide(rightVertexEvent.Vertex))}LookForIntersectionOfObstacleSideAndRightConeSide(obstacleSideStart,obstacleSideVertex){const node=this.GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart);if(null!=node){if(null!=node.item instanceof ConeRightSide){const intersection=point_Point.IntervalIntersectsRay(obstacleSideStart,obstacleSideVertex.point,node.item.Start,this.ConeRightSideDirection);intersection&&this.SegmentIsNotHorizontal(intersection,obstacleSideVertex.point)&&this.EnqueueEvent(this.CreateRightIntersectionEvent(node.item,intersection,obstacleSideVertex))}}}CreateRightIntersectionEvent(coneRightSide,intersection,obstacleSideVertex){return new RightIntersectionEvent(coneRightSide,intersection,obstacleSideVertex)}GetLastNodeToTheLeftOfPointInRightSegmentTree(obstacleSideStart){return this.rightConeSides.findLast((s=>LineSweeper.PointIsToTheRightOfSegment(obstacleSideStart,s)))}LookForIntersectionOfObstacleSideAndLeftConeSide(obstacleSideStart,obstacleSideVertex){const node=this.GetFirstNodeToTheRightOfPoint(obstacleSideStart);if(null==node)return;if(!(node.item instanceof ConeLeftSide))return;const coneLeftSide=node.item,intersection=point_Point.IntervalIntersectsRay(obstacleSideStart,obstacleSideVertex.point,coneLeftSide.Start,this.ConeLeftSideDirection);intersection&&this.EnqueueEvent(new LeftIntersectionEvent(coneLeftSide,intersection,obstacleSideVertex))}GetFirstNodeToTheRightOfPoint(p){return this.leftConeSides.findFirst((s=>LineSweeper.PointIsToTheLeftOfSegment(p,s)))}static PointIsToTheLeftOfSegment(p,seg){return point_Point.getTriangleOrientation(seg.Start,seg.Start.add(seg.Direction),p)==point_TriangleOrientation.Counterclockwise}static PointIsToTheRightOfSegment(p,seg){return point_Point.getTriangleOrientation(seg.Start,seg.Start.add(seg.Direction),p)==point_TriangleOrientation.Clockwise}FixConeLeftSideIntersections(leftSide,rbNode){do{rbNode=this.leftConeSides.next(rbNode)}while(null!=rbNode&&point_Point.PointToTheRightOfLineOrOnLine(leftSide.Start,rbNode.item.Start,rbNode.item.Start.add(rbNode.item.Direction)));if(null!=rbNode&&rbNode.item instanceof ConeLeftSide){const seg=rbNode.item,intersection=point_Point.IntervalIntersectsRay(leftSide.start,leftSide.End,seg.Start,seg.Direction);intersection&&this.EnqueueEvent(new LeftIntersectionEvent(seg,intersection,leftSide.EndVertex))}}InsertToTree(tree,coneSide){return this.coneSideComparer.SetOperand(coneSide),tree.insert(coneSide)}CloseConesAddConeAtLeftVertex(leftVertexEvent,nextVertex){const prevSite=leftVertexEvent.Vertex.prevOnPolyline.point;leftVertexEvent.Site.sub(prevSite).dot(this.directionPerp)<-GeomConstants.distanceEpsilon&&this.RemoveConesClosedBySegment(leftVertexEvent.Site,prevSite),nextVertex.point.sub(leftVertexEvent.Site).dot(this.directionPerp)<-GeomConstants.distanceEpsilon&&this.RemoveConesClosedBySegment(nextVertex.point,leftVertexEvent.Site);const site=leftVertexEvent.Site,coneLp=site.add(this.ConeLeftSideDirection),coneRp=site.add(this.ConeRightSideDirection),nextSite=nextVertex.point;this.GetZP(site.sub(prevSite))>GeomConstants.distanceEpsilon&&this.RemoveLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex.prevOnPolyline));const nextDelZ=this.GetZP(nextSite)-this.Z;nextDelZ<-GeomConstants.distanceEpsilon&&this.RemoveRightSide(new RightObstacleSide(nextVertex));const toNext=nextSite.sub(leftVertexEvent.Site);if(nextDelZ<-GeomConstants.distanceEpsilon||closeDistEps(nextDelZ,0)&&this.GetZP(toNext)>0&&toNext.dot(this.directionPerp)>-GeomConstants.distanceEpsilon)this.CreateConeOnVertex(leftVertexEvent);else if(point_Point.PointToTheLeftOfLineOrOnLine(nextSite,site,coneRp))if(point_Point.PointToTheLeftOfLineOrOnLine(nextSite,site,coneLp))this.EnqueueEvent(new LeftVertexEvent(nextVertex)),this.GetZP(toNext)>GeomConstants.distanceEpsilon&&(this.LookForIntersectionOfObstacleSideAndRightConeSide(leftVertexEvent.Site,nextVertex),this.InsertLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex)));else{this.EnqueueEvent(new LeftVertexEvent(nextVertex));const cone=new Cone(leftVertexEvent.Vertex.point,this),rightSide=new BrokenConeSide(leftVertexEvent.Vertex.point,nextVertex,new ConeRightSide(cone));cone.RightSide=rightSide,cone.LeftSide=new ConeLeftSide(cone),this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides,cone.LeftSide));const rbNode=this.InsertToTree(this.rightConeSides,rightSide);this.FixConeRightSideIntersections(rightSide,rbNode),this.GetZP(toNext)>GeomConstants.distanceEpsilon&&this.InsertLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex))}else this.CreateConeOnVertex(leftVertexEvent),this.EnqueueEvent(new LeftVertexEvent(nextVertex))}RemoveCone(cone){cone.Removed=!0,this.RemoveSegFromLeftTree(cone.LeftSide),this.RemoveSegFromRightTree(cone.RightSide)}RemoveSegFromRightTree(coneSide){this.coneSideComparer.SetOperand(coneSide);let b=this.rightConeSides.remove(coneSide);if(coneSide.Removed=!0,null==b){const tmpZ=this.Z;this.Z=Math.max(this.GetZP(coneSide.Start),this.Z-.01),this.coneSideComparer.SetOperand(coneSide),b=this.rightConeSides.remove(coneSide),this.Z=tmpZ}}RemoveSegFromLeftTree(coneSide){coneSide.Removed=!0,this.coneSideComparer.SetOperand(coneSide);if(null==this.leftConeSides.remove(coneSide)){const tmpZ=this.Z;this.Z=Math.max(this.GetZP(coneSide.Start),this.Z-.01),this.coneSideComparer.SetOperand(coneSide),this.leftConeSides.remove(coneSide),this.Z=tmpZ}}FixConeRightSideIntersections(rightSide,rbNode){do{rbNode=this.rightConeSides.previous(rbNode)}while(null!=rbNode&&point_Point.PointToTheLeftOfLineOrOnLine(rightSide.start,rbNode.item.Start,rbNode.item.Start.add(rbNode.item.Direction)));if(null!=rbNode){let intersection;if(rbNode.item instanceof ConeRightSide){const seg=rbNode.item;(intersection=point_Point.IntervalIntersectsRay(rightSide.start,rightSide.End,seg.Start,seg.Direction))&&this.EnqueueEvent(this.CreateRightIntersectionEvent(seg,intersection,rightSide.EndVertex))}}}CreateConeOnVertex(sweepEvent){const cone=new Cone(sweepEvent.Site,this);cone.LeftSide=new ConeLeftSide(cone),cone.RightSide=new ConeRightSide(cone);const leftNode=this.InsertToTree(this.leftConeSides,cone.LeftSide),rightNode=this.InsertToTree(this.rightConeSides,cone.RightSide);this.LookForIntersectionWithConeRightSide(rightNode),this.LookForIntersectionWithConeLeftSide(leftNode)}LookForIntersectionWithConeLeftSide(leftNode){if(leftNode.item instanceof ConeLeftSide){const coneLeftSide=leftNode.item,rightObstacleSide=this.FindFirstObstacleSideToTheLeftOfPoint(coneLeftSide.Start);null!=rightObstacleSide&&this.TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide,rightObstacleSide)}else{const seg=leftNode.item;null!=(leftNode=this.leftConeSides.next(leftNode))&&leftNode.item instanceof ConeLeftSide&&this.TryIntersectionOfConeLeftSideAndObstacleConeSide(leftNode.item,seg)}}LookForIntersectionWithConeRightSide(rightNode){if(rightNode.item instanceof ConeRightSide){const crs=rightNode.item,leftObstacleSide=this.FindFirstObstacleSideToToTheRightOfPoint(crs.Start);null!=leftObstacleSide&&this.TryIntersectionOfConeRightSideAndObstacleSide(crs,leftObstacleSide)}else{const seg=rightNode.item;null!=(rightNode=this.rightConeSides.previous(rightNode))&&rightNode.item instanceof ConeRightSide&&this.TryIntersectionOfConeRightSideAndObstacleConeSide(rightNode.item,seg)}}TryIntersectionOfConeRightSideAndObstacleConeSide(coneRightSide,seg){const x=point_Point.IntervalIntersectsRay(seg.start,seg.End,coneRightSide.Start,coneRightSide.Direction);x&&this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide,x,seg.EndVertex))}TryIntersectionOfConeRightSideAndObstacleSide(coneRightSide,side){const x=point_Point.IntervalIntersectsRay(side.Start,side.End,coneRightSide.Start,coneRightSide.Direction);x&&this.EnqueueEvent(this.CreateRightIntersectionEvent(coneRightSide,x,side.EndVertex))}TryIntersectionOfConeLeftSideAndObstacleConeSide(coneLeftSide,seg){const x=point_Point.IntervalIntersectsRay(seg.start,seg.End,coneLeftSide.Start,coneLeftSide.Direction);x&&this.EnqueueEvent(new LeftIntersectionEvent(coneLeftSide,x,seg.EndVertex))}TryIntersectionOfConeLeftSideAndObstacleSide(coneLeftSide,side){const x=point_Point.IntervalIntersectsRay(side.Start,side.End,coneLeftSide.Start,coneLeftSide.Direction);x&&this.EnqueueEvent(new LeftIntersectionEvent(coneLeftSide,x,side.EndVertex))}Show(curves,fn){let l=Array.from(this.Obstacles).map((o=>debugCurve_DebugCurve.mkDebugCurveTWCI(100,.1,"Blue",o)));for(const s of this.rightConeSides)l.push(debugCurve_DebugCurve.mkDebugCurveWCI(.5,"Brown",this.ExtendSegmentToZ(s))),s instanceof BrokenConeSide&&l.push(debugCurve_DebugCurve.mkDebugCurveCI("brown",LineSweeper.Diamond(s.start))),l.push(debugCurve_DebugCurve.mkDebugCurveWCI(.5,"green",this.ExtendSegmentToZ(s.Cone.LeftSide))),s.Cone.LeftSide instanceof BrokenConeSide&&l.push(debugCurve_DebugCurve.mkDebugCurveCI("green",LineSweeper.Diamond(s.Cone.LeftSide.start)));l=l.concat(curves.map((c=>debugCurve_DebugCurve.mkDebugCurveCI("red",c))))}ExtendSegmentToZ(segment){const den=segment.Direction.dot(this.SweepDirection),t=(this.Z+40-segment.Start.dot(this.SweepDirection))/den;return LineSegment.mkPP(segment.Start,segment.Start.add(segment.Direction.mul(t)))}GoOverConesSeeingVertexEvent(vertexEvent){let rbNode=this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent);if(null==rbNode)return;const cone=rbNode.item.Cone,leftConeSide=cone.LeftSide;if(LineSweeper.VertexIsToTheLeftOfSegment(vertexEvent,leftConeSide))return;const visibleCones=[cone];if(this.coneSideComparer.SetOperand(leftConeSide),rbNode=this.leftConeSides.find(leftConeSide),null==rbNode){const tmpZ=this.Z;this.Z=Math.max(this.GetZP(leftConeSide.Start),this.PreviousZ),this.coneSideComparer.SetOperand(leftConeSide),rbNode=this.leftConeSides.find(leftConeSide),this.Z=tmpZ}if(null!=rbNode||(rbNode=this.GetRbNodeEmergency(rbNode,leftConeSide),null!=rbNode)){for(rbNode=this.leftConeSides.next(rbNode);null!=rbNode&&!LineSweeper.VertexIsToTheLeftOfSegment(vertexEvent,rbNode.item);)visibleCones.push(rbNode.item.Cone),rbNode=this.leftConeSides.next(rbNode);for(const visCone of visibleCones)this.AddEdgeAndRemoveCone(visCone,vertexEvent.Site)}}GetRbNodeEmergency(rbNode,leftConeSide){for(let node=this.leftConeSides.treeMinimum();null!=node;node=this.leftConeSides.next(node))if(node.item==leftConeSide){rbNode=node;break}return rbNode}static VertexIsToTheLeftOfSegment(vertexEvent,seg){return point_Point.getTriangleOrientation(seg.Start,seg.Start.add(seg.Direction),vertexEvent.Site)==point_TriangleOrientation.Counterclockwise}static VertexIsToTheRightOfSegment(vertexEvent,seg){return point_Point.getTriangleOrientation(seg.Start,seg.Start.add(seg.Direction),vertexEvent.Site)==point_TriangleOrientation.Clockwise}FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(vertexEvent){return this.rightConeSides.findFirst((s=>!LineSweeper.VertexIsToTheRightOfSegment(vertexEvent,s)))}EnqueueRightVertexEvent(vertexEvent){this.GetZP(vertexEvent.Site.sub(vertexEvent.Vertex.prevOnPolyline.point))>GeomConstants.tolerance||this.EnqueueEvent(vertexEvent)}invariant(){for(const cs of this.leftConeSides)if(cs.Removed)return!1;for(const cs of this.rightConeSides)if(cs.Removed)return!1;return!0}}LineSweeper.debCount=0;class ConeSpanner extends Algorithm{constructor(obstacles,visibilityGraph){super(null),this.coneAngle=Math.PI/6,this.ports=new PointSet,this._obstacles=Array.from(VisibilityGraph.OrientHolesClockwise(obstacles)),this._visibilityGraph=visibilityGraph}static mk(obstacles,visibilityGraph,coneAngle,ports,borderPolyline){const ret=new ConeSpanner(obstacles,visibilityGraph);return ret.Ports=ports,ret.BorderPolyline=borderPolyline,ret.ConeAngle=coneAngle,ret}get ConeAngle(){return this.coneAngle}set ConeAngle(value){this.coneAngle=value}get Ports(){return this.ports}set Ports(value){this.ports=value}get BorderPolyline(){return this.borderPolyline}set BorderPolyline(value){this.borderPolyline=value}get Bidirectional(){return this._bidirectional}set Bidirectional(value){this._bidirectional=value}static GetTotalSteps(coneAngle){return Math.floor((2*Math.PI-coneAngle/2)/coneAngle)+1}run(){const offset=2*Math.PI-this.coneAngle/2;if(this.Bidirectional)this.HandleBideractionalCase();else{let angle;for(let i=0;(angle=this.coneAngle*i)<=offset;i++)super.ProgressStep(),this.AddDirection(new point_Point(Math.cos(angle),Math.sin(angle)),this.BorderPolyline,this._visibilityGraph)}}HandleBideractionalCase(){const k=Math.PI/this.coneAngle;for(let i=0;i<k;i++){const angle=i*this.coneAngle,vg0=new VisibilityGraph;this.AddDirection(new point_Point(Math.cos(angle),Math.sin(angle)),this.BorderPolyline,vg0);const vg1=new VisibilityGraph;this.AddDirection(new point_Point(-1*Math.cos(angle),-1*Math.sin(angle)),this.BorderPolyline,vg1),this.AddIntersectionOfBothDirectionSweepsToTheResult(vg0,vg1)}}AddIntersectionOfBothDirectionSweepsToTheResult(vg0,vg1){for(const edge of vg0.Edges)null!=vg1.FindEdgePP(edge.SourcePoint,edge.TargetPoint)&&this._visibilityGraph.AddEdgePP(edge.SourcePoint,edge.TargetPoint)}AddDirection(direction,borderPolyline,visibilityGraph){LineSweeper.Sweep(this._obstacles,direction,this.coneAngle,visibilityGraph,this.Ports,borderPolyline)}}class HookUpAnywhereFromInsidePort extends Port{constructor(boundaryCurve){super(),this.adjustmentAngle=Math.PI/10,this.hookSize=9,this.curve=boundaryCurve,this.location=this.curve().start}mk(boundaryCurve,hookSize){const ret=new HookUpAnywhereFromInsidePort(boundaryCurve);return ret.HookSize=hookSize,ret}get Location(){return this.location}get Curve(){return this.curve()}SetLocation(p){this.location=p}get AdjustmentAngle(){return this.adjustmentAngle}set AdjustmentAngle(value){this.adjustmentAngle=value}get HookSize(){return this.hookSize}set HookSize(value){this.hookSize=value}}class ClusterBoundaryPort extends RelativeFloatingPort{constructor(curveDelegate,centerDelegate,locationOffset=new point_Point(0,0)){super(curveDelegate,centerDelegate,locationOffset)}get LoosePolyline(){return this.loosePolyline}set LoosePolyline(value){this.loosePolyline=value}static mk(curveDelegate,centerDelegate){return new ClusterBoundaryPort(curveDelegate,centerDelegate)}}class CurvePort extends Port{get Location(){return this.curve.value(this.parameter)}set Location(value){throw new Error("Method should not be called.")}static mk(curve,parameter){const ret=new CurvePort;return ret.curve=curve,ret.parameter=parameter,ret}get Parameter(){return this.parameter}set Parameter(value){this.parameter=value}get Curve(){return this.curve}set Curve(value){this.curve=value}}class RelativeShape extends Shape{constructor(curveDelegate){super(null),this.curveDelegate=curveDelegate}get BoundaryCurve(){return this.curveDelegate()}set BoundaryCurve(value){if(value)throw new Error("Cannot set BoundaryCurve directly for RelativeShape")}}class ShapeCreatorForRoutingToParents{static GetShapes(inParentEdges,outParentEdges){const nodesToShapes=new Map;for(const edge of inParentEdges)ShapeCreatorForRoutingToParents.ProcessAncestorDescendantCouple(edge.target,edge.source,nodesToShapes),ShapeCreatorForRoutingToParents.InsertEdgePortsToShapes(nodesToShapes,edge);for(const edge of outParentEdges)ShapeCreatorForRoutingToParents.ProcessAncestorDescendantCouple(edge.source,edge.target,nodesToShapes),ShapeCreatorForRoutingToParents.InsertEdgePortsToShapes(nodesToShapes,edge);return ShapeCreatorForRoutingToParents.BindShapes(nodesToShapes),Array.from(nodesToShapes.values())}static InsertEdgePortsToShapes(nodesToShapes,edge){nodesToShapes.get(edge.target).Ports.add(edge.targetPort),nodesToShapes.get(edge.source).Ports.add(edge.sourcePort)}static BindShapes(nodesToShapes){for(const[key,shape]of nodesToShapes){if(!(key instanceof GeomGraph))continue;const cluster=key;for(const child of Children(cluster)){const childShape=nodesToShapes.get(child);childShape&&shape.AddChild(childShape)}}}static ProcessAncestorDescendantCouple(ancestor,geomNode,nodesToShapes){let parent=Parent(geomNode);for(;;){for(const n of Children(parent))ShapeCreatorForRoutingToParents.CreateShapeIfNeeeded(n,nodesToShapes);if(parent==ancestor)break;parent=Parent(parent)}ShapeCreatorForRoutingToParents.CreateShapeIfNeeeded(parent,nodesToShapes)}static CreateShapeIfNeeeded(n,nodesToShapes){nodesToShapes.has(n)||nodesToShapes.set(n,new RelativeShape((()=>n.boundaryCurve)))}static NumberOfActiveNodesIsUnderThreshold(inParentEdges,outParentEdges,threshold){const usedNodeSet=new Set;for(const edge of inParentEdges)if(ShapeCreatorForRoutingToParents.SetOfActiveNodesIsLargerThanThreshold(edge.target,edge.source,usedNodeSet,threshold))return!1;for(const edge of outParentEdges)if(ShapeCreatorForRoutingToParents.SetOfActiveNodesIsLargerThanThreshold(edge.source,edge.target,usedNodeSet,threshold))return!1;return!0}static SetOfActiveNodesIsLargerThanThreshold(ancestor,node,usedNodeSet,threshold){let parent=Parent(node);for(;;){for(const n of Children(parent))if(usedNodeSet.add(n),usedNodeSet.size>threshold)return!0;if(parent==ancestor)break;parent=Parent(parent)}return usedNodeSet.add(parent),usedNodeSet.size>threshold}}function Parent(geomNode){const p=geomNode.node.parent;return GeomObject.getGeom(p)}function*Children(gg){for(const n of gg.graph.shallowNodes)yield GeomObject.getGeom(n)}class ConvexHull{constructor(bodyPoints){this.stamp=0,this.SetPivotAndAllocateHullPointsArray(bodyPoints)}SetPivotAndAllocateHullPointsArray(bodyPoints){this.pivot=new point_Point(0,Number.MAX_SAFE_INTEGER);let pivotIndex=-1,n=0;for(const point of bodyPoints)(point.y<this.pivot.y||point.y==this.pivot.y&&point.x>this.pivot.x)&&(this.pivot=point,pivotIndex=n),n++;if(n>=1){this.hullPoints=new Array(n-1),n=0;for(const point of bodyPoints)n!=pivotIndex?this.hullPoints[n++]={point:point,deleted:!1,stamp:this.stamp++}:pivotIndex=-1}}get StackTopPoint(){return this.stack.point}get StackSecondPoint(){return this.stack.next.point}static*CalculateConvexHull(pointsOfTheBody){const convexHull=new ConvexHull(pointsOfTheBody);for(const p of convexHull.Calculate())yield p}*Calculate(){if(this.pivot.y!=Number.MAX_SAFE_INTEGER)if(0!=this.hullPoints.length){this.SortAllPointsWithoutPivot(),this.Scan();for(const p of this.EnumerateStack())yield p}else yield this.pivot}*EnumerateStack(){let stackCell=this.stack;for(;null!=stackCell;)yield stackCell.point,stackCell=stackCell.next}Scan(){let i=0;for(;this.hullPoints[i].deleted;)i++;for(this.stack={point:this.pivot,next:null},this.Push(i++),i<this.hullPoints.length&&(this.hullPoints[i].deleted?i++:this.Push(i++));i<this.hullPoints.length;)this.hullPoints[i].deleted?i++:this.LeftTurn(i)?this.Push(i++):this.Pop();for(;this.StackHasMoreThanTwoPoints()&&!this.LeftTurnToPivot();)this.Pop()}LeftTurnToPivot(){return point_Point.getTriangleOrientation(this.StackSecondPoint,this.StackTopPoint,this.pivot)==point_TriangleOrientation.Counterclockwise}StackHasMoreThanTwoPoints(){return null!=this.stack.next&&null!=this.stack.next.next}Pop(){this.stack=this.stack.next}LeftTurn(i){if(null==this.stack.next)return!0;const orientation=point_Point.getTriangleOrientationWithIntersectionEpsilon(this.StackSecondPoint,this.StackTopPoint,this.hullPoints[i].point);return orientation==point_TriangleOrientation.Counterclockwise||orientation!=point_TriangleOrientation.Clockwise&&this.BackSwitchOverPivot(this.hullPoints[i].point)}BackSwitchOverPivot(point){return null==this.stack.next.next&&(this.StackTopPoint.x>this.pivot.x+GeomConstants.distanceEpsilon&&point.x<this.pivot.x-GeomConstants.distanceEpsilon)}Push(p){this.stack={point:this.hullPoints[p].point,next:this.stack}}SortAllPointsWithoutPivot(){this.hullPoints.sort(function hullPointComparer(pivot){return(i,j)=>{if(i==j)return 0;if(null==i)return-1;if(null==j)return 1;switch(point_Point.getTriangleOrientationWithIntersectionEpsilon(pivot,i.point,j.point)){case point_TriangleOrientation.Counterclockwise:return-1;case point_TriangleOrientation.Clockwise:return 1;case point_TriangleOrientation.Collinear:const piDelX=i.point.x-pivot.x,pjDelX=j.point.x-pivot.x;if(piDelX>GeomConstants.distanceEpsilon&&pjDelX<-1*GeomConstants.distanceEpsilon)return-1;if(piDelX<-1*GeomConstants.distanceEpsilon&&pjDelX>GeomConstants.distanceEpsilon)return 1;const pi=i.point.sub(pivot),pj=j.point.sub(pivot),iMinJ=pi.l1-pj.l1;return iMinJ<0?(i.deleted=!0,-1):iMinJ>0?(j.deleted=!0,1):(i.stamp>j.stamp?i.deleted=!0:j.deleted=!0,0)}throw new Error}}(this.pivot))}static createConvexHullAsClosedPolyline(points){return Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(points)))}}function CrossRectangleNodes(a,b,action){a.irect.intersects_rect(b.irect)&&(null==a.Left?null==b.Left?action(a.UserData,b.UserData):(CrossRectangleNodes(a,b.Left,action),CrossRectangleNodes(a,b.Right,action)):null!=b.Left?(CrossRectangleNodes(a.Left,b.Left,action),CrossRectangleNodes(a.Left,b.Right,action),CrossRectangleNodes(a.Right,b.Left,action),CrossRectangleNodes(a.Right,b.Right,action)):(CrossRectangleNodes(a.Left,b,action),CrossRectangleNodes(a.Right,b,action)))}function CrossRectangleNodesSameType(a,b,action){a.irect.intersects_rect(b.irect)&&(a==b?function HandleEquality(a,action){if(null==a.Left)return;CrossRectangleNodesSameType(a.Left,a.Left,action),CrossRectangleNodesSameType(a.Left,a.Right,action),CrossRectangleNodesSameType(a.Right,a.Right,action)}(a,action):null==a.Left?null==b.Left?action(a.UserData,b.UserData):(CrossRectangleNodesSameType(a,b.Left,action),CrossRectangleNodesSameType(a,b.Right,action)):null!=b.Left?(CrossRectangleNodesSameType(a.Left,b.Left,action),CrossRectangleNodesSameType(a.Left,b.Right,action),CrossRectangleNodesSameType(a.Right,b.Left,action),CrossRectangleNodesSameType(a.Right,b.Right,action)):(CrossRectangleNodesSameType(a.Left,b,action),CrossRectangleNodesSameType(a.Right,b,action)))}function FindIntersectionWithProperty(a,b,property){if(!a.irect.intersects_rect(b.irect))return!1;if(a==b)return function HandleEqualityCheck(a,func){return null!=a.Left&&(FindIntersectionWithProperty(a.Left,a.Left,func)||FindIntersectionWithProperty(a.Left,a.Right,func)||FindIntersectionWithProperty(a.Right,a.Right,func))}(a,property);if(null==a.Left){if(null==b.Left)return property(a.UserData,b.UserData);if(FindIntersectionWithProperty(a,b.Left,property))return!0;if(FindIntersectionWithProperty(a,b.Right,property))return!0}else if(null!=b.Left){if(FindIntersectionWithProperty(a.Left,b.Left,property))return!0;if(FindIntersectionWithProperty(a.Left,b.Right,property))return!0;if(FindIntersectionWithProperty(a.Right,b.Left,property))return!0;if(FindIntersectionWithProperty(a.Right,b.Right,property))return!0}else{if(FindIntersectionWithProperty(a.Left,b,property))return!0;if(FindIntersectionWithProperty(a.Right,b,property))return!0}return!1}!function(Behavior){Behavior[Behavior.Increasing=0]="Increasing",Behavior[Behavior.Decreasing=1]="Decreasing",Behavior[Behavior.Extremum=2]="Extremum"}(Behavior||(Behavior={}));class UnimodalSequence{constructor(sequenceDelegate,length){this.f=sequenceDelegate,this.length=length}get Sequence(){return this.f}set Sequence(value){this.f=value}get Length(){return this.length}set Length(value){this.length=value}FindMinimum(){let a=0,b=this.length-1,m=a+Math.floor((b-a)/2);const valAtM=this.f(m);if(valAtM>=this.f(0)&&valAtM>=this.f(this.length-1))return this.f(0)<this.f(this.length-1)?0:this.length-1;for(;b-a>1;)switch(m=a+Math.floor((b-a)/2),this.BehaviourAtIndex(m)){case Behavior.Decreasing:a=m;break;case Behavior.Increasing:b=m;break;case Behavior.Extremum:return m}return a==b||this.f(a)<=this.f(b)?a:b}BehaviourAtIndex(m){const seqAtM=this.f(m);if(0==m){const seqAt1=this.f(1);return seqAt1==seqAtM?Behavior.Extremum:seqAt1>seqAtM?Behavior.Increasing:Behavior.Decreasing}if(m==this.length-1){const seqAt1=this.f(this.length-2);return seqAt1==seqAtM?Behavior.Extremum:seqAt1>seqAtM?Behavior.Decreasing:Behavior.Increasing}const delLeft=seqAtM-this.f(m-1);return delLeft*(this.f(m+1)-seqAtM)<=0?Behavior.Extremum:delLeft>0?Behavior.Increasing:Behavior.Decreasing}FindMaximum(){let a=0,b=this.length-1,m=a+Math.floor((b-a)/2);const valAtM=this.f(m);if(valAtM<=this.f(0)&&valAtM<=this.f(this.length-1))return this.f(0)>this.f(this.length-1)?0:this.length-1;for(;b-a>1;)switch(m=a+Math.floor((b-a)/2),this.BehaviourAtIndex(m)){case Behavior.Decreasing:b=m;break;case Behavior.Increasing:a=m;break;case Behavior.Extremum:return m}return a==b||this.f(a)>this.f(b)?a:b}}class BimodalSequence{constructor(sequence,length){this.f=sequence,this.length=length}toArray(){const r=[];for(let i=0;i<this.length;i++)r.push(this.f(i));return r}GetAdjustedSequenceForMinimum(){const leftVal=this.f(0),k=(this.f(this.length-1)-leftVal)/(this.length-1);return i=>Math.min(this.f(i),leftVal+k*i)}GetAdjustedSequenceForMaximum(){const leftVal=this.f(0),k=(this.f(this.length-1)-leftVal)/(this.length-1);return i=>Math.max(this.f(i),leftVal+k*i)}FindMinimum(){return this.f(0)==this.f(this.length-1)?new UnimodalSequence(this.f,this.length).FindMinimum():new UnimodalSequence(this.GetAdjustedSequenceForMinimum(),this.length).FindMinimum()}FindMaximum(){return this.f(0)==this.f(this.length-1)?new UnimodalSequence(this.f,this.length).FindMaximum():new UnimodalSequence(this.GetAdjustedSequenceForMaximum(),this.length).FindMaximum()}}class TangentPair{constructor(polygonP,polygonQ){this.P=polygonP,this.Q=polygonQ}LeftFromLineOnP(vertexIndex,lineStart,lineEnd){const p=this.P.pnt(vertexIndex);return this.upperBranchOnP?point_Point.pointToTheLeftOfLineOrOnLine(lineEnd,p,lineStart):point_Point.pointToTheRightOfLineOrOnLine(lineEnd,p,lineStart)}LeftFromLineOnQ(vertexIndex,lineStart,lineEnd){const point=this.Q.pnt(vertexIndex);return this.lowerBranchOnQ?point_Point.pointToTheLeftOfLineOrOnLine(lineEnd,point,lineStart):point_Point.pointToTheRightOfLineOrOnLine(lineEnd,point,lineStart)}PrevOnP(i){return this.upperBranchOnP?this.P.Prev(i):this.P.Next(i)}PrevOnQ(i){return this.lowerBranchOnQ?this.Q.Prev(i):this.Q.Next(i)}NextOnP(i){return this.upperBranchOnP?this.P.Next(i):this.P.Prev(i)}NextOnQ(i){return this.lowerBranchOnQ?this.Q.Next(i):this.Q.Prev(i)}MedianOnP(i,j){return this.upperBranchOnP?this.P.Median(i,j):this.P.Median(j,i)}MedianOnQ(i,j){return this.lowerBranchOnQ?this.Q.Median(i,j):this.Q.Median(j,i)}ModuleP(p0,p1){return this.upperBranchOnP?this.P.Module(p1-p0):this.P.Module(p0-p1)}ModuleQ(q0,q1){return this.lowerBranchOnQ?this.Q.Module(q1-q0):this.Q.Module(q0-q1)}TangentBetweenBranches(p0,p1,q0,q1){for(;p1!=p0||q1!=q0;){const mp=p1!=p0?this.MedianOnP(p0,p1):p0,mq=q1!=q0?this.MedianOnQ(q0,q1):q0,mpp=this.P.pnt(mp),mqp=this.Q.pnt(mq);let moveOnP=!0;this.ModuleP(p0,p1)>1?this.LeftFromLineOnP(this.NextOnP(mp),mpp,mqp)?p0=mp:this.LeftFromLineOnP(this.PrevOnP(mp),mpp,mqp)?p1=mp:moveOnP=!1:p1!=p0?this.LeftFromLineOnP(p1,this.P.pnt(p0),mqp)?p0=p1:this.LeftFromLineOnP(p0,this.P.pnt(p1),mqp)?p1=p0:moveOnP=!1:moveOnP=!1;let moveOnQ=!0;this.ModuleQ(q0,q1)>1?this.LeftFromLineOnQ(this.NextOnQ(mq),mqp,mpp)?q0=mq:this.LeftFromLineOnQ(this.PrevOnQ(mq),mqp,mpp)?q1=mq:moveOnQ=!1:q1!=q0?this.LeftFromLineOnQ(q1,this.Q.pnt(q0),mpp)?q0=q1:this.LeftFromLineOnQ(q0,this.Q.pnt(q1),mpp)?q1=q0:moveOnQ=!1:moveOnQ=!1,moveOnP||moveOnQ||(p0=mp,p1=mp,q0=mq,q1=mq)}return[p0,q1]}FindDividingBisector(t){const m={pClosest:void 0,qClosest:void 0,p1:void 0,p2:void 0,q1:void 0,q2:void 0};this.FindClosestFeatures(m),t.bisectorPivot=point_Point.middle(m.pClosest,m.qClosest),t.bisectorRay=m.pClosest.add(m.qClosest).rotate(Math.PI/2)}FindClosestPoints(){const m={q2:void 0,p1:void 0,p2:void 0,q1:void 0,pClosest:void 0,qClosest:void 0};return this.FindClosestFeatures(m),{pClosest:m.pClosest,qClosest:m.qClosest}}FindClosestFeatures(m){const r={leftTangentPoint:void 0,rightTangentPoint:void 0};this.P.GetTangentPoints(r,this.Q.pp(0).point),m.p2=r.leftTangentPoint,m.p1=r.rightTangentPoint,m.p2==m.p1&&(m.p2+=this.P.count),this.Q.GetTangentPoints(r,this.P.pp(0).point),m.q1=r.leftTangentPoint,m.q2=r.rightTangentPoint,m.q2==m.q1&&(m.q2+=this.Q.count),this.FindClosestPoints_(m)}FindClosestPoints_(t){for(;this.ChunksAreLong(t.p2,t.p1,t.q2,t.q1);)this.ShrinkChunks(t);t.p1==t.p2?(t.pClosest=this.P.pp(t.p2).point,t.q1==t.q2?t.qClosest=this.Q.pp(t.q1).point:(t.qClosest=point_Point.ClosestPointAtLineSegment(t.pClosest,this.Q.pp(t.q1).point,this.Q.pp(t.q2).point),point_Point.closeDistEps(t.qClosest,this.Q.pnt(t.q1))?t.q2=t.q1:point_Point.closeDistEps(t.qClosest,this.Q.pnt(t.q2))&&(t.q1=t.q2))):(t.qClosest=this.Q.pp(t.q1).point,t.pClosest=point_Point.ClosestPointAtLineSegment(t.qClosest,this.P.pp(t.p1).point,this.P.pp(t.p2).point),point_Point.closeDistEps(t.pClosest,this.P.pnt(t.p1))?t.p2=t.p1:point_Point.closeDistEps(t.qClosest,this.P.pnt(t.p2))&&(t.p1=t.p2))}ChunksAreLong(p2,p1,q2,q1){const pLength=this.P.Module(p2-p1)+1;if(pLength>2)return!0;const qLength=this.Q.Module(q1-q2)+1;return qLength>2||2==pLength&&2==qLength}ShrinkChunks(t){const mp=t.p1==t.p2?t.p1:this.P.Median(t.p1,t.p2),mq=t.q1==t.q2?t.q1:this.Q.Median(t.q2,t.q1),mP=this.P.pp(mp).point,mQ=this.Q.pp(mq).point,angles={a1:void 0,a2:void 0,b1:void 0,b2:void 0};if(this.GetAnglesAtTheMedian(mp,mq,mP,mQ,angles),!this.InternalCut(t,mp,mq,angles.a1,angles.a2,angles.b1,angles.b2)&&!TangentPair.OneOfChunksContainsOnlyOneVertex(t,mp,mq,angles.a1,angles.b1)&&!this.OnlyOneChunkContainsExactlyTwoVertices(t,{mp:mp,mq:mq},angles))if(t.p2!=this.P.Next(t.p1)||t.q1!=this.Q.Next(t.q2))angles.a1<=Math.PI&&angles.a2<=Math.PI&&angles.b1<=Math.PI&&angles.b2<=Math.PI?angles.a1+angles.b1>Math.PI?angles.a1>=Math.PI/2?t.p1=mp:t.q1=mq:angles.a2>=Math.PI/2?t.p2=mp:t.q2=mq:angles.a1>Math.PI?t.p1=mp:angles.a2>Math.PI?t.p2=mp:angles.b1>Math.PI?t.q1=mq:t.q2=mq;else{const md=LineSegment.minDistBetweenLineSegments(this.P.pnt(t.p1),this.P.pnt(t.p2),this.Q.pnt(t.q1),this.Q.pnt(t.q2));0==md.parab?t.p2=t.p1:1==md.parab?t.p1=t.p2:0==md.parcd?t.q2=t.q1:1==md.parcd&&(t.q1=t.q2)}}InternalCut(t,mp,mq,a1,a2,b1,b2){let ret=!1;if(a1>=Math.PI&&a2>=Math.PI){const mpp=this.P.pp(mp).point,mqp=this.Q.pp(mq).point,mpnp=this.P.pp(this.P.Next(mp)).point;point_Point.getTriangleOrientation(mpp,mqp,this.Q.pp(0).point)==point_Point.getTriangleOrientation(mpp,mqp,mpnp)?t.p1=this.P.Next(mp):t.p2=this.P.Prev(mp),ret=!0}if(b1>=Math.PI&&b2>=Math.PI){const mpp=this.P.pp(mp).point,mqp=this.Q.pp(mq).point,mqnp=this.Q.pp(this.Q.Next(mq)).point;point_Point.getTriangleOrientation(mpp,mqp,this.P.pp(0).point)==point_Point.getTriangleOrientation(mpp,mqp,mqnp)?t.q2=this.Q.Next(mq):t.q1=this.Q.Prev(mq),ret=!0}return ret}GetAnglesAtTheMedian(mp,mq,mP,mQ,t){t.a1=point_Point.anglePCP(mQ,mP,this.P.pnt(this.P.Prev(mp))),t.a2=point_Point.anglePCP(this.P.pnt(this.P.Next(mp)),mP,mQ),t.b1=point_Point.anglePCP(this.Q.pnt(this.Q.Next(mq)),mQ,mP),t.b2=point_Point.anglePCP(mP,mQ,this.Q.pnt(this.Q.Prev(mq)))}OnlyOneChunkContainsExactlyTwoVertices(t,l,angles){const pSideIsShort=t.p2==this.P.Next(t.p1),qSideIsShort=t.q1==this.Q.Next(t.q2);return pSideIsShort&&!qSideIsShort?(this.ProcessShortSide(t,l.mp,l.mq,angles.a1,angles.b1,angles.a2,angles.b2),!0):!(!qSideIsShort||pSideIsShort)&&(this.SwapEverything(t,l,angles),this.ProcessShortSide(t,l.mp,l.mq,angles.a1,angles.b1,angles.a2,angles.b2),this.SwapEverything(t,l,angles),!0)}SwapEverything(t,l,angles){this.SwapPq();let u=t.p2;t.p2=t.q1,t.q1=u,u=t.q2,t.q2=t.p1,t.p1=u,u=l.mq,l.mq=l.mp,l.mp=u,u=angles.a2,angles.a2=angles.b1,angles.b1=u,u=angles.b2,angles.b2=angles.a1,angles.a1=u}ProcessShortSide(t,mp,mq,a1,b1,a2,b2){mp==t.p2?this.ProcessSide(t,mq,a1,b1,b2):a2<=Math.PI?a2+b2>=Math.PI?a2>=Math.PI/2?t.p2=t.p1:t.q2=mq:b1>=Math.PI/2?t.q1=mq:a2<b2&&(point_Point.canProject(this.Q.pnt(mq),this.P.pp(t.p1).point,this.P.pp(t.p2).point)?t.q1=mq:t.p1=t.p2):a1+b1<=Math.PI?t.p1=t.p2:t.p2=t.p1}SwapPq(){const t=this.P;this.P=this.Q,this.Q=t}ProcessSide(t,mq,a1,b1,b2){const mQ=this.Q.pnt(mq);a1<=Math.PI?a1+b1>=Math.PI?a1>=Math.PI/2?t.p1=t.p2:t.q1=mq:b2>=Math.PI/2?t.q2=mq:a1<b2&&(point_Point.canProject(mQ,this.P.pp(t.p1).point,this.P.pp(t.p2).point)?t.q2=mq:t.p2=t.p1):(t.p2=t.p1,b1>=Math.PI?t.q1=mq:b2>=Math.PI&&(t.q2=mq))}static OneOfChunksContainsOnlyOneVertex(t,mp,mq,a1,b1){return t.p1==t.p2?(b1>=Math.PI/2?t.q1=mq:t.q2=mq,!0):t.q1==t.q2&&(a1>=Math.PI/2?t.p1=mp:t.p2=mp,!0)}CalculateLeftTangents(){let t;this.FindDividingBisector(t);const pFurthest=this.P.FindTheFurthestVertexFromBisector(t.p1,t.p2,t.bisectorPivot,t.bisectorRay),qFurthest=this.Q.FindTheFurthestVertexFromBisector(t.q2,t.q1,t.bisectorPivot,t.bisectorRay);this.upperBranchOnP=!1,this.lowerBranchOnQ=!0,this.leftPLeftQ=this.TangentBetweenBranches(pFurthest,t.p1,qFurthest,t.q1),this.lowerBranchOnQ=!1,this.leftPRightQ=this.TangentBetweenBranches(pFurthest,t.p1,qFurthest,t.q2)}CalculateRightTangents(){let t;this.FindDividingBisector(t);const pFurthest=this.P.FindTheFurthestVertexFromBisector(t.p1,t.p2,t.bisectorPivot,t.bisectorRay),qFurthest=this.Q.FindTheFurthestVertexFromBisector(t.q2,t.q1,t.bisectorPivot,t.bisectorRay);this.upperBranchOnP=!0,this.lowerBranchOnQ=!0,this.rightPLeftQ=this.TangentBetweenBranches(pFurthest,t.p2,qFurthest,t.q1),this.lowerBranchOnQ=!1,this.rightPRightQ=this.TangentBetweenBranches(pFurthest,t.p2,qFurthest,t.q2)}}class Polygon{constructor(polyline){this.polyline=polyline,this.points=new Array;for(let pp=this.polyline.startPoint;pp;pp=pp.next)this.points.push(pp)}static mkFromPoints(pts){return new Polygon(Polyline.mkClosedFromPoints(pts))}get Polyline(){return this.polyline}Next(i){return this.Module(i+1)}Prev(i){return this.Module(i-1)}get count(){return this.Polyline.count}Module(i){return i<0?i+this.count:i<this.count?i:i-this.count}pp(i){return this.points[this.Module(i)]}pnt(i){return this.pp(i).point}toString(){return this.polyline.toString()}Median(p1,p2){return p2>p1?Math.floor((p2+p1)/2):this.Module(p2+Math.floor((this.count+p1)/2))}FindTheFurthestVertexFromBisector(p1,p2,bisectorPivot,bisectorRay){let directionToTheHill=bisectorRay.rotate(Math.PI/2);this.polyline.startPoint.point.sub(bisectorPivot).dot(directionToTheHill)<0&&(directionToTheHill=directionToTheHill.mul(-1)),p1==p2&&(p2=this.Next(p1));do{const m=this.Median(p2,p1),mp=this.pnt(m);this.pnt(this.Next(m)).sub(mp).dot(directionToTheHill)>=0?p2=this.Next(m):this.pnt(this.Prev(m)).sub(mp).dot(directionToTheHill)>=0?p1=this.Prev(m):p2=m,p1=m}while(p1!=p2);return p1}static TestPolygonDist(a,b){let ret=Number.MAX_SAFE_INTEGER;for(let i=0;i<a.count;i++)for(let j=0;j<b.count;j++){const t=LineSegment.minDistBetweenLineSegments(a.pnt(i),a.pnt(i+1),b.pnt(j),b.pnt(j+1));ret=Math.min(ret,t.dist)}return ret}static Distance(a,b){const pq=new TangentPair(a,b).FindClosestPoints();return{p:pq.pClosest,q:pq.qClosest,dist:pq.pClosest.sub(pq.qClosest).length}}static DistanceOnly(a,b){return Polygon.Distance(a,b).dist}static PolygonIsLegalDebug(a){for(let p=a.Polyline.startPoint;null!=p.next&&null!=p.next.next;p=p.next)if(point_Point.getTriangleOrientation(p.point,p.next.point,p.next.next.point)==point_TriangleOrientation.Collinear)return!1;return!0}static DistancePoint(poly,b){let res=Number.MAX_VALUE;for(let i=0;i<poly.count;i++){const dist=point_Point.distToLineSegment(b,poly.points[i].point,poly.points[(i+1)%poly.count].point).dist;res=Math.min(res,dist)}return res}GetTangentPoints(t,point){const bimodalSequence=new BimodalSequence(this.GetSequenceDelegate(point),this.count);t.leftTangentPoint=bimodalSequence.FindMaximum(),t.rightTangentPoint=bimodalSequence.FindMinimum()}GetSequenceDelegate(point){const pointOfP=this.pnt(0);return i=>{const d=point_Point.anglePCP(pointOfP,point,this.pnt(i));return d<Math.PI?d:d-2*Math.PI}}}class InteractiveObstacleCalculator{constructor(obstacles,tightPadding,loosePadding,ignoreTightPadding){this.Obstacles=obstacles,this.TightPadding=tightPadding,this.LoosePadding=loosePadding,this.IgnoreTightPadding=ignoreTightPadding}ObstaclesIntersectLine(a,b){return this.ObstaclesIntersectICurve(LineSegment.mkPP(a,b))}static PadCorner(poly,p0,p1,p2,padding){const padInfo=InteractiveObstacleCalculator.GetPaddedCorner(p0,p1,p2,padding);return-1!=padInfo.numberOfPoints&&(poly.addPoint(padInfo.a),2==padInfo.numberOfPoints&&poly.addPoint(padInfo.b),!0)}static CurveIsClockwise(iCurve,pointInside){return point_Point.getTriangleOrientation(pointInside,iCurve.start,iCurve.start.add(iCurve.derivative(iCurve.parStart)))==point_TriangleOrientation.Clockwise}static PaddedPolylineBoundaryOfNode(curve,padding){return InteractiveObstacleCalculator.CreatePaddedPolyline(Curve.polylineAroundClosedCurve(curve),padding)}static LoosePolylineWithFewCorners(tightPolyline,p){return p<GeomConstants.distanceEpsilon?tightPolyline:InteractiveObstacleCalculator.CreateLoosePolylineOnBisectors(tightPolyline,p)}static CreateLoosePolylineOnBisectors(tightPolyline,offset){return Polyline.mkClosedFromPoints(ConvexHull.CalculateConvexHull(InteractiveObstacleCalculator.BisectorPoints(tightPolyline,offset)))}static CreateRectNodeOfPolyline(polyline){return mkRectangleNode(polyline,polyline.boundingBox)}CreateLooseObstacles(){this.tightPolylinesToLooseDistances=new Map,this.LooseObstacles=new Array;for(const tightPolyline of this.TightObstacles){const distance=InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(this.RootOfTightHierarchy,tightPolyline,this.LoosePadding);this.tightPolylinesToLooseDistances.set(tightPolyline,distance),this.LooseObstacles.push(InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline,distance))}this.RootOfLooseHierarchy=InteractiveObstacleCalculator.CalculateHierarchy(this.LooseObstacles)}CreateTightObstacles(){this.RootOfTightHierarchy=InteractiveObstacleCalculator.CreateTightObstacles_(this.Obstacles,this.TightPadding,this.TightObstacles),this.OverlapsDetected=this.TightObstacles.size<this.Obstacles.length}Calculate(){this.ignoreTightPadding?this.CreateTightObstaclesIgnoringTightPadding():this.CreateTightObstacles(),this.IsEmpty()||this.CreateLooseObstacles()}IsEmpty(){return null==this.TightObstacles||0==this.TightObstacles.size}ObstaclesIntersectICurve(curve){const rect=curve.boundingBox;return InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve,rect,this.RootOfTightHierarchy)}static CurveIntersectsRectangleNode(curve,curveBox,rectNode){if(!rectNode.irect.intersects(curveBox))return!1;if(null!=rectNode.UserData){const curveUnderTest=rectNode.UserData;return null!=Curve.intersectionOne(curveUnderTest,curve,!1)||InteractiveObstacleCalculator.Inside(curveUnderTest,curve)}return InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve,curveBox,rectNode.Left)||InteractiveObstacleCalculator.CurveIntersectsRectangleNode(curve,curveBox,rectNode.Right)}static Inside(curveUnderTest,curve){return Curve.PointRelativeToCurveLocation(curve.start,curveUnderTest)==PointLocation.Inside}CreateTightObstaclesIgnoringTightPadding(){const polysWithoutPadding=this.Obstacles.map((o=>Curve.polylineAroundClosedCurve(o))),polylineHierarchy=InteractiveObstacleCalculator.CalculateHierarchy(polysWithoutPadding),overlappingPairSet=InteractiveObstacleCalculator.GetOverlappedPairSet(polylineHierarchy);if(this.TightObstacles=new Set,0==overlappingPairSet.size){for(const polyline of polysWithoutPadding){const distance=InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(polylineHierarchy,polyline,this.TightPadding);this.TightObstacles.add(InteractiveObstacleCalculator.LoosePolylineWithFewCorners(polyline,distance))}this.RootOfTightHierarchy=InteractiveObstacleCalculator.CalculateHierarchy(Array.from(this.TightObstacles))}else{for(const poly of polysWithoutPadding)this.TightObstacles.add(InteractiveObstacleCalculator.CreatePaddedPolyline(poly,this.TightPadding));if(!this.IsEmpty())for(this.RootOfTightHierarchy=InteractiveObstacleCalculator.CalculateHierarchy(Array.from(this.TightObstacles)),this.OverlapsDetected=!1;InteractiveObstacleCalculator.GetOverlappedPairSet(this.RootOfTightHierarchy).size>0;)this.RootOfTightHierarchy=InteractiveObstacleCalculator.ReplaceTightObstaclesWithConvexHulls(this.TightObstacles,Array.from(overlappingPairSet)),this.OverlapsDetected=!0}}static CreateTightObstacles_(obstacles,tightPadding,tightObstacleSet){if(0==obstacles.length)return null;for(const curve of obstacles)InteractiveObstacleCalculator.CalculateTightPolyline(tightObstacleSet,tightPadding,curve);return InteractiveObstacleCalculator.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacleSet)}static CalculateTightPolyline(tightObstacles,tightPadding,curve){const tightPoly=InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(curve,tightPadding);tightObstacles.add(tightPoly)}static CalculateHierarchy(polylines){return CreateRectNodeOnArrayOfRectNodes(polylines.map((polyline=>InteractiveObstacleCalculator.CreateRectNodeOfPolyline(polyline))))}static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacleSet){let overlappingPairSet,hierarchy=InteractiveObstacleCalculator.CalculateHierarchy(Array.from(tightObstacleSet));for(;(overlappingPairSet=InteractiveObstacleCalculator.GetOverlappedPairSet(hierarchy)).size>0;)hierarchy=InteractiveObstacleCalculator.ReplaceTightObstaclesWithConvexHulls(tightObstacleSet,Array.from(overlappingPairSet));return hierarchy}static MapToInt(objects){const ret=new Map;for(let i=0;i<objects.length;i++)ret.set(objects[i],i);return ret}static ReplaceTightObstaclesWithConvexHulls(tightObsts,overlappingPairSet){const overlapping=new Set;for(const pair of overlappingPairSet)overlapping.add(pair[0]),overlapping.add(pair[1]);const intToPoly=Array.from(overlapping),polyToInt=InteractiveObstacleCalculator.MapToInt(intToPoly),connectedComponents=GetConnectedComponents(mkGraphOnEdgesArray(Array.from(overlappingPairSet).map((pair=>new IntPair(polyToInt.get(pair[0]),polyToInt.get(pair[1]))))));for(const component of connectedComponents){const polys=component.map((i=>intToPoly[i])),points=flatMap(polys,(p=>Array.from(p))),convexHull=ConvexHull.createConvexHullAsClosedPolyline(points);for(const poly of polys)tightObsts.delete(poly);tightObsts.add(convexHull)}return InteractiveObstacleCalculator.CalculateHierarchy(Array.from(tightObsts))}static OneCurveLiesInsideOfOther(polyA,polyB){return Curve.PointRelativeToCurveLocation(polyA.start,polyB)!=PointLocation.Outside||Curve.PointRelativeToCurveLocation(polyB.start,polyA)!=PointLocation.Outside}static PolylinesIntersect(a,b){return Curve.CurvesIntersect(a,b)||InteractiveObstacleCalculator.OneCurveLiesInsideOfOther(a,b)}static GetOverlappedPairSet(rootOfObstacleHierarchy){const overlappingPairSet=new Set;return CrossRectangleNodesSameType(rootOfObstacleHierarchy,rootOfObstacleHierarchy,((a,b)=>{InteractiveObstacleCalculator.PolylinesIntersect(a,b)&&overlappingPairSet.add([a,b])})),overlappingPairSet}static BisectorPoints(tightPolyline,offset){const ret=new Array;for(let pp=tightPolyline.startPoint;null!=pp;pp=pp.next){const t={skip:!1},currentSticking=InteractiveObstacleCalculator.GetStickingVertexOnBisector(pp,offset,t);t.skip||ret.push(currentSticking)}return ret}static GetStickingVertexOnBisector(pp,p,t){const u=pp.polyline.prev(pp).point,v=pp.point,w=pp.polyline.next(pp).point;let z=v.sub(u).normalize().add(v.sub(w).normalize());const zLen=z.length;return zLen<GeomConstants.tolerance?t.skip=!0:(t.skip=!1,z=z.div(zLen)),z.mul(p).add(v)}static FindMaxPaddingForTightPolyline(hierarchy,polyline,desiredPadding){let dist=desiredPadding;const polygon=new Polygon(polyline),boundingBox=polyline.boundingBox.clone();boundingBox.pad(2*desiredPadding);for(const poly of Array.from(hierarchy.GetNodeItemsIntersectingRectangle(boundingBox)).filter((p=>p!=polyline))){const separation=Polygon.Distance(polygon,new Polygon(poly)).dist;dist=Math.min(dist,separation/InteractiveObstacleCalculator.LooseDistCoefficient)}return dist}static GetPaddedCorner(first,second,third,padding){const u=first.point,v=second.point,w=third.point;if(point_Point.getTriangleOrientation(u,v,w)==point_TriangleOrientation.Counterclockwise)return{a:void 0,b:void 0,numberOfPoints:-1};let uvPerp=v.sub(u).rotate(Math.PI/2).normalize();if(InteractiveObstacleCalculator.CornerIsNotTooSharp(u,v,w)){uvPerp=uvPerp.mul(padding);const vwPerp=w.sub(v).normalize().mul(padding).rotate(Math.PI/2),a=point_Point.lineLineIntersection(u.add(uvPerp),v.add(uvPerp),v.add(vwPerp),w.add(vwPerp));return{a:a,b:a,numberOfPoints:1}}const l=v.sub(u).normalize().add(v.sub(w).normalize());if(l.length<GeomConstants.intersectionEpsilon){const a=v.add(uvPerp.mul(padding));return{a:a,b:a,numberOfPoints:1}}const d=l.normalize().mul(padding),dp=d.rotate(Math.PI/2),xp=(padding-d.dot(uvPerp))/dp.dot(uvPerp),dpxp=dp.mul(xp);return{a:d.add(dpxp).add(v),b:d.sub(dpxp).add(v),numberOfPoints:2}}static CornerIsNotTooSharp(u,v,w){const a=u.sub(v).rotate(Math.PI/4).add(v);return point_Point.getTriangleOrientation(v,a,w)==point_TriangleOrientation.Counterclockwise}static CreatePaddedPolyline(poly,padding){const ret=new Polyline;if(!InteractiveObstacleCalculator.PadCorner(ret,poly.endPoint.prev,poly.endPoint,poly.startPoint,padding))return InteractiveObstacleCalculator.CreatePaddedPolyline(Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(poly))),padding);if(!InteractiveObstacleCalculator.PadCorner(ret,poly.endPoint,poly.startPoint,poly.startPoint.next,padding))return InteractiveObstacleCalculator.CreatePaddedPolyline(Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(poly))),padding);for(let pp=poly.startPoint;null!=pp.next.next;pp=pp.next)if(!InteractiveObstacleCalculator.PadCorner(ret,pp,pp.next,pp.next.next,padding))return InteractiveObstacleCalculator.CreatePaddedPolyline(Polyline.mkClosedFromPoints(Array.from(ConvexHull.CalculateConvexHull(poly))),padding);return ret.closed=!0,ret}}InteractiveObstacleCalculator.LooseDistCoefficient=2.1;class TightLooseCouple{get TightPolyline(){return this.tightPoly}set TightPolyline(value){this.tightPoly=value}static mk(tightPolyline,looseShape,distance){const ret=new TightLooseCouple;return ret.TightPolyline=tightPolyline,ret.LooseShape=looseShape,ret.Distance=distance,ret}toString(){return(null==this.TightPolyline?"null":this.TightPolyline.toString().substring(0,5))+","+(null==this.LooseShape?"null":this.LooseShape.toString().substring(0,5))}}class ShapeObstacleCalculator{constructor(shape,tightPadding,loosePadding,shapesToTightLooseCouples){this.MainShape=shape,this.TightPadding=tightPadding,this.LoosePadding=loosePadding,this.ShapesToTightLooseCouples=shapesToTightLooseCouples}Calculate(){0!=this.MainShape.Children.length&&(this.CreateTightObstacles(),this.CreateTigthLooseCouples(),this.FillTheMapOfShapeToTightLooseCouples())}FillTheMapOfShapeToTightLooseCouples(){CrossRectangleNodes(CreateRectNodeOnArrayOfRectNodes(this.MainShape.Children.map((s=>mkRectangleNode(s,s.BoundingBox)))),this.coupleHierarchy,this.TryMapShapeToTightLooseCouple.bind(this))}TryMapShapeToTightLooseCouple(shape,tightLooseCouple){ShapeObstacleCalculator.ShapeIsInsideOfPoly(shape,tightLooseCouple.TightPolyline)&&this.ShapesToTightLooseCouples.set(shape,tightLooseCouple)}static ShapeIsInsideOfPoly(shape,tightPolyline){return Curve.PointRelativeToCurveLocation(shape.BoundaryCurve.start,tightPolyline)==PointLocation.Inside}CreateTigthLooseCouples(){const couples=new Array;for(const tightPolyline of this.tightHierarchy.GetAllLeaves()){const distance=InteractiveObstacleCalculator.FindMaxPaddingForTightPolyline(this.tightHierarchy,tightPolyline,this.LoosePadding),loosePoly=InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tightPolyline,distance);couples.push(TightLooseCouple.mk(tightPolyline,new Shape(loosePoly),distance))}this.coupleHierarchy=CreateRectNodeOnArrayOfRectNodes(couples.map((c=>mkRectangleNode(c,c.TightPolyline.boundingBox))))}CreateTightObstacles(){const tightObstacles=new Set(this.MainShape.Children.map(this.InitialTightPolyline.bind(this))),initialNumberOfTightObstacles=tightObstacles.size;this.tightHierarchy=InteractiveObstacleCalculator.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacles),this.OverlapsDetected=initialNumberOfTightObstacles>tightObstacles.size}InitialTightPolyline(shape){const poly=InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(shape.BoundaryCurve,this.TightPadding),stickingPointsArray=flatMap(this.LoosePolylinesUnderShape(shape),(p=>Array.from(p))).filter((p=>Curve.PointRelativeToCurveLocation(p,poly)==PointLocation.Outside));if(stickingPointsArray.length<=0)return poly;const pts=Array.from(poly).concat(stickingPointsArray);return Polyline.mkClosedFromPoints(ConvexHull.CalculateConvexHull(pts))}LoosePolylinesUnderShape(shape){return shape.Children.map((child=>this.ShapesToTightLooseCouples.get(child).LooseShape.BoundaryCurve))}}class GenericHeapElement{constructor(index,priority,v){this.indexToA=index,this.priority=priority,this.v=v}}class GenericBinaryHeapPriorityQueue{constructor(compare=compareNumbers){this.heapSize=0,this.compare=compare,this.cache=new Map,this.A=[]}get count(){return this.heapSize}ContainsElement(key){return this.cache.has(key)}SwapWithParent(i){const parent=this.A[i>>1];this.PutAtI(i>>1,this.A[i]),this.PutAtI(i,parent)}Enqueue(element,priority){let i=++this.heapSize;const h=new GenericHeapElement(i,priority,element);for(this.cache.set(element,h),this.A[i]=h;i>1&&this.compare(this.A[i>>1].priority,priority)>0;)this.SwapWithParent(i),i>>=1}IsEmpty(){return 0==this.heapSize}PutAtI(i,h){this.A[i]=h,h.indexToA=i}Dequeue(){if(0==this.heapSize)throw new Error("dequeue on an empty queue");const ret=this.A[1].v;return this.MoveQueueOneStepForward(ret),ret}DequeueAndGetPriority(t){if(0==this.heapSize)throw new Error("dequeue on an empty queue");const ret=this.A[1].v;return t.priority=this.A[1].priority,this.MoveQueueOneStepForward(ret),ret}MoveQueueOneStepForward(ret){this.cache.delete(ret),this.PutAtI(1,this.A[this.heapSize]);let i=1;for(;;){let smallest=i;const l=i<<1;l<=this.heapSize&&this.compare(this.A[l].priority,this.A[i].priority)<0&&(smallest=l);const r=l+1;if(r<=this.heapSize&&this.compare(this.A[r].priority,this.A[smallest].priority)<0&&(smallest=r),smallest==i)break;this.SwapWithParent(smallest),i=smallest}this.heapSize--}DecreasePriority(element,newPriority){const h=this.cache.get(element);if(!h)return;h.priority=newPriority;let i=h.indexToA;for(;i>1&&this.compare(this.A[i].priority,this.A[i>>1].priority)<0;)this.SwapWithParent(i),i>>=1}*GetEnumerator(){for(let i=1;i<=this.heapSize;i++)yield this.A[i].v}Peek(t){if(0!=this.count)return t.priority=this.A[1].priority,this.A[1].v;t.priority=0}toString(){const sb=new dist.fe;for(const i of this.A)sb.Append(i+",");return sb.ToString()}}class SingleSourceMultipleTargetsShortestPathOnVisibilityGraph{constructor(sourceVisVertex,targetVisVertices,visibilityGraph){this.upperBound=Number.POSITIVE_INFINITY,this._visGraph=visibilityGraph,this._visGraph.ClearPrevEdgesTable();for(const v of visibilityGraph.Vertices())v.Distance=Number.POSITIVE_INFINITY;this.source=sourceVisVertex,this.targets=new Set(targetVisVertices),this.source.Distance=0}GetPath(){const pq=new GenericBinaryHeapPriorityQueue(compareNumbers);for(this.source.Distance=0,pq.Enqueue(this.source,0);!pq.IsEmpty()&&(this.current=pq.Dequeue(),!this.targets.has(this.current));){for(const e of this.current.OutEdges)this.PassableOutEdge(e)&&this.ProcessNeighbor(pq,e,e.Target);for(const e of this.current.InEdges)this.PassableInEdge(e)&&this.ProcessNeighbor(pq,e,e.Source)}return null==this._visGraph.PreviosVertex(this.current)?null:this.CalculatePath()}PassableOutEdge(e){return e.Source==this.source||this.targets.has(e.Target)||!SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e)}PassableInEdge(e){return this.targets.has(e.Source)||e.Target==this.source||!SingleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e)}static IsForbidden(e){return null!=e.IsPassable&&!e.IsPassable()||e instanceof TollFreeVisibilityEdge}ProcessNeighbor(pq,l,v){const len=l.Length,c=this.current.Distance+len;c>=this.upperBound||(this.targets.has(v)&&(this.upperBound=c,this.closestTarget=v),v!=this.source&&null==this._visGraph.PreviosVertex(v)?(v.Distance=c,this._visGraph.SetPreviousEdge(v,l),pq.Enqueue(v,c)):c<v.Distance&&(v.Distance=c,this._visGraph.SetPreviousEdge(v,l),pq.DecreasePriority(v,c)))}CalculatePath(){if(null==this.closestTarget)return null;const ret=new Array;let v=this.closestTarget;do{ret.push(v),v=this._visGraph.PreviosVertex(v)}while(v!=this.source);return ret.push(this.source),ret.reverse()}}class SingleSourceSingleTargetShortestPathOnVisibilityGraph{constructor(visGraph,sourceVisVertex,targetVisVertex){this._lengthMultiplier=1,this._lengthMultiplierForAStar=1,this._visGraph=visGraph,this._source=sourceVisVertex,this._target=targetVisVertex,this._source.Distance=0}get LengthMultiplier(){return this._lengthMultiplier}set LengthMultiplier(value){this._lengthMultiplier=value}get LengthMultiplierForAStar(){return this._lengthMultiplierForAStar}set LengthMultiplierForAStar(value){this._lengthMultiplierForAStar=value}GetPath(shrinkEdgeLength){const pq=new GenericBinaryHeapPriorityQueue(compareNumbers);for(this._source.Distance=0,this._target.Distance=Number.POSITIVE_INFINITY,pq.Enqueue(this._source,this.H(this._source));!pq.IsEmpty();){const hu={priority:0},u=pq.DequeueAndGetPriority(hu);if(hu.priority>=this._target.Distance)break;for(const e of u.OutEdges)if(this.PassableOutEdge(e)){const v=e.Target;this.ProcessNeighbor(pq,u,e,v)}for(const e of u.InEdges)if(this.PassableInEdge(e)){const v=e.Source;this.ProcessNeighbor(pq,u,e,v)}}return null==this._visGraph.PreviosVertex(this._target)?null:this.CalculatePath(shrinkEdgeLength)}PassableOutEdge(e){return e.Source==this._source||e.Target==this._target||!SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e)}PassableInEdge(e){return e.Source==this._target||e.Target==this._source||!SingleSourceSingleTargetShortestPathOnVisibilityGraph.IsForbidden(e)}static IsForbidden(e){return null!=e.IsPassable&&!e.IsPassable()||e instanceof TollFreeVisibilityEdge}ProcessNeighborN(pq,u,l,v,penalty){const len=l.Length+penalty,c=u.Distance+len;v!=this._source&&null==this._visGraph.PreviosVertex(v)?(v.Distance=c,this._visGraph.SetPreviousEdge(v,l),v!=this._target&&pq.Enqueue(v,this.H(v))):v!=this._source&&c<v.Distance&&(v.Distance=c,this._visGraph.SetPreviousEdge(v,l),v!=this._target&&pq.DecreasePriority(v,this.H(v)))}ProcessNeighbor(pq,u,l,v){const len=l.Length,c=u.Distance+len;v!=this._source&&null==this._visGraph.PreviosVertex(v)?(v.Distance=c,this._visGraph.SetPreviousEdge(v,l),v!=this._target&&pq.Enqueue(v,this.H(v))):v!=this._source&&c<v.Distance&&(v.Distance=c,this._visGraph.SetPreviousEdge(v,l),v!=this._target&&pq.DecreasePriority(v,this.H(v)))}H(visibilityVertex){return visibilityVertex.Distance+visibilityVertex.point.sub(this._target.point).length*this.LengthMultiplierForAStar}CalculatePath(shrinkEdgeLength){const ret=new Array;let v=this._target;do{ret.push(v),shrinkEdgeLength&&this._visGraph.ShrinkLengthOfPrevEdge(v,this.LengthMultiplier),v=this._visGraph.PreviosVertex(v)}while(v!=this._source);return ret.push(this._source),ret.reverse()}}!function(VisibilityKind){VisibilityKind[VisibilityKind.Regular=0]="Regular",VisibilityKind[VisibilityKind.Tangent=1]="Tangent"}(VisibilityKind||(VisibilityKind={}));class Diagonal{constructor(leftTangent,rightTangent){this.LeftTangent=leftTangent,this.RightTangent=rightTangent}toString(){return dist.Qf.Format("{0},{1}",this.Start,this.End)}get Start(){return this.leftTangent.End.point}get End(){return this.rightTangent.End.point}get LeftTangent(){return this.leftTangent}set LeftTangent(value){this.leftTangent=value}get RightTangent(){return this.rightTangent}set RightTangent(value){this.rightTangent=value}get RbNode(){return this.rbNode}set RbNode(value){this.rbNode=value}}class Tangent{constructor(start,end){this.start=start,this.End=end}get Comp(){return this.comp}set Comp(value){this.comp=value}get IsHigh(){return!this.IsLow}get IsLow(){return this.lowTangent}set IsLow(value){this.lowTangent=value}get SeparatingPolygons(){return this.separatingPolygons}set SeparatingPolygons(value){this.separatingPolygons=value}get Diagonal(){return this.diagonal}set Diagonal(value){this.diagonal=value}get Start(){return this.start}set Start(value){this.start=value}get End(){return this.end}set End(value){this.end=value}toString(){return dist.Qf.Format("{0},{1}",this.Start,this.End)}}class ActiveDiagonalComparerWithRay{get PointOnTangentAndInsertedDiagonal(){return this.pointOnTheRay}set PointOnTangentAndInsertedDiagonal(value){this.pointOnTheRay=value}Compare(x,y){return x.Start.equal(y.Start)?0:point_Point.getTriangleOrientation(this.PointOnTangentAndInsertedDiagonal,y.Start,y.End)===point_TriangleOrientation.Counterclockwise?-1:1}static BelongsToTheDiagonal(IntersectionOfTheRayAndInsertedEdge,start,end){return point_Point.closeDistEps(IntersectionOfTheRayAndInsertedEdge,point_Point.ClosestPointAtLineSegment(IntersectionOfTheRayAndInsertedEdge,start,end))}static IntersectDiagonalWithRay(pivot,pointOnRay,diagonal){const ray=pointOnRay.sub(pivot),source=diagonal.Start,target=diagonal.End,result=LinearSystem2.solve(target.x-source.x,-1*ray.x,pivot.x-source.x,target.y-source.y,-1*ray.y,pivot.y-source.y);return pivot.add(ray.mul(result.y))}}class StemStartPointComparer{constructor(p){this.pivot=p}IComparer(i,j){if(i==j)return 0;if(null==i)return-1;if(null==j)return 1;const a=i.Start.point.sub(this.pivot),b=j.Start.point.sub(this.pivot);return StemStartPointComparer.CompareVectorsByAngleToXAxis(a,b)}static CompareVectorsByAngleToXAxis(a,b){return a.y>=0?b.y<0?-1:StemStartPointComparer.CompareVectorsPointingToTheSameYHalfPlane(a,b):b.y>=0?1:StemStartPointComparer.CompareVectorsPointingToTheSameYHalfPlane(a,b)}static CompareVectorsPointingToTheSameYHalfPlane(a,b){const sign=a.x*b.y-a.y*b.x;if(sign>GeomConstants.tolerance)return-1;if(sign<-GeomConstants.tolerance)return 1;if(a.x>=0){if(b.x<0)return-1}else if(b.x>=0)return 1;let del=Math.abs(a.x)-Math.abs(b.x);return del<0?-1:del>0?1:(del=Math.abs(a.y)-Math.abs(b.y),del<0?-1:del>0?1:0)}}class InteractiveTangentVisibilityGraphCalculator extends Algorithm{constructor(holes,addedPolygons,visibilityGraph){super(null),this.activeDiagonalComparer=new ActiveDiagonalComparerWithRay,this.polygons=holes,this.visibilityGraph=visibilityGraph,this.addedPolygons=addedPolygons}run(){this.useLeftPTangents=!0,this.CalculateAndAddEdges(),this.useLeftPTangents=!1,this.CalculateAndAddEdges()}CalculateAndAddEdges(){for(const p of this.addedPolygons)this.CalculateVisibleTangentsFromPolygon(p);this.ProgressStep()}CalculateVisibleTangentsFromPolygon(polygon){this.currentPolygon=polygon,this.AllocateDataStructures(),this.OrganizeTangents(),this.InitActiveDiagonals(),this.Sweep()}AllocateDataStructures(){this.tangents=new Array,this.diagonals=new Array,this.activeDiagonalTree=new RBTree(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer))}Sweep(){if(!(this.tangents.length<2))for(let i=1;i<this.tangents.length;i++){const t=this.tangents[i];null!=t.Diagonal?(t.Diagonal.RbNode==this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(t),t.IsHigh&&this.RemoveDiagonalFromActiveNodes(t.Diagonal)):t.IsLow&&(this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal=t.End.point,this.InsertActiveDiagonal(new Diagonal(t,t.Comp)),t.Diagonal.RbNode==this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(t))}}AddVisibleEdge(t){VisibilityGraph.AddEdgeVV(getVertex(this.visibilityGraph,t.start),getVertex(this.visibilityGraph,t.End))}InitActiveDiagonals(){if(0==this.tangents.length)return;const firstTangent=this.tangents[0],firstTangentStart=firstTangent.start.point,firstTangentEnd=firstTangent.End.point;for(const diagonal of this.diagonals)if(InteractiveTangentVisibilityGraphCalculator.RayIntersectDiagonal(firstTangentStart,firstTangentEnd,diagonal)&&(this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal=ActiveDiagonalComparerWithRay.IntersectDiagonalWithRay(firstTangentStart,firstTangentEnd,diagonal),this.InsertActiveDiagonal(diagonal)),firstTangent.Diagonal.RbNode==this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(firstTangent),0==firstTangent.IsLow){const diag=firstTangent.Diagonal;this.RemoveDiagonalFromActiveNodes(diag)}}RemoveDiagonalFromActiveNodes(diag){const changedNode=this.activeDiagonalTree.deleteSubTree(diag.RbNode);null!=changedNode&&null!=changedNode.item&&(changedNode.item.RbNode=changedNode),diag.LeftTangent.Diagonal=null,diag.RightTangent.Diagonal=null}InsertActiveDiagonal(diagonal){diagonal.RbNode=this.activeDiagonalTree.insert(diagonal),InteractiveTangentVisibilityGraphCalculator.MarkDiagonalAsActiveInTangents(diagonal)}static MarkDiagonalAsActiveInTangents(diagonal){diagonal.LeftTangent.Diagonal=diagonal,diagonal.RightTangent.Diagonal=diagonal}static RayIntersectDiagonal(pivot,pointOnRay,diagonal){const a=diagonal.Start,b=diagonal.End;return point_Point.getTriangleOrientation(pivot,a,b)==point_TriangleOrientation.Counterclockwise&&point_Point.getTriangleOrientation(pivot,pointOnRay,a)!=point_TriangleOrientation.Counterclockwise&&point_Point.getTriangleOrientation(pivot,pointOnRay,b)!=point_TriangleOrientation.Clockwise}static TangentComparison(e0,e1){return StemStartPointComparer.CompareVectorsByAngleToXAxis(e0.End.point.sub(e0.start.point),e1.End.point.sub(e1.start.point))}*AllObstacles(){for(const p of this.addedPolygons)yield p;for(const p of this.polygons)yield p}OrganizeTangents(){for(const q of this.AllObstacles())q!=this.currentPolygon&&this.ProcessPolygonQ(q);this.tangents.sort(InteractiveTangentVisibilityGraphCalculator.TangentComparison)}ProcessPolygonQ(q){const tangentPair=new TangentPair(this.currentPolygon,q);this.useLeftPTangents?tangentPair.CalculateLeftTangents():tangentPair.CalculateRightTangents();let couple=this.useLeftPTangents?tangentPair.leftPLeftQ:tangentPair.rightPLeftQ;const t0=new Tangent(this.currentPolygon.pp(couple[0]),q.pp(couple[1]));t0.IsLow=!0,t0.SeparatingPolygons=!this.useLeftPTangents,couple=this.useLeftPTangents?tangentPair.leftPRightQ:tangentPair.rightPRightQ;const t1=new Tangent(this.currentPolygon.pp(couple[0]),q.pp(couple[1]));t1.IsLow=!1,t1.SeparatingPolygons=this.useLeftPTangents,t0.Comp=t1,t1.Comp=t0,this.tangents.push(t0),this.tangents.push(t1),this.diagonals.push(new Diagonal(t0,t1))}}function getVertex(vg,pp){return vg.FindVertex(pp.point)}class ActiveEdgeComparerWithRay{get Pivot(){return this.pivot}set Pivot(value){this.pivot=value}get IntersectionOfTheRayAndInsertedEdge(){return this.pointOnTheRay}set IntersectionOfTheRayAndInsertedEdge(value){this.pointOnTheRay=value}Compare(x,y){return point_Point.getTriangleOrientation(this.IntersectionOfTheRayAndInsertedEdge,y.point,y.nextOnPolyline.point)===point_TriangleOrientation.Counterclockwise?-1:1}IntersectionPointBelongsToTheInsertedEdge(x){const a=x.point.sub(this.IntersectionOfTheRayAndInsertedEdge),b=x.nextOnPolyline.point.sub(this.IntersectionOfTheRayAndInsertedEdge);return Math.abs(a.x*b.y-b.x*a.y)<GeomConstants.distanceEpsilon}IntersectEdgeWithRayPPP(source,target,ray){const result=LinearSystem2.solve(target.x-source.x,-ray.x,this.Pivot.x-source.x,target.y-source.y,-ray.y,this.Pivot.y-source.y);if(!(-GeomConstants.tolerance<=result.x&&result.x<=1+GeomConstants.tolerance))throw new Error;if(!result)throw new Error;return this.Pivot.add(ray.mul(result.y))}IntersectEdgeWithRay(side,ray){return this.IntersectEdgeWithRayPPP(side.point,side.nextOnPolyline.point,ray)}static constructorPP(pivot,pointOnTheRay){const r=new ActiveEdgeComparerWithRay;return r.pivot=pivot,r.pointOnTheRay=pointOnTheRay,r}}class Stem{constructor(start,end){this.start=start,this.end=end}get Start(){return this.start}set Start(value){this.start=value}get End(){return this.end}set End(value){this.end=value}*Sides(){let v=this.start;for(;v!=this.end;){const side=v;yield side,v=side.nextOnPolyline}}MoveStartClockwise(){return this.Start!=this.End&&(this.Start=this.Start.nextOnPolyline,!0)}toString(){return dist.Qf.Format("Stem({0},{1})",this.Start,this.End)}}class PointVisibilityCalculator{constructor(holes,visibilityGraph,point,visibilityKind){this.sideNodes=new Map,this.visibleBoundaries=new Map,this.sortedListOfPolypoints=new Array,this.holes=Array.from(holes),this.visibilityGraph=visibilityGraph,this.q=point,this.qPolylinePoint=PolylinePoint.mkFromPoint(this.q),this.QVertex=this.visibilityGraph.AddVertexP(this.qPolylinePoint.point),this.visibilityKind=visibilityKind;const comp=new StemStartPointComparer(this.q);this.heapForSorting=new BinaryHeapWithComparer(comp.IComparer.bind(comp))}get QVertex(){return this.qV}set QVertex(value){this.qV=value}static CalculatePointVisibilityGraph(listOfHoles,visibilityGraph,point,visibilityKind){const qv=visibilityGraph.FindVertex(point);if(null!=qv)return qv;const calculator=new PointVisibilityCalculator(listOfHoles,visibilityGraph,point,visibilityKind);return calculator.FillGraph(),calculator.QVertex}FillGraph(){this.ComputeHoleBoundariesPossiblyVisibleFromQ(),this.visibleBoundaries.size>0&&(this.SortSAndInitActiveSides(),this.Sweep())}SortSAndInitActiveSides(){this.InitHeapAndInsertActiveSides();for(let stem=this.heapForSorting.GetMinimum();this.sortedListOfPolypoints.push(stem.Start),stem.MoveStartClockwise()?this.heapForSorting.ChangeMinimum(stem):this.heapForSorting.Dequeue(),0!=this.heapForSorting.Count;stem=this.heapForSorting.GetMinimum());}InitHeapAndInsertActiveSides(){for(const pp of this.GetInitialVisibleBoundaryStemsAndInsertActiveSides())this.heapForSorting.Enqueue(pp)}*GetInitialVisibleBoundaryStemsAndInsertActiveSides(){for(const[hole,stem]of this.visibleBoundaries){let crosses=!1;for(const side of stem.Sides()){const source=side;if(source.point.y<this.q.y){if(side.nextOnPolyline.point.y>=this.q.y){const orientation=point_Point.getTriangleOrientation(this.q,source.point,side.nextOnPolyline.point);if(orientation==point_TriangleOrientation.Counterclockwise||orientation==point_TriangleOrientation.Collinear){crosses=!0,yield new Stem(stem.Start,side),yield new Stem(side.nextOnPolyline,stem.End),this.RegisterActiveSide(side);break}}}else{if(source.point.y>this.q.y)break;if(side.point.x>=this.q.x){crosses=!0,yield new Stem(side,stem.End),side!=stem.Start&&(yield new Stem(stem.Start,hole.prev(source))),this.RegisterActiveSide(side);break}}}crosses||(yield stem)}}RegisterActiveSide(side){this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge=this.activeEdgeComparer.IntersectEdgeWithRay(side,new point_Point(1,0)),this.sideNodes.set(side,this.activeSidesTree.insert(side))}Sweep(){for(const polylinePoint of this.sortedListOfPolypoints)this.SweepPolylinePoint(polylinePoint)}SweepPolylinePoint(v){const inSide=PointVisibilityCalculator.GetIncomingSide(v),outSide=this.GetOutgoingSide(v);let node;if(this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge=v.point,node=this.sideNodes.get(inSide)){if(node==this.activeSidesTree.treeMinimum()&&this.AddEdge(v),null!=outSide)node.item=outSide,this.sideNodes.set(outSide,node);else{const changedNode=this.activeSidesTree.deleteSubTree(node);null!=changedNode&&null!=changedNode.item&&this.sideNodes.set(changedNode.item,changedNode)}this.sideNodes.delete(inSide)}else{if(null==outSide)throw new Error;{let outsideNode;(outsideNode=this.sideNodes.get(outSide))||(outsideNode=this.activeSidesTree.insert(outSide),this.sideNodes.set(outSide,outsideNode),outsideNode==this.activeSidesTree.treeMinimum()&&this.AddEdge(v))}}}AddEdge(v){(this.visibilityKind==VisibilityKind.Regular||this.visibilityKind==VisibilityKind.Tangent&&PointVisibilityCalculator.LineTouchesPolygon(this.QVertex.point,v))&&this.visibilityGraph.AddEdgeF(this.QVertex.point,v.point,((a,b)=>new TollFreeVisibilityEdge(a,b)))}static LineTouchesPolygon(a,p){const prev=p.polyline.prev(p).point,next=p.polyline.next(p).point,v=p.point;return point_Point.signedDoubledTriangleArea(a,v,prev)*point_Point.signedDoubledTriangleArea(a,v,next)>=0}GetOutgoingSide(v){return v==this.visibleBoundaries.get(v.polyline).End?null:v}static GetIncomingSide(v){return v.prevOnPolyline}ComputeHoleBoundariesPossiblyVisibleFromQ(){this.InitActiveEdgesAndActiveEdgesComparer();for(const hole of this.holes)this.ComputeVisiblePartOfTheHole(hole)}InitActiveEdgesAndActiveEdgesComparer(){this.activeEdgeComparer=new ActiveEdgeComparerWithRay,this.activeEdgeComparer.pivot=this.q,this.activeSidesTree=new RBTree(this.activeEdgeComparer.Compare.bind(this.activeEdgeComparer))}ComputeVisiblePartOfTheHole(hole){let a,needToGoCounterclockWise=!0;for(a=hole.startPoint;!this.HoleSideIsVisibleFromQ(hole,a);a=hole.next(a))needToGoCounterclockWise=!1;let b=hole.next(a);if(needToGoCounterclockWise)for(;this.HoleSideIsVisibleFromQ(hole,hole.prev(a));)a=hole.prev(a);for(;this.HoleSideIsVisibleFromQ(hole,b);b=hole.next(b));this.visibleBoundaries.set(hole,new Stem(a,b))}HoleSideIsVisibleFromQ(hole,b){return point_Point.signedDoubledTriangleArea(this.q,b.point,hole.next(b).point)>=-GeomConstants.squareOfDistanceEpsilon}}class RelaxedPolylinePoint{constructor(polylinePoint,originalPosition){this.next=null,this.prev=null,this.PolylinePoint=polylinePoint,this.OriginalPosition=originalPosition}get PolylinePoint(){return this.polylinePoint}set PolylinePoint(value){this.polylinePoint=value}get OriginalPosition(){return this.originalPosition}set OriginalPosition(value){this.originalPosition=value}get Next(){return this.next}set Next(value){this.next=value}get Prev(){return this.prev}set Prev(value){this.prev=value}}class InteractiveEdgeRouter extends Algorithm{constructor(){super(...arguments),this.IgnoreTightPadding=!1,this.activeRectangle=Rectangle.mkEmpty(),this.activePolygons=new Array,this.alreadyAddedOrExcludedPolylines=new Set,this.UseEdgeLengthMultiplier=!1,this.UseInnerPolylingShortcutting=!0,this.UsePolylineEndShortcutting=!0,this.AllowedShootingStraightLines=!0,this.LookForRoundedVertices=!1}get Obstacles(){return this.obstacles_}set Obstacles(value){this.obstacles_=value}get EnteringAngleBound(){return this.enteringAngleBound_}set EnteringAngleBound(value){this.enteringAngleBound_=value}get SourceTightPolyline(){return this._sourceTightPolyline}set SourceTightPolyline(value){this._sourceTightPolyline=value}get TargetTightPolyline(){return this.targetTightPolyline}set TargetTightPolyline(value){this.targetTightPolyline=value}get TargetLoosePolyline(){return this.targetLoosePolyline}set TargetLoosePolyline(value){this.targetLoosePolyline=value}get VisibilityGraph(){return this.visibilityGraph}set VisibilityGraph(value){this.visibilityGraph=value}get SourcePort(){return this.sourcePort}set SourcePort(value){if(this.sourcePort=value,null!=this.sourcePort)if(this.SourceTightPolyline=InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.sourcePort instanceof FloatingPort)this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline),this.StartPointOfEdgeRouting=this.SourcePort.Location;else{const bp=this.sourcePort;this.StartPointOfEdgeRouting=this.TakeBoundaryPortOutsideOfItsLoosePolyline(bp.Curve,bp.Parameter,this.SourceLoosePolyline)}}get TargetPort(){return this.targetPort}set TargetPort(value){this.targetPort=value}get LoosePadding(){return this.loosePadding}set LoosePadding(value){this.loosePadding=value,null!=this.ObstacleCalculator&&(this.ObstacleCalculator.LoosePadding=value)}get StartPointOfEdgeRouting(){return this.startPointOfRouting_}set StartPointOfEdgeRouting(value){this.startPointOfRouting_=value}ExtendVisibilityGraphToLocation(location){null==this.VisibilityGraph&&(this.VisibilityGraph=new VisibilityGraph);let addedPolygons=null;if(!this.activeRectangle.contains(location)){this.activeRectangle.isEmpty?this.activeRectangle=Rectangle.mkPP(this.SourcePort.Location,location):this.activeRectangle.add(location),addedPolygons=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(const polygon of addedPolygons)this.VisibilityGraph.AddHole(polygon.Polyline)}if(null==addedPolygons||0==addedPolygons.length)null!=this.targetVV&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraph(location);else{this.RemovePointVisibilityGraphs();new InteractiveTangentVisibilityGraphCalculator(addedPolygons,this.activePolygons,this.VisibilityGraph).run(),addRange(this.activePolygons,addedPolygons),this.CalculateEdgeTargetVisibilityGraph(location),this.CalculateSourcePortVisibilityGraph()}}RemovePointVisibilityGraphs(){null!=this.targetVV&&this.VisibilityGraph.RemoveVertex(this.targetVV),null!=this.sourceVV&&this.VisibilityGraph.RemoveVertex(this.sourceVV)}CalculateEdgeTargetVisibilityGraph(location){this.targetVV=PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()),this.VisibilityGraph,location,VisibilityKind.Tangent)}CalculateSourcePortVisibilityGraph(){this.sourceVV=PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()),this.VisibilityGraph,this.StartPointOfEdgeRouting,VisibilityKind.Tangent)}TakeBoundaryPortOutsideOfItsLoosePolyline(nodeBoundary,parameter,loosePolyline){const location=nodeBoundary.value(parameter);let tangent=nodeBoundary.leftDerivative(parameter).normalize().add(nodeBoundary.rightDerivative(parameter).normalize()).normalize();point_Point.getTriangleOrientation(InteractiveEdgeRouter.PointInsideOfConvexCurve(nodeBoundary),location,location.add(tangent))==point_TriangleOrientation.Counterclockwise&&(tangent=tangent.mul(-1)),tangent=tangent.rotate(Math.PI/2);const len=loosePolyline.boundingBox.diagonal;let ls=LineSegment.mkPP(location,location.add(tangent.mul(len)));const p=Curve.intersectionOne(ls,loosePolyline,!1).x;let del=tangent.mul(p.sub(location).length/2);for(;;){ls=LineSegment.mkPP(location,p.add(del));let foundIntersectionsOutsideOfSource=!1;for(const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls,this.ObstacleCalculator.RootOfLooseHierarchy))if(ii.seg1!=loosePolyline){del=del.div(1.5),foundIntersectionsOutsideOfSource=!0;break}if(!foundIntersectionsOutsideOfSource)break}return ls.end}static PointInsideOfConvexCurve(nodeBoundary){return nodeBoundary.value(0).add(nodeBoundary.value(1.5)).div(2)}*GetActivePolylines(){for(const polygon of this.activePolygons)yield polygon.Polyline}GetAddedPolygonesAndMaybeExtendActiveRectangle(){const rect=this.activeRectangle,addedPolygones=new Array;let added;do{added=!1;for(const loosePoly of this.ObstacleCalculator.RootOfLooseHierarchy.GetNodeItemsIntersectingRectangle(this.activeRectangle))this.alreadyAddedOrExcludedPolylines.has(loosePoly)||(rect.addRec(loosePoly.boundingBox),addedPolygones.push(new Polygon(loosePoly)),this.alreadyAddedOrExcludedPolylines.add(loosePoly),added=!0);added&&(this.activeRectangle=rect)}while(added);return addedPolygones}RelaxPolyline(){let relaxedPolylinePoint=InteractiveEdgeRouter.CreateRelaxedPolylinePoints(this._polyline);for(relaxedPolylinePoint=relaxedPolylinePoint.Next;null!=relaxedPolylinePoint.Next;relaxedPolylinePoint=relaxedPolylinePoint.Next)this.RelaxPolylinePoint(relaxedPolylinePoint)}static CreateRelaxedPolylinePoints(polyline){let p=polyline.startPoint;const ret=new RelaxedPolylinePoint(p,p.point);let currentRelaxed=ret;for(;null!=p.next;){p=p.next;const r=new RelaxedPolylinePoint(p,p.point);r.Prev=currentRelaxed,currentRelaxed.Next=r,currentRelaxed=r}return ret}RelaxPolylinePoint(relaxedPoint){if(!(null==relaxedPoint.PolylinePoint.prev.prev&&this.SourcePort instanceof CurvePort&&relaxedPoint.PolylinePoint.polyline!=this.SourceLoosePolyline||null==relaxedPoint.PolylinePoint.next.next&&this.TargetPort instanceof CurvePort&&relaxedPoint.PolylinePoint.polyline!=this.TargetLoosePolyline))for(let d=this.OffsetForPolylineRelaxing;d>GeomConstants.distanceEpsilon&&!this.RelaxWithGivenOffset(d,relaxedPoint);)d/=2}RelaxWithGivenOffset(offset,relaxedPoint){return InteractiveEdgeRouter.SetRelaxedPointLocation(offset,relaxedPoint),!!this.StickingSegmentDoesNotIntersectTightObstacles(relaxedPoint)||(InteractiveEdgeRouter.PullCloserRelaxedPoint(relaxedPoint.Prev),!1)}static PullCloserRelaxedPoint(relaxedPolylinePoint){relaxedPolylinePoint.PolylinePoint.point=relaxedPolylinePoint.OriginalPosition.mul(.2).add(relaxedPolylinePoint.PolylinePoint.point.mul(.8))}StickingSegmentDoesNotIntersectTightObstacles(relaxedPoint){return!(this.PolylineSegmentIntersectsTightHierarchy(relaxedPoint.PolylinePoint.point,relaxedPoint.Prev.PolylinePoint.point)||null!=relaxedPoint.Next&&this.PolylineSegmentIntersectsTightHierarchy(relaxedPoint.PolylinePoint.point,relaxedPoint.Next.PolylinePoint.point))}PolylineSegmentIntersectsTightHierarchy(a,b){return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(a,b,this.ObstacleCalculator.RootOfTightHierarchy)}PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(a,b,rect){return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(LineSegment.mkPP(a,b),rect)}PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls,rect){if(!ls.boundingBox.intersects(rect.irect))return!1;if(null!=rect.UserData){for(const ii of Curve.getAllIntersections(ls,rect.UserData,!1)){if(ii.seg1!=this.SourceTightPolyline&&ii.seg1!=this.TargetTightPolyline)return!0;if((ii.seg1==this.SourceTightPolyline&&this.SourcePort)instanceof CurvePort)return!0;if((ii.seg1==this.TargetTightPolyline&&this.TargetPort)instanceof CurvePort)return!0}return!1}return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls,rect.Left)||this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(ls,rect.Right)}static IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls,rectNode){const ret=new Array;return InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls,rectNode,ret),ret}static IntersectionsOfLineAndRectangleNodeOverPolyline(ls,rectNode,listOfIntersections){null!=rectNode&&ls.boundingBox.intersects(rectNode.irect)&&(null==rectNode.UserData?(InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls,rectNode.Left,listOfIntersections),InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolyline(ls,rectNode.Right,listOfIntersections)):addRange(listOfIntersections,Curve.getAllIntersections(ls,rectNode.UserData,!0)))}LineCanBeAcceptedForRouting(ls){const sourceIsFloating=this.SourcePort instanceof FloatingPort,targetIsFloating=this.TargetPort instanceof FloatingPort;if(!sourceIsFloating&&!this.targetIsInsideOfSourceTightPolyline&&!this.InsideOfTheAllowedConeOfBoundaryPort(ls.end,this.SourcePort))return!1;if(!targetIsFloating&&null!=this.TargetPort&&!this.sourceIsInsideOfTargetTightPolyline&&!this.InsideOfTheAllowedConeOfBoundaryPort(ls.start,this.TargetPort))return!1;const xx=InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls,this.ObstacleCalculator.RootOfTightHierarchy);for(const ii of xx)if(ii.seg1!=this.SourceTightPolyline&&ii.seg1!=this.targetTightPolyline)return!1;return!0}InsideOfTheAllowedConeOfBoundaryPort(pointToTest,port){const boundaryCurve=port.Curve,curveIsClockwise=InteractiveObstacleCalculator.CurveIsClockwise(boundaryCurve,InteractiveEdgeRouter.PointInsideOfConvexCurve(boundaryCurve)),portLocation=port.Location,pointOnTheRightConeSide=this.GetPointOnTheRightBoundaryPortConeSide(portLocation,boundaryCurve,curveIsClockwise,port.Parameter),pointOnTheLeftConeSide=this.GetPointOnTheLeftBoundaryPortConeSide(portLocation,boundaryCurve,curveIsClockwise,port.Parameter);return point_Point.getTriangleOrientation(portLocation,pointOnTheRightConeSide,pointToTest)!=point_TriangleOrientation.Clockwise&&point_Point.getTriangleOrientation(portLocation,pointToTest,pointOnTheLeftConeSide)!=point_TriangleOrientation.Clockwise}GetPointOnTheRightBoundaryPortConeSide(portLocation,boundaryCurve,curveIsClockwise,portParam){const tan=curveIsClockwise?boundaryCurve.rightDerivative(portParam):boundaryCurve.leftDerivative(portParam).neg();return portLocation.add(tan.rotate(this.EnteringAngleBound))}GetPointOnTheLeftBoundaryPortConeSide(portLocation,boundaryCurve,curveIsClockwise,portParam){const tan=curveIsClockwise?boundaryCurve.leftDerivative(portParam).neg():boundaryCurve.rightDerivative(portParam);return portLocation.add(tan.rotate(-this.EnteringAngleBound))}static SetRelaxedPointLocation(offset,relaxedPoint){const leftTurn=point_Point.getTriangleOrientation(relaxedPoint.Next.OriginalPosition,relaxedPoint.OriginalPosition,relaxedPoint.Prev.OriginalPosition)==point_TriangleOrientation.Counterclockwise;let v=relaxedPoint.Next.OriginalPosition.sub(relaxedPoint.Prev.OriginalPosition).normalize().mul(offset).rotate(Math.PI/2);leftTurn||(v=v.neg()),relaxedPoint.PolylinePoint.point=relaxedPoint.OriginalPosition.add(v)}SmoothCorners(edgePolyline){let a=edgePolyline.headSite,corner={b:null,c:null};for(;corner=Curve.findCorner(a);)a=this.SmoothOneCorner(a,corner.c,corner.b)}SmoothOneCorner(a,c,b){let seg,v,u,k=.5;null==a.prev?(u=2,v=1):null==c.next?(u=1,v=2):v=1,u=1;do{seg=Curve.createBezierSeg(k*u,k*v,a,b,c),b.previouisBezierCoefficient=k*u,b.nextBezierCoefficient=k*v,k/=1.5}while(this.ObstacleCalculator.ObstaclesIntersectICurve(seg)&&k>.01);return k*=1.5,k<.5&&k>.01&&(k=.5*(k+1.5*k),seg=Curve.createBezierSeg(k*u,k*v,a,b,c),this.ObstacleCalculator.ObstaclesIntersectICurve(seg)||(b.previouisBezierCoefficient=k*u,b.nextBezierCoefficient=k*v)),b}TryToRemoveInflectionsAndCollinearSegments(underlyingPolyline){let progress=!0;const t={s:null};for(;progress;)for(progress=!1,t.s=underlyingPolyline.headSite;null!=t.s&&null!=t.s.next;t.s=t.s.next)t.s.turn*t.s.next.turn<0&&(progress=this.TryToRemoveInflectionEdge(t)||progress)}TryToRemoveInflectionEdge(t){if(!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point,t.s.next.point)){const a=t.s.prev,b=t.s.next;return a.next=b,b.prev=a,t.s=a,!0}if(!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point,t.s.next.next.point)){const a=t.s.prev,b=t.s.next.next;return a.next=b,b.prev=a,t.s=a,!0}if(!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.point,t.s.next.next.point)){const b=t.s.next.next;return t.s.next=b,b.prev=t.s,!0}return!1}GetShortestPolyline(sourceVisVertex,_targetVisVertex){this.CleanTheGraphForShortestPath();const path=new SingleSourceSingleTargetShortestPathOnVisibilityGraph(this.visibilityGraph,sourceVisVertex,_targetVisVertex).GetPath(this.UseEdgeLengthMultiplier);if(null==path)return null;const ret=new Polyline;for(const v of path)ret.addPoint(v.point);return InteractiveEdgeRouter.RemoveCollinearVertices(ret)}CleanTheGraphForShortestPath(){this.visibilityGraph.ClearPrevEdgesTable()}static RemoveCollinearVertices(ret){for(let pp=ret.startPoint.next;null!=pp.next;pp=pp.next)point_Point.getTriangleOrientation(pp.prev.point,pp.point,pp.next.point)==point_TriangleOrientation.Collinear&&(pp.prev.next=pp.next,pp.next.prev=pp.prev);return ret}get OverlapsDetected(){return this.ObstacleCalculator.OverlapsDetected}get TightHierarchy(){return this.ObstacleCalculator.RootOfTightHierarchy}set TightHierarchy(value){this.ObstacleCalculator.RootOfTightHierarchy=value}get LooseHierarchy(){return this.ObstacleCalculator.RootOfLooseHierarchy}set LooseHierarchy(value){this.ObstacleCalculator.RootOfLooseHierarchy=value}CalculateObstacles(){this.ObstacleCalculator=new InteractiveObstacleCalculator(this.Obstacles,this.TightPadding,this.LoosePadding,this.IgnoreTightPadding),this.ObstacleCalculator.Calculate()}RouteEdgeToLocation(targetLocation){this.TargetPort=new FloatingPort(null,targetLocation),this.TargetTightPolyline=null,this.TargetLoosePolyline=null;const edge=new GeomEdge(null);let ls=LineSegment.mkPP(this.SourcePort.Location,targetLocation);return this.LineCanBeAcceptedForRouting(ls)?(this._polyline=new Polyline,this._polyline.addPoint(ls.start),this._polyline.addPoint(ls.end),edge.smoothedPolyline=SmoothedPolyline.mkFromPoints(this._polyline),edge.curve=edge.smoothedPolyline.createCurve(),edge):this.SourcePort instanceof CurvePort&&(ls=LineSegment.mkPP(this.StartPointOfEdgeRouting,targetLocation),0==InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls,this.ObstacleCalculator.RootOfTightHierarchy).length)?(this._polyline=new Polyline,this._polyline.addPoint(this.SourcePort.Location),this._polyline.addPoint(ls.start),this._polyline.addPoint(ls.end),edge.smoothedPolyline=SmoothedPolyline.mkFromPoints(this._polyline),edge.curve=edge.smoothedPolyline.createCurve(),edge):(this.ExtendVisibilityGraphToLocation(targetLocation),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this.RelaxPolyline(),this.SourcePort instanceof CurvePort&&this._polyline.PrependPoint(this.SourcePort.Location),edge.smoothedPolyline=SmoothedPolyline.mkFromPoints(this._polyline),edge.curve=edge.smoothedPolyline.createCurve(),edge)}RouteEdgeToPort(edgeTargetPort,portLoosePolyline,smooth,t){return this.ObstacleCalculator.IsEmpty()?null!=this.sourcePort&&null!=this.targetPort?(t.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(this.sourcePort.Location,this.targetPort.Location),LineSegment.mkPP(this.sourcePort.Location,this.targetPort.Location)):null:(this.TargetPort=edgeTargetPort,this.TargetTightPolyline=InteractiveEdgeRouter.GetFirstHitPolyline(edgeTargetPort.Location,this.ObstacleCalculator.RootOfTightHierarchy),edgeTargetPort instanceof CurvePort?this.RouteEdgeToBoundaryPort(portLoosePolyline,smooth,t):this.RouteEdgeToFloatingPortOfNode(portLoosePolyline,smooth,t))}SmoothedPolylineFromTwoPoints(s,e){return this._polyline=new Polyline,this._polyline.addPoint(s),this._polyline.addPoint(e),SmoothedPolyline.mkFromPoints(this._polyline)}RouteEdgeToFloatingPortOfNode(portLoosePolyline,smooth,t){return this.sourcePort instanceof FloatingPort?this.RouteFromFloatingPortToFloatingPort(portLoosePolyline,smooth,t):this.RouteFromBoundaryPortToFloatingPort(portLoosePolyline,smooth,t)}RouteFromBoundaryPortToFloatingPort(targetPortLoosePolyline,smooth,t){const sourcePortLocation=this.SourcePort.Location,targetPortLocation=this.targetPort.Location;let ls=LineSegment.mkPP(sourcePortLocation,targetPortLocation);if(this.LineCanBeAcceptedForRouting(ls))return t.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(ls.start,ls.end),ls;if(!this.targetIsInsideOfSourceTightPolyline){const takenOutPoint=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve,this.SourcePort.Parameter,this.SourceLoosePolyline);if(ls=LineSegment.mkPP(takenOutPoint,targetPortLocation),this.LineAvoidsTightHierarchyLP(ls,targetPortLoosePolyline))return t.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(ls.start,ls.end),ls}this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(targetPortLoosePolyline),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV);const tmp=this.SourceTightPolyline;return this.targetIsInsideOfSourceTightPolyline||(this.SourceTightPolyline=null),this.TryShortcutPolyline(),this.SourceTightPolyline=tmp,this.RelaxPolyline(),this._polyline.PrependPoint(sourcePortLocation),this.SmoothCornersAndReturnCurve(smooth,t)}SmoothCornersAndReturnCurve(smooth,t){return t.smoothedPolyline=SmoothedPolyline.mkFromPoints(this._polyline),smooth&&this.SmoothCorners(t.smoothedPolyline),t.smoothedPolyline.createCurve()}RouteFromFloatingPortToFloatingPort(portLoosePolyline,smooth,t){const targetPortLocation=this.TargetPort.Location,ls=LineSegment.mkPP(this.StartPointOfEdgeRouting,targetPortLocation);return this.AllowedShootingStraightLines&&this.LineAvoidsTightHierarchyLPP(ls,this.SourceTightPolyline,this.targetTightPolyline)?(t.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(ls.start,ls.end),ls):(this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(portLoosePolyline),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),null==this._polyline?null:(this.UseSpanner&&this.TryShortcutPolyline(),this.RelaxPolyline(),t.smoothedPolyline=SmoothedPolyline.mkFromPoints(this._polyline),this.SmoothCornersAndReturnCurve(smooth,t)))}TryShortcutPolyline(){if(this.UseInnerPolylingShortcutting)for(;this.ShortcutPolylineOneTime(););this.UsePolylineEndShortcutting&&this.TryShortCutThePolylineEnds()}TryShortCutThePolylineEnds(){this.TryShortcutPolylineStart(),this.TryShortcutPolylineEnd()}TryShortcutPolylineEnd(){const a=this._polyline.endPoint,b=a.prev;if(null==b)return;const c=b.prev;if(null==c)return;const m=point_Point.middle(b.point,c.point);if(this.LineAvoidsTightHierarchyPPPP(a.point,m,this._sourceTightPolyline,this.targetTightPolyline)){const p=PolylinePoint.mkFromPoint(m);p.next=a,p.prev=c,a.prev=p,c.next=p}}TryShortcutPolylineStart(){const a=this._polyline.startPoint,b=a.next;if(null==b)return;const c=b.next;if(null==c)return;const m=point_Point.middle(b.point,c.point);if(this.LineAvoidsTightHierarchyPPPP(a.point,m,this._sourceTightPolyline,this.targetTightPolyline)){const p=PolylinePoint.mkFromPoint(m);p.prev=a,p.next=c,a.next=p,c.prev=p}}ShortcutPolylineOneTime(){let ret=!1;for(let pp=this._polyline.startPoint;null!=pp.next&&null!=pp.next.next;pp=pp.next)ret=ret||this.TryShortcutPolyPoint(pp);return ret}TryShortcutPolyPoint(pp){return!!this.LineAvoidsTightHierarchyLPP(LineSegment.mkPP(pp.point,pp.next.next.point),this.SourceTightPolyline,this.targetTightPolyline)&&(pp.next=pp.next.next,pp.next.prev=pp,!0)}ExtendVisibilityGraphToLocationOfTargetFloatingPort(portLoosePolyline){null==this.VisibilityGraph&&(this.VisibilityGraph=new VisibilityGraph);let addedPolygons=null;const targetLocation=this.targetPort.Location;if(!this.activeRectangle.contains(targetLocation)){this.activeRectangle.isEmpty?this.activeRectangle=Rectangle.mkPP(this.SourcePort.Location,targetLocation):this.activeRectangle.add(targetLocation),addedPolygons=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(const polygon of addedPolygons)this.VisibilityGraph.AddHole(polygon.Polyline)}if(null==addedPolygons)null!=this.targetVV&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation,portLoosePolyline),null==this.sourceVV&&this.CalculateSourcePortVisibilityGraph();else{this.RemovePointVisibilityGraphs();new InteractiveTangentVisibilityGraphCalculator(addedPolygons,this.activePolygons,this.VisibilityGraph).run(),addRange(this.activePolygons,addedPolygons),this.CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation,portLoosePolyline),this.CalculateSourcePortVisibilityGraph()}}CalculateEdgeTargetVisibilityGraphForFloatingPort(targetLocation,targetLoosePoly){this.UseSpanner?this.targetVV=this.AddTransientVisibilityEdgesForPort(targetLocation,targetLoosePoly):this.targetVV=PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(targetLoosePoly),this.VisibilityGraph,targetLocation,VisibilityKind.Tangent)}AddTransientVisibilityEdgesForPort(point,loosePoly){let v=this.GetVertex(point);if(null!=v)return v;if(v=this.visibilityGraph.AddVertexP(point),null!=loosePoly)for(const p of loosePoly)this.visibilityGraph.AddEdgeF(point,p,((a,b)=>new TollFreeVisibilityEdge(a,b)));else v=PointVisibilityCalculator.CalculatePointVisibilityGraph(this.GetActivePolylines(),this.VisibilityGraph,point,VisibilityKind.Tangent);return v}GetVertex(point){let v=this.visibilityGraph.FindVertex(point);return null==v&&this.LookForRoundedVertices&&(v=this.visibilityGraph.FindVertex(GeomConstants.RoundPoint(point))),v}*GetActivePolylinesWithException(targetLoosePoly){for(const polygon of this.activePolygons)polygon.Polyline!=targetLoosePoly&&(yield polygon.Polyline)}RouteEdgeToBoundaryPort(portLoosePolyline,smooth,t){return this.TargetLoosePolyline=portLoosePolyline,this.sourcePort instanceof FloatingPort?this.RouteFromFloatingPortToBoundaryPort(smooth,t):this.RouteFromBoundaryPortToBoundaryPort(smooth,t)}RouteFromBoundaryPortToBoundaryPort(smooth,t){const sourcePortLocation=this.SourcePort.Location;let curve;const targetPortLocation=this.targetPort.Location;let ls=LineSegment.mkPP(sourcePortLocation,targetPortLocation);if(this.LineCanBeAcceptedForRouting(ls))this._polyline=new Polyline,this._polyline.addPoint(ls.start),this._polyline.addPoint(ls.end),t.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(ls.start,ls.end),curve=SmoothedPolyline.mkFromPoints(this._polyline).createCurve();else{const takenOutPoint=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.Curve,this.targetPort.Parameter,this.TargetLoosePolyline);if(ls=LineSegment.mkPP(sourcePortLocation,takenOutPoint),this.InsideOfTheAllowedConeOfBoundaryPort(takenOutPoint,this.SourcePort)&&this.LineAvoidsTightHierarchyLP(ls,this._sourceTightPolyline))this._polyline=new Polyline,this._polyline.addPoint(ls.start),this._polyline.addPoint(ls.end),this._polyline.addPoint(targetPortLocation),curve=this.SmoothCornersAndReturnCurve(smooth,t);else if(ls=LineSegment.mkPP(this.StartPointOfEdgeRouting,targetPortLocation),this.InsideOfTheAllowedConeOfBoundaryPort(this.StartPointOfEdgeRouting,this.TargetPort)&&this.LineAvoidsTightHierarchy(ls))this._polyline=new Polyline,this._polyline.addPoint(sourcePortLocation),this._polyline.addPoint(ls.start),this._polyline.addPoint(ls.end),curve=this.SmoothCornersAndReturnCurve(smooth,t);else{let x;if(x=LineSegment.IntersectPPPP(sourcePortLocation,this.StartPointOfEdgeRouting,targetPortLocation,takenOutPoint))this._polyline=new Polyline,this._polyline.addPoint(sourcePortLocation),this._polyline.addPoint(x),this._polyline.addPoint(targetPortLocation),curve=this.SmoothCornersAndReturnCurve(smooth,t);else if(point_Point.closeDistEps(this.StartPointOfEdgeRouting,takenOutPoint))this._polyline=new Polyline,this._polyline.addPoint(sourcePortLocation),this._polyline.addPoint(takenOutPoint),this._polyline.addPoint(targetPortLocation),curve=this.SmoothCornersAndReturnCurve(smooth,t);else if(this.LineAvoidsTightHierarchy(LineSegment.mkPP(this.StartPointOfEdgeRouting,takenOutPoint)))this._polyline=new Polyline,this._polyline.addPoint(sourcePortLocation),this._polyline.addPoint(this.StartPointOfEdgeRouting),this._polyline.addPoint(takenOutPoint),this._polyline.addPoint(targetPortLocation),curve=this.SmoothCornersAndReturnCurve(smooth,t);else{this.ExtendVisibilityGraphToTargetBoundaryPort(takenOutPoint),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV);const r={tmpTargetTight:null},tmpSourceTight=this.HideSourceTargetTightsIfNeeded(r);this.TryShortcutPolyline(),this.RecoverSourceTargetTights(tmpSourceTight,r.tmpTargetTight),this.RelaxPolyline(),this._polyline.PrependPoint(sourcePortLocation),this._polyline.addPoint(targetPortLocation),curve=this.SmoothCornersAndReturnCurve(smooth,t)}}}return curve}RecoverSourceTargetTights(tmpSourceTight,tmpTargetTight){this.SourceTightPolyline=tmpSourceTight,this.TargetTightPolyline=tmpTargetTight}HideSourceTargetTightsIfNeeded(t){const tmpSourceTight=this.SourceTightPolyline;return t.tmpTargetTight=this.TargetTightPolyline,this.TargetTightPolyline=null,this.SourceTightPolyline=null,tmpSourceTight}LineAvoidsTightHierarchy(lineSegment){return 0==InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(lineSegment,this.ObstacleCalculator.RootOfTightHierarchy).length}RouteFromFloatingPortToBoundaryPort(smooth,r){const targetPortLocation=this.targetPort.Location;let ls;if(this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.Location,this.targetPort)&&(ls=LineSegment.mkPP(this.SourcePort.Location,targetPortLocation),this.LineCanBeAcceptedForRouting(ls)))return r.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(ls.start,ls.end),ls;const takenOutTargetPortLocation=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.TargetPort.Curve,this.TargetPort.Parameter,this.TargetLoosePolyline);if(ls=LineSegment.mkPP(this.SourcePort.Location,takenOutTargetPortLocation),this.LineAvoidsTightHierarchyLP(ls,this._sourceTightPolyline))return this._polyline=Polyline.mkFromPoints([ls.start,ls.end,targetPortLocation]),r.smoothedPolyline=SmoothedPolyline.mkFromPoints(this._polyline),r.smoothedPolyline.createCurve();this.ExtendVisibilityGraphToTargetBoundaryPort(takenOutTargetPortLocation),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this.RelaxPolyline(),this._polyline.addPoint(targetPortLocation);return this.SmoothCornersAndReturnCurve(smooth,{smoothedPolyline:null})}LineAvoidsTightHierarchyLP(ls,polylineToExclude){let lineIsGood=!0;for(const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls,this.ObstacleCalculator.RootOfTightHierarchy))if(ii.seg1!=polylineToExclude){lineIsGood=!1;break}return lineIsGood}LineAvoidsTightHierarchyLPP(ls,polylineToExclude0,polylineToExclude1){let lineIsGood=!0;for(const ii of InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(ls,this.ObstacleCalculator.RootOfTightHierarchy))if(ii.seg1!=polylineToExclude0&&ii.seg1!=polylineToExclude1){lineIsGood=!1;break}return lineIsGood}LineAvoidsTightHierarchyPPPP(a,b,polylineToExclude0,polylineToExclude1){return this.LineAvoidsTightHierarchyLPP(LineSegment.mkPP(a,b),polylineToExclude0,polylineToExclude1)}ExtendVisibilityGraphToTargetBoundaryPort(takenOutTargetPortLocation){let addedPolygons=null;if(null==this.VisibilityGraph&&(this.VisibilityGraph=new VisibilityGraph),!this.activeRectangle.contains(takenOutTargetPortLocation)||!this.activeRectangle.containsRect(this.TargetLoosePolyline.boundingBox)){this.activeRectangle.isEmpty?(this.activeRectangle=this.TargetLoosePolyline.boundingBox.clone(),this.activeRectangle.add(this.SourcePort.Location),this.activeRectangle.add(this.StartPointOfEdgeRouting),this.activeRectangle.add(takenOutTargetPortLocation)):(this.activeRectangle.add(takenOutTargetPortLocation),this.activeRectangle.addRec(this.TargetLoosePolyline.boundingBox)),addedPolygons=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(const polygon of addedPolygons)this.VisibilityGraph.AddHole(polygon.Polyline)}if(null==addedPolygons)null!=this.targetVV&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraph(takenOutTargetPortLocation);else{this.RemovePointVisibilityGraphs();new InteractiveTangentVisibilityGraphCalculator(addedPolygons,this.activePolygons,this.VisibilityGraph).run(),addRange(this.activePolygons,addedPolygons),this.CalculateEdgeTargetVisibilityGraph(takenOutTargetPortLocation),this.CalculateSourcePortVisibilityGraph()}}GetHitLoosePolyline(point){return this.ObstacleCalculator.IsEmpty()||null==this.ObstacleCalculator.RootOfLooseHierarchy?null:InteractiveEdgeRouter.GetFirstHitPolyline(point,this.ObstacleCalculator.RootOfLooseHierarchy)}static GetFirstHitPolyline(point,rectangleNode){const rectNode=InteractiveEdgeRouter.GetFirstHitRectangleNode(point,rectangleNode);return rectNode?rectNode.UserData:null}static GetFirstHitRectangleNode(point,rectangleNode){return null==rectangleNode?null:rectangleNode.FirstHitNodePF(point,((pnt,polyline)=>Curve.PointRelativeToCurveLocation(pnt,polyline)!=PointLocation.Outside?HitTestBehavior.Stop:HitTestBehavior.Continue))}Clean(){this.TargetPort=null,this.SourcePort=null,this.SourceTightPolyline=null,this.SourceLoosePolyline=null,this.TargetLoosePolyline=null,this.targetTightPolyline=null,this.VisibilityGraph=null,this.targetVV=null,this.sourceVV=null,this.activePolygons=[],this.alreadyAddedOrExcludedPolylines.clear(),this.activeRectangle.setToEmpty()}SetSourcePortAndSourceLoosePolyline(port,sourceLoosePolylinePar){this.SourceLoosePolyline=sourceLoosePolylinePar,this.sourcePort=port,null!=this.sourcePort&&(this.SourceTightPolyline=InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.sourcePort instanceof FloatingPort?(this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline),this.StartPointOfEdgeRouting=this.SourcePort.Location):this.StartPointOfEdgeRouting=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve,this.sourcePort.Parameter,this.SourceLoosePolyline))}run(){this.CalculateWholeTangentVisibilityGraph()}CalculateWholeTangentVisibilityGraph(){this.VisibilityGraph=new VisibilityGraph,this.CalculateWholeVisibilityGraphOnExistingGraph()}CalculateWholeVisibilityGraphOnExistingGraph(){this.activePolygons=Array.from(this.AllPolygons());for(const polylineLocal of this.ObstacleCalculator.LooseObstacles)this.VisibilityGraph.AddHole(polylineLocal);let visibilityGraphGenerator;visibilityGraphGenerator=this.UseSpanner?new ConeSpanner(this.ObstacleCalculator.LooseObstacles,this.VisibilityGraph):new InteractiveTangentVisibilityGraphCalculator(new Array,this.activePolygons,this.visibilityGraph),visibilityGraphGenerator.run()}RouteSplineFromPortToPortWhenTheWholeGraphIsReady(sourcePortLocal,targetPortLocal,smooth,t){const reversed=sourcePortLocal instanceof FloatingPort&&targetPortLocal instanceof CurvePort||sourcePortLocal instanceof HookUpAnywhereFromInsidePort;if(reversed){const tmp=sourcePortLocal;sourcePortLocal=targetPortLocal,targetPortLocal=tmp}this.sourcePort=sourcePortLocal,this.targetPort=targetPortLocal,this.FigureOutSourceTargetPolylinesAndActiveRectangle();let curve=this.GetEdgeGeomByRouting(smooth,t);return null==curve?null:(this.targetVV=null,this.sourceVV=null,reversed&&(curve=curve.reverse()),curve)}GetEdgeGeomByRouting(smooth,t){let curve;if(this.targetIsInsideOfSourceTightPolyline=null==this.SourceTightPolyline||Curve.PointRelativeToCurveLocation(this.targetPort.Location,this.SourceTightPolyline)==PointLocation.Inside,this.sourceIsInsideOfTargetTightPolyline=null==this.TargetTightPolyline||Curve.PointRelativeToCurveLocation(this.sourcePort.Location,this.TargetTightPolyline)==PointLocation.Inside,this.sourcePort instanceof CurvePort){const curvePort=this.sourcePort;this.StartPointOfEdgeRouting=this.targetIsInsideOfSourceTightPolyline?curvePort.Location:this.TakeBoundaryPortOutsideOfItsLoosePolyline(curvePort.Curve,curvePort.Parameter,this.SourceLoosePolyline),this.CalculateSourcePortVisibilityGraph();const t={smoothedPolyline:null};curve=this.targetPort instanceof CurvePort?this.RouteFromBoundaryPortToBoundaryPort(smooth,t):this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline,smooth,t)}else this.targetPort instanceof FloatingPort?(this.ExtendVisibilityGraphFromFloatingSourcePort(),curve=this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline,smooth,t)):curve=this.RouteFromFloatingPortToAnywherePort(this.targetPort.LoosePolyline,smooth,t,this.targetPort);return curve}RouteFromFloatingPortToAnywherePort(targetLoosePoly,smooth,t,port){return port.Curve.boundingBox.contains(this.sourcePort.Location)?(this.sourceVV=this.GetVertex(this.sourcePort.Location),this._polyline=this.GetShortestPolylineToMulitpleTargets(this.sourceVV,Array.from(this.Targets(targetLoosePoly))),null==this._polyline?null:(this.UseSpanner&&this.TryShortcutPolyline(),this.RelaxPolyline(),this.FixLastPolylinePointForAnywherePort(port),port.HookSize>0&&this.BuildHook(port),this.SmoothCornersAndReturnCurve(smooth,t))):(t.smoothedPolyline=null,null)}BuildHook(port){const curve=port.Curve,ellipse=Ellipse.mkFullEllipseNNP(port.HookSize,port.HookSize,this._polyline.end),intersections=Curve.getAllIntersections(curve,ellipse,!0);point_Point.getTriangleOrientation(intersections[0].x,this._polyline.end,this._polyline.endPoint.prev.point)==point_TriangleOrientation.Counterclockwise&&intersections.reverse();const polylineTangent=this._polyline.end.sub(this._polyline.endPoint.prev.point).normalize(),tan0=curve.derivative(intersections[0].par0).normalize(),prj0=tan0.dot(polylineTangent);if(Math.abs(prj0)<.2)this.ExtendPolyline(tan0,intersections[0],polylineTangent,port);else{const tan1=curve.derivative(intersections[1].par0).normalize();tan1.dot(polylineTangent)<prj0?this.ExtendPolyline(tan1,intersections[1],polylineTangent,port):this.ExtendPolyline(tan0,intersections[0],polylineTangent,port)}}ExtendPolyline(tangentAtIntersection,x,polylineTangent,port){let normal=tangentAtIntersection.rotate(Math.PI/2);normal.dot(polylineTangent)<0&&(normal=normal.neg());const pointBeforeLast=x.x.add(normal.mul(port.HookSize));let pointAfterX;(pointAfterX=point_Point.lineLineIntersection(pointBeforeLast,pointBeforeLast.add(tangentAtIntersection),this._polyline.end,this._polyline.end.add(polylineTangent)))&&(this._polyline.addPoint(pointAfterX),this._polyline.addPoint(pointBeforeLast),this._polyline.addPoint(x.x))}FixLastPolylinePointForAnywherePort(port){for(;;){const lastPointInside=this.GetLastPointInsideOfCurveOnPolyline(port.Curve);lastPointInside.next.next=null,this._polyline.endPoint=lastPointInside.next;let dir=lastPointInside.next.point.sub(lastPointInside.point);dir=dir.normalize().mul(port.Curve.boundingBox.diagonal);const dir0=dir.rotate(-1*port.AdjustmentAngle),dir1=dir.rotate(port.AdjustmentAngle),rx=Curve.intersectionOne(port.Curve,LineSegment.mkPP(lastPointInside.point,lastPointInside.point.add(dir0)),!0),lx=Curve.intersectionOne(port.Curve,LineSegment.mkPP(lastPointInside.point,lastPointInside.point.add(dir1)),!0);if(null==rx||null==lx)return;const trimmedCurve=InteractiveEdgeRouter.GetTrimmedCurveForHookingUpAnywhere(port.Curve,lastPointInside,rx,lx),newLastPoint=trimmedCurve.value(trimmedCurve.closestParameter(lastPointInside.point));if(!this.LineAvoidsTightHierarchyLPP(LineSegment.mkPP(lastPointInside.point,newLastPoint),this.SourceTightPolyline,null)){const xx=Curve.intersectionOne(port.Curve,LineSegment.mkPP(lastPointInside.point,lastPointInside.next.point),!1);if(null==xx)return;this._polyline.endPoint.point=xx.x;break}if(this._polyline.endPoint.point=newLastPoint,null==lastPointInside.prev||!this.TryShortcutPolyPoint(lastPointInside.prev))break}}static GetTrimmedCurveForHookingUpAnywhere(curve,lastPointInside,x0,x1){const clockwise=point_Point.getTriangleOrientation(x1.x,x0.x,lastPointInside.point)==point_TriangleOrientation.Clockwise,rightX=x0.par0,leftX=x1.par0;let tr1,tr0,ret;return clockwise?rightX<leftX?curve.trim(rightX,leftX):(tr0=curve.trim(rightX,curve.parEnd),tr1=curve.trim(curve.parStart,leftX),ret=new Curve,ret.addSegs([tr0,tr1])):leftX<rightX?curve.trim(leftX,rightX):(tr0=curve.trim(leftX,curve.parEnd),tr1=curve.trim(curve.parStart,rightX),ret=new Curve,ret.addSegs([tr0,tr1]))}GetLastPointInsideOfCurveOnPolyline(curve){for(let p=this._polyline.endPoint.prev;null!=p;p=p.prev){if(null==p.prev)return p;if(Curve.PointRelativeToCurveLocation(p.point,curve)==PointLocation.Inside)return p}throw new Error}GetShortestPolylineToMulitpleTargets(sourceVisVertex,targets){this.CleanTheGraphForShortestPath();const path=new SingleSourceMultipleTargetsShortestPathOnVisibilityGraph(sourceVisVertex,targets,this.VisibilityGraph).GetPath();if(null==path)return null;const ret=new Polyline;for(const v of path)ret.addPoint(v.point);return InteractiveEdgeRouter.RemoveCollinearVertices(ret)}Targets(targetLoosePoly){return Array.from(targetLoosePoly).map((p=>this.visibilityGraph.FindVertex(p)))}ExtendVisibilityGraphFromFloatingSourcePort(){const fp=this.sourcePort;this.StartPointOfEdgeRouting=fp.Location,this.UseSpanner?this.sourceVV=this.AddTransientVisibilityEdgesForPort(this.sourcePort.Location,this.SourceLoosePolyline):this.sourceVV=PointVisibilityCalculator.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()).filter((p=>p!=this.SourceLoosePolyline)),this.VisibilityGraph,this.StartPointOfEdgeRouting,VisibilityKind.Tangent)}FigureOutSourceTargetPolylinesAndActiveRectangle(){this._sourceTightPolyline=InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.SourceLoosePolyline=InteractiveEdgeRouter.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfLooseHierarchy),this.targetTightPolyline=InteractiveEdgeRouter.GetFirstHitPolyline(this.targetPort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.targetLoosePolyline=InteractiveEdgeRouter.GetFirstHitPolyline(this.targetPort.Location,this.ObstacleCalculator.RootOfLooseHierarchy),this.activeRectangle=Rectangle.mkPP(new point_Point(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),new point_Point(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY))}*AllPolygons(){for(const p of this.ObstacleCalculator.LooseObstacles)yield new Polygon(p)}GetVisibilityGraph(){return this.VisibilityGraph}AddActivePolygons(polygons){addRange(this.activePolygons,polygons)}ClearActivePolygons(){this.activePolygons=[]}}class PointPairMap{constructor(){this.size_=0,this.mapOfMaps=new PointMap}clear(){this.mapOfMaps.clear(),this.size_=0}get size(){return this.size_}set(pp,v){const x=pp.first,y=pp.second;let m=this.mapOfMaps.get(x);null==m&&this.mapOfMaps.set(x,m=new PointMap),m.has(y)||this.size_++,m.set(y,v)}delete(pp){const x=pp.first,y=pp.second,m=this.mapOfMaps.get(x);null!=m&&m.deleteP(y)&&this.size_--}has(pp){const m=this.mapOfMaps.get(pp.first);return null!=m&&m.has(pp.second)}get_(p,q){return this.get(new PointPair(p,q))}get(pp){const m=this.mapOfMaps.get(pp.first);if(null!=m)return m.get(pp.second)}*keys(){for(const p of this.mapOfMaps)for(const yp of p[1])yield new PointPair(p[0],yp[0])}*[Symbol.iterator](){for(const[x,m]of this.mapOfMaps)for(const[y,t]of m)yield[new PointPair(x,y),t]}*values(){for(const p of this.mapOfMaps)for(const yV of p[1])yield yV[1]}}class ShapeCreator{static GetShapes(graph,edges=Array.from(graph.edges())){const nodesToShapes=new Map;getShapesUnderGraph(graph,nodesToShapes);for(const edge of edges){let shape=nodesToShapes.get(edge.source);shape&&null!=edge.sourcePort&&shape.Ports.add(edge.sourcePort),shape=nodesToShapes.get(edge.target),shape&&null!=edge.targetPort&&shape.Ports.add(edge.targetPort)}return Array.from(nodesToShapes.values())}static CreateShapeWithCenterPort(node){const shape=new RelativeShape((()=>node.boundaryCurve)),port=RelativeFloatingPort.mk((()=>node.boundaryCurve),(()=>node.center));shape.Ports.add(port);for(const e of node.inEdges())ShapeCreator.FixPortAtTarget(port,e);for(const e of node.outEdges())ShapeCreator.FixPortAtSource(port,e);for(const e of node.selfEdges())ShapeCreator.FixPortAtSource(port,e),ShapeCreator.FixPortAtTarget(port,e);return shape}static CreateShapeWithClusterBoundaryPort(node){const shape=new RelativeShape((()=>node.boundaryCurve)),port=ClusterBoundaryPort.mk((()=>node.boundaryCurve),(()=>node.center));shape.Ports.add(port);for(const e of node.inEdges())ShapeCreator.FixPortAtTarget(port,e);for(const e of node.outEdges())ShapeCreator.FixPortAtSource(port,e);for(const e of node.selfEdges())ShapeCreator.FixPortAtSource(port,e),ShapeCreator.FixPortAtTarget(port,e);return shape}static FixPortAtSource(port,e){null==e.sourcePort&&(e.sourcePort=port)}static FixPortAtTarget(port,e){null==e.targetPort&&(e.targetPort=port)}}function getShapesUnderGraph(graph,nodesToShapes){for(const n of graph.shallowNodes())if(n.isGraph){const nShape=ShapeCreator.CreateShapeWithClusterBoundaryPort(n);nodesToShapes.set(n,nShape);const ng=n;if(!ng.graph.isCollapsed){getShapesUnderGraph(ng,nodesToShapes);for(const ch of ng.shallowNodes())nShape.AddChild(nodesToShapes.get(ch))}}else nodesToShapes.set(n,ShapeCreator.CreateShapeWithCenterPort(n))}class Constraint{constructor(variable){this.Right=variable,this.Left=variable}SetActiveState(activeState,newVectorIndex){this.IsActive=activeState,this.VectorIndex=newVectorIndex,this.IsActive?(this.Left.ActiveConstraintCount++,this.Right.ActiveConstraintCount++):(this.Left.ActiveConstraintCount--,this.Right.ActiveConstraintCount--)}SetVectorIndex(vectorIndex){this.VectorIndex=vectorIndex}Reinitialize(){this.IsActive=!1,this.IsUnsatisfiable=!1,this.ClearDfDv()}UpdateGap(newGap){this.Gap=newGap}static constructorVVNB(left,right,gap,isEquality){const v=new Constraint(left);return v.Left=left,v.Right=right,v.Gap=gap,v.IsEquality=isEquality,v.Lagrangian=0,v.IsActive=!1,v}ToString(){return dist.Qf.Format("  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv",this.Left,this.Right,this.IsEquality?"==":">=",this.Gap,this.Violation,this.Lagrangian,2*this.Lagrangian,this.IsActive?"+":this.IsUnsatisfiable?"!":"-")}get Violation(){return this.Left.ActualPos*this.Left.Scale+(this.Gap-this.Right.ActualPos*this.Right.Scale)}ClearDfDv(){this.Lagrangian=0}CompareTo(other){let cmp=this.Left.CompareTo(other.Left);return 0==cmp&&(cmp=this.Right.CompareTo(other.Right)),0==cmp&&(cmp=compareNumbers(this.Gap,other.Gap)),cmp}}class DfDvNode{constructor(dummyConstraint){this.ConstraintToEval=dummyConstraint,this.Depth=-1}static constructorDCVV(parent,constraintToEval,variableToEval,variableDoneEval){const ret=new DfDvNode(constraintToEval);return ret.Set(parent,constraintToEval,variableToEval,variableDoneEval),ret}Set(parent,constraintToEval,variableToEval,variableDoneEval){return this.Parent=parent,this.ConstraintToEval=constraintToEval,this.VariableToEval=variableToEval,this.VariableDoneEval=variableDoneEval,this.Depth=0,this.ChildrenHaveBeenPushed=!1,constraintToEval.Lagrangian=0,this}get IsLeftToRight(){return this.VariableToEval==this.ConstraintToEval.Right}toString(){return dist.Qf.Format("{0} {1}{2} - {3}{4} ({5})","",this.IsLeftToRight?"":"*",this.ConstraintToEval.Left.Name,this.IsLeftToRight?"*":"",this.ConstraintToEval.Right.Name,this.Depth)}}class ConstraintDirectionPair{constructor(constraint,isLeftToRight){this.Constraint=constraint,this.IsForward=isLeftToRight}}class Block{constructor(initialVariable,allConstraints){this.Variables=new Array,null!=initialVariable&&this.AddVariable(initialVariable),this.allConstraints=allConstraints}toString(){return dist.Qf.Format("[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]",this.Variables.length,this.ReferencePos,this.Scale)}ComputeDfDv(initialVarToEval){this.allConstraints.DfDvStack=new lib_src.B;const dummyConstraint=new Constraint(initialVarToEval);this.dfDvDummyParentNode=new DfDvNode(dummyConstraint);const firstNode=this.GetDfDvNode(this.dfDvDummyParentNode,dummyConstraint,initialVarToEval,null);for(this.allConstraints.DfDvStack.push(firstNode);;){const node=this.allConstraints.DfDvStack.top,prevStackCount=this.allConstraints.DfDvStack.length;if(!node.ChildrenHaveBeenPushed){node.ChildrenHaveBeenPushed=!0;for(const constraint of node.VariableToEval.LeftConstraints)if(constraint.IsActive&&constraint.Right!=node.VariableDoneEval){const childNode=this.GetDfDvNode(node,constraint,constraint.Right,node.VariableToEval);1==constraint.Right.ActiveConstraintCount?this.ProcessDfDvLeafNodeDirectly(childNode):this.PushDfDvNode(childNode)}for(const constraint of node.VariableToEval.RightConstraints)if(constraint.IsActive&&constraint.Left!=node.VariableDoneEval){const childNode=this.GetDfDvNode(node,constraint,constraint.Left,node.VariableToEval);1==constraint.Left.ActiveConstraintCount?this.ProcessDfDvLeafNodeDirectly(childNode):this.PushDfDvNode(childNode)}if(this.allConstraints.DfDvStack.length>prevStackCount)continue}if(this.allConstraints.DfDvStack.pop(),this.ProcessDfDvLeafNode(node),node==firstNode)break}}ProcessDfDvLeafNode(node){const dfdv=node.VariableToEval.DfDv;node.IsLeftToRight?(node.ConstraintToEval.Lagrangian=node.ConstraintToEval.Lagrangian+dfdv,node.Parent.ConstraintToEval.Lagrangian=node.Parent.ConstraintToEval.Lagrangian+node.ConstraintToEval.Lagrangian):(node.ConstraintToEval.Lagrangian=-1*(node.ConstraintToEval.Lagrangian+dfdv),node.Parent.ConstraintToEval.Lagrangian=node.Parent.ConstraintToEval.Lagrangian-node.ConstraintToEval.Lagrangian),this.CheckForConstraintPathTarget(node),this.Debug_CheckForViolatedActiveConstraint(node.ConstraintToEval),this.allConstraints.RecycleDfDvNode(node)}Debug_CheckForViolatedActiveConstraint(constraint){constraint.Violation,this.allConstraints.SolverParameters.GapTolerance}ProcessDfDvLeafNodeDirectly(node){this.ProcessDfDvLeafNode(node)}GetDfDvNode(parent,constraintToEval,variableToEval,variableDoneEval){const node=this.allConstraints.DfDvRecycleStack.size>0?this.allConstraints.DfDvRecycleStack.pop().Set(parent,constraintToEval,variableToEval,variableDoneEval):DfDvNode.constructorDCVV(parent,constraintToEval,variableToEval,variableDoneEval);return node.Depth=node.Parent.Depth+1,this.allConstraints.MaxConstraintTreeDepth<node.Depth&&(this.allConstraints.MaxConstraintTreeDepth=node.Depth),node}PushDfDvNode(node){this.PushOnDfDvStack(node)}AddVariableAndPushDfDvNode(lstVars,node){lstVars.push(node.VariableToEval),this.PushOnDfDvStack(node)}PushOnDfDvStack(node){this.allConstraints.DfDvStack.push(node)}CheckForConstraintPathTarget(node){if(this.pathTargetVariable==node.VariableToEval){for(;node.Parent!=this.dfDvDummyParentNode;)this.constraintPath.push(new ConstraintDirectionPair(node.ConstraintToEval,node.IsLeftToRight)),node=node.Parent;this.pathTargetVariable=null}}Expand(violatedConstraint){null==this.constraintPath&&(this.constraintPath=new Array),this.constraintPath=[],this.pathTargetVariable=violatedConstraint.Right,this.ComputeDfDv(violatedConstraint.Left);let minLagrangianConstraint=null;if(this.constraintPath.length>0){for(const pathItem of this.constraintPath)pathItem.IsForward&&(null==minLagrangianConstraint||pathItem.Constraint.Lagrangian<minLagrangianConstraint.Lagrangian)&&(pathItem.Constraint.IsEquality||(minLagrangianConstraint=pathItem.Constraint));null!=minLagrangianConstraint&&this.allConstraints.DeactivateConstraint(minLagrangianConstraint)}if(this.constraintPath=[],this.pathTargetVariable=null,null==minLagrangianConstraint)return violatedConstraint.IsUnsatisfiable=!0,void this.allConstraints.NumberOfUnsatisfiableConstraints++;const lstConnectedVars=new Array;this.GetConnectedVariables(lstConnectedVars,violatedConstraint.Right,violatedConstraint.Left);const violation=violatedConstraint.Violation,cConnectedVars=lstConnectedVars.length;for(let ii=0;ii<cConnectedVars;ii++)lstConnectedVars[ii].OffsetInBlock=lstConnectedVars[ii].OffsetInBlock+violation;this.allConstraints.ActivateConstraint(violatedConstraint),violatedConstraint.ClearDfDv(),this.UpdateReferencePos()}Split(isQpsc){if(isQpsc&&this.UpdateReferencePos(),this.Variables.length<2)return null;let minLagrangianConstraint=null;this.ComputeDfDv(this.Variables[0]);let minLagrangian=this.allConstraints.SolverParameters.Advanced.MinSplitLagrangianThreshold;const numVars=this.Variables.length;for(let ii=0;ii<numVars;ii++)for(const constraint of this.Variables[ii].LeftConstraints)constraint.IsActive&&!constraint.IsEquality&&constraint.Lagrangian<minLagrangian&&(minLagrangianConstraint=constraint,minLagrangian=constraint.Lagrangian);return null==minLagrangianConstraint?null:this.SplitOnConstraint(minLagrangianConstraint)}SplitOnConstraint(constraintToSplit){this.allConstraints.DeactivateConstraint(constraintToSplit);let newSplitBlock=new Block(null,this.allConstraints);return this.TransferConnectedVariables(newSplitBlock,constraintToSplit.Right,constraintToSplit.Left),newSplitBlock.Variables.length>0?(this.UpdateReferencePos(),newSplitBlock.UpdateReferencePos()):newSplitBlock=null,newSplitBlock}AddVariable(variable){this.Variables.push(variable),variable.Block=this,1==this.Variables.length?(this.Scale=variable.Scale,this.ReferencePos=variable.ActualPos,this.sumAd=variable.ActualPos*variable.Weight,this.sumAb=0,this.sumA2=variable.Weight,variable.OffsetInBlock=0):this.AddVariableToBlockSums(variable)}UpdateReferencePos(){this.Scale=this.Variables[0].Scale,this.sumAd=0,this.sumAb=0,this.sumA2=0;const numVars=this.Variables.length;for(let ii=0;ii<numVars;ii++)this.AddVariableToBlockSums(this.Variables[ii]);this.UpdateReferencePosFromSums()}AddVariableToBlockSums(variable){const a=this.Scale/variable.Scale,b=variable.OffsetInBlock/variable.Scale,aw=a*variable.Weight;this.sumAd=this.sumAd+aw*variable.DesiredPos,this.sumAb=this.sumAb+aw*b,this.sumA2=this.sumA2+aw*a}UpdateReferencePosFromSums(){if(!(Number.isFinite(this.sumAd)&&Number.isFinite(this.sumAb)&&Number.isFinite(this.sumA2)))throw new Error("infinite numbers");this.ReferencePos=(this.sumAd-this.sumAb)/this.sumA2,this.UpdateVariablePositions()}UpdateVariablePositions(){const scaledReferencePos=this.Scale*this.ReferencePos,numVars=this.Variables.length;for(let ii=0;ii<numVars;ii++){const v=this.Variables[ii];v.ActualPos=(scaledReferencePos+v.OffsetInBlock)/v.Scale}}GetConnectedVariables(lstVars,varToEval,varDoneEval){this.RecurseGetConnectedVariables(lstVars,varToEval,varDoneEval)}RecurseGetConnectedVariables(lstVars,initialVarToEval,initialVarDoneEval){this.allConstraints.DfDvStack=new lib_src.B;const dummyConstraint=new Constraint(initialVarToEval);for(this.dfDvDummyParentNode=new DfDvNode(dummyConstraint),this.allConstraints.DfDvStack.push(this.GetDfDvNode(this.dfDvDummyParentNode,dummyConstraint,initialVarToEval,initialVarDoneEval)),lstVars.push(initialVarToEval);this.allConstraints.DfDvStack.length>0;){const node=this.allConstraints.DfDvStack.top,prevStackCount=this.allConstraints.DfDvStack.length;if(!node.ChildrenHaveBeenPushed){node.ChildrenHaveBeenPushed=!0;for(const constraint of node.VariableToEval.LeftConstraints)constraint.IsActive&&constraint.Right!=node.VariableDoneEval&&(1==constraint.Right.ActiveConstraintCount?lstVars.push(constraint.Right):this.AddVariableAndPushDfDvNode(lstVars,this.GetDfDvNode(node,constraint,constraint.Right,node.VariableToEval)));for(const constraint of node.VariableToEval.RightConstraints)constraint.IsActive&&constraint.Left!=node.VariableDoneEval&&(1==constraint.Left.ActiveConstraintCount?lstVars.push(constraint.Left):this.AddVariableAndPushDfDvNode(lstVars,this.GetDfDvNode(node,constraint,constraint.Left,node.VariableToEval)))}this.allConstraints.DfDvStack.length>prevStackCount||this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.pop())}}TransferConnectedVariables(newSplitBlock,varToEval,varDoneEval){this.GetConnectedVariables(newSplitBlock.Variables,varToEval,varDoneEval);const numVarsToMove=newSplitBlock.Variables.length;for(let moveIndex=0;moveIndex<numVarsToMove;moveIndex++)newSplitBlock.Variables[moveIndex].Block=newSplitBlock;let lastKeepIndex=this.Variables.length-1;for(let currentIndex=this.Variables.length-1;currentIndex>=0;currentIndex--){this.Variables[currentIndex].Block==newSplitBlock&&(currentIndex<lastKeepIndex&&(this.Variables[currentIndex]=this.Variables[lastKeepIndex]),lastKeepIndex--)}if(this.Variables=this.Variables.slice(0,lastKeepIndex+1),0==this.Variables.length){for(let moveIndex=0;moveIndex<numVarsToMove;moveIndex++){const variableToMove=newSplitBlock.Variables[moveIndex];this.Variables.push(variableToMove),variableToMove.Block=this}newSplitBlock.Variables=[]}}}class BlockVector{constructor(){this.Vector=new Array}get Count(){return this.Vector.length}item(index){return this.Vector[index]}Add(block){block.VectorIndex=this.Vector.length,this.Vector.push(block)}Remove(block){const swapBlock=this.Vector[this.Vector.length-1];this.Vector[block.VectorIndex]=swapBlock,swapBlock.VectorIndex=block.VectorIndex,this.Vector.pop()}toString(){return this.Vector.toString()}}class ConstraintVector{constructor(){this.nextConstraintIndex=0,this.DfDvStack=new lib_src.B,this.DfDvRecycleStack=new lib_src.B}get IsEmpty(){return null==this.Vector}Create(numConstraints){this.Vector=new Array(numConstraints),this.firstActiveConstraintIndex=numConstraints}Add(constraint){constraint.SetVectorIndex(this.nextConstraintIndex),this.Vector[this.nextConstraintIndex++]=constraint}ActivateConstraint(constraint){this.firstActiveConstraintIndex--,this.SwapConstraint(constraint)}DeactivateConstraint(constraint){this.SwapConstraint(constraint),this.firstActiveConstraintIndex++}SwapConstraint(constraint){const swapConstraint=this.Vector[this.firstActiveConstraintIndex];swapConstraint.SetVectorIndex(constraint.VectorIndex),this.Vector[constraint.VectorIndex]=swapConstraint,this.Vector[this.firstActiveConstraintIndex]=constraint,constraint.SetActiveState(!constraint.IsActive,this.firstActiveConstraintIndex)}Reinitialize(){if(null!=this.Vector){for(const constraint of this.Vector)constraint.Reinitialize();this.firstActiveConstraintIndex=this.Vector.length}}RecycleDfDvNode(node){this.DfDvRecycleStack.length<1024&&this.DfDvRecycleStack.push(node)}toString(){return this.Vector.toString()}}class Parameters{constructor(){this.GapTolerance=1e-4,this.QpscConvergenceEpsilon=1e-5,this.QpscConvergenceQuotient=1e-6,this.OuterProjectIterationsLimit=-1,this.InnerProjectIterationsLimit=-1,this.TimeLimit=-1,this.Advanced=new AdvancedParameters}Clone(){const newParams=this.MemberwiseClone();return newParams.Advanced=this.Advanced.Clone(),newParams}MemberwiseClone(){const par=new Parameters;return par.GapTolerance=this.GapTolerance,par.QpscConvergenceEpsilon=this.QpscConvergenceEpsilon,par.QpscConvergenceQuotient=this.QpscConvergenceQuotient,par.OuterProjectIterationsLimit=this.OuterProjectIterationsLimit,par.InnerProjectIterationsLimit=this.InnerProjectIterationsLimit,par.TimeLimit=this.TimeLimit,par}}class AdvancedParameters{constructor(){this.ForceQpsc=!1,this.ScaleInQpsc=!0,this.MinSplitLagrangianThreshold=-1e-7,this.UseViolationCache=!0,this.ViolationCacheMinBlocksDivisor=10,this.ViolationCacheMinBlocksCount=100}Clone(){const ret=new AdvancedParameters;return ret.ForceQpsc=this.ForceQpsc,ret.ScaleInQpsc=this.ScaleInQpsc,ret.MinSplitLagrangianThreshold=this.MinSplitLagrangianThreshold,ret.UseViolationCache=this.UseViolationCache,ret.ViolationCacheMinBlocksDivisor=this.ViolationCacheMinBlocksDivisor,ret.ViolationCacheMinBlocksCount=this.ViolationCacheMinBlocksCount,ret}}class QpscVar{constructor(v){this.Variable=v,this.OrigWeight=v.Weight,this.OrigScale=v.Scale,this.OrigDesiredPos=this.Variable.DesiredPos}}class MatrixCell{constructor(w,index){this.Value=w,this.Column=index}}class Qpsc{constructor(solverParameters,cVariables){this.newMatrixRow=new Array,this.previousFunctionValue=Number.MAX_VALUE,this.solverParameters=this.solverParameters,this.matrixQ=new Array(cVariables),this.vectorWiDi=new Array(cVariables),this.vectorQpscVars=new Array(cVariables),this.gradientVector=new Array(cVariables),this.vectorQg=new Array(cVariables),this.vectorPrevY=new Array(cVariables),this.vectorCurY=new Array(cVariables)}AddVariable(variable){if(this.isFirstProjectCall=!0,this.vectorWiDi[variable.Ordinal]=variable.Weight*variable.DesiredPos*2*-1,this.vectorPrevY[variable.Ordinal]=variable.Weight,null!=variable.Neighbors)for(const neighborWeightPair of variable.Neighbors)this.vectorPrevY[variable.Ordinal]=this.vectorPrevY[variable.Ordinal]+neighborWeightPair.Weight,this.vectorPrevY[neighborWeightPair.Neighbor.Ordinal]=this.vectorPrevY[neighborWeightPair.Neighbor.Ordinal]-neighborWeightPair.Weight;for(let ii=0;ii<this.vectorPrevY.length;ii++)0!=this.vectorPrevY[ii]&&(this.newMatrixRow.push(new MatrixCell(2*this.vectorPrevY[ii],ii)),this.vectorPrevY[ii]=0);this.matrixQ[variable.Ordinal]=Array.from(this.newMatrixRow),this.newMatrixRow=[],this.vectorQpscVars[variable.Ordinal]=new QpscVar(variable),variable.Weight=1}VariablesComplete(){for(const qvar of this.vectorQpscVars){const variable=qvar.Variable;for(const cell of this.matrixQ[variable.Ordinal])cell.Column==variable.Ordinal&&(this.solverParameters.Advanced.ScaleInQpsc&&(variable.Scale=1/Math.sqrt(Math.abs(cell.Value)),Number.isFinite(variable.Scale)||(variable.Scale=1),variable.Scale,this.vectorWiDi[variable.Ordinal]=this.vectorWiDi[variable.Ordinal]*variable.Scale),this.vectorCurY[variable.Ordinal]=variable.ActualPos,variable.DesiredPos=variable.ActualPos)}if(this.solverParameters.Advanced.ScaleInQpsc)for(let rowNum=0;rowNum<this.matrixQ.length;rowNum++){const row=this.matrixQ[rowNum];for(let sparseCol=0;sparseCol<row.length;sparseCol++)row[sparseCol].Column==rowNum?row[sparseCol].Value=1:row[sparseCol].Value=row[sparseCol].Value*(this.vectorQpscVars[rowNum].Variable.Scale*this.vectorQpscVars[row[sparseCol].Column].Variable.Scale)}}PreProject(){if(this.isFirstProjectCall)for(const qvar of this.vectorQpscVars)this.vectorCurY[qvar.Variable.Ordinal]=qvar.Variable.ActualPos;if(this.MatrixVectorMultiply(this.vectorCurY,this.gradientVector),this.HasConverged())return!1;Qpsc.VectorVectorAdd(this.gradientVector,this.vectorWiDi,this.gradientVector);const alphaNumerator=Qpsc.VectorVectorMultiply(this.gradientVector,this.gradientVector);let alphaDenominator=0;if(0!=alphaNumerator&&(this.MatrixVectorMultiply(this.gradientVector,this.vectorQg),alphaDenominator=Qpsc.VectorVectorMultiply(this.vectorQg,this.gradientVector)),0==alphaDenominator)return!1;const alpha=alphaNumerator/alphaDenominator;Qpsc.VectorCopy(this.vectorPrevY,this.vectorCurY),Qpsc.VectorScaledVectorSubtract(this.vectorPrevY,alpha,this.gradientVector,this.vectorCurY);for(let ii=0;ii<this.vectorCurY.length;ii++)this.vectorQpscVars[ii].Variable.DesiredPos=this.vectorCurY[ii];return!0}PostProject(){for(const qvar of this.vectorQpscVars)this.vectorCurY[qvar.Variable.Ordinal]=qvar.Variable.ActualPos;Qpsc.VectorVectorSubtract(this.vectorPrevY,this.vectorCurY,this.vectorCurY);const betaNumerator=Qpsc.VectorVectorMultiply(this.gradientVector,this.vectorCurY);let beta=0;if(0!=betaNumerator){this.MatrixVectorMultiply(this.vectorCurY,this.vectorQg);const betaDenominator=Qpsc.VectorVectorMultiply(this.vectorQg,this.vectorCurY);beta=0==betaDenominator?1:betaNumerator/betaDenominator,beta>1?beta=1:beta<0&&(beta=0)}return Qpsc.VectorScaledVectorSubtract(this.vectorPrevY,beta,this.vectorCurY,this.vectorCurY),this.isFirstProjectCall=!1,beta>0}QpscComplete(){for(const qvar of this.vectorQpscVars)qvar.Variable.Weight=qvar.OrigWeight,qvar.Variable.DesiredPos=qvar.OrigDesiredPos,this.solverParameters.Advanced.ScaleInQpsc&&(qvar.Variable.ActualPos=qvar.Variable.ActualPos*qvar.Variable.Scale,qvar.Variable.Scale=qvar.OrigScale);return this.previousFunctionValue}HasConverged(){const currentFunctionValue=this.GetFunctionValue(this.vectorCurY);let fConverged=!1;if(!this.isFirstProjectCall){const diff=this.previousFunctionValue-currentFunctionValue;let quotient=0;if(0!=diff){const divisor=0!=this.previousFunctionValue?this.previousFunctionValue:currentFunctionValue;quotient=Math.abs(diff/divisor)}(Math.abs(diff)<this.solverParameters.QpscConvergenceEpsilon||Math.abs(quotient)<this.solverParameters.QpscConvergenceQuotient)&&(fConverged=!0)}return this.previousFunctionValue=currentFunctionValue,fConverged}GetFunctionValue(positions){return Qpsc.VectorVectorMultiply(this.gradientVector,positions)/2+Qpsc.VectorVectorMultiply(this.vectorWiDi,positions)}static VectorVectorMultiply(lhs,rhs){let sum=0;for(let ii=0;ii<lhs.length;ii++)sum+=lhs[ii]*rhs[ii];return sum}MatrixVectorMultiply(rhs,result){let rowIndex=0;for(const row of this.matrixQ){let sum=0;for(const cell of row)sum+=cell.Value*rhs[cell.Column];result[rowIndex++]=sum}}static VectorVectorAdd(lhs,rhs,result){for(let ii=0;ii<lhs.length;ii++)result[ii]=lhs[ii]+rhs[ii]}static VectorVectorSubtract(lhs,rhs,result){for(let ii=0;ii<lhs.length;ii++)result[ii]=lhs[ii]-rhs[ii]}static VectorScaledVectorSubtract(lhs,scale,rhs,result){for(let ii=0;ii<lhs.length;ii++)result[ii]=lhs[ii]-scale*rhs[ii]}static VectorCopy(dest,src){for(let ii=0;ii<src.length;ii++)dest[ii]=src[ii]}}class Solution{get ExecutionLimitExceeded(){return this.TimeLimitExceeded||this.OuterProjectIterationsLimitExceeded||this.InnerProjectIterationsLimitExceeded}Clone(){const r=new Solution;return r.GoalFunctionValue=this.GoalFunctionValue,r.InnerProjectIterationsLimitExceeded=this.InnerProjectIterationsLimitExceeded,r.InnerProjectIterationsTotal=this.InnerProjectIterationsTotal,r.MaxConstraintTreeDepth=this.MaxConstraintTreeDepth,r.OuterProjectIterations=this.OuterProjectIterations,r.OuterProjectIterationsLimitExceeded=this.OuterProjectIterationsLimitExceeded,r.AlgorithmUsed=this.AlgorithmUsed,r.NumberOfUnsatisfiableConstraints=this.NumberOfUnsatisfiableConstraints,r.MaxInnerProjectIterations=this.MaxInnerProjectIterations,r}}!function(SolverAlgorithm){SolverAlgorithm[SolverAlgorithm.ProjectOnly=0]="ProjectOnly",SolverAlgorithm[SolverAlgorithm.QpscWithScaling=1]="QpscWithScaling",SolverAlgorithm[SolverAlgorithm.QpscWithoutScaling=2]="QpscWithoutScaling"}(SolverAlgorithm||(SolverAlgorithm={}));class NeighborAndWeight{constructor(neighbor,weight){this.Neighbor=neighbor,this.Weight=weight}}class Variable{constructor(ordinal,userData,desiredPos,weight,scale){if(this.ActiveConstraintCount=0,weight<=0)throw new Error("weight");if(scale<=0)throw new Error("scale");let check=desiredPos*weight;if(!Number.isFinite(check)||Number.isNaN(check))throw new Error("desiredPos");if(check=desiredPos*scale,!Number.isFinite(check)||Number.isNaN(check))throw new Error("desiredPos");this.Ordinal=ordinal,this.UserData=userData,this.DesiredPos=desiredPos,this.Weight=weight,this.Scale=scale,this.OffsetInBlock=0,this.ActualPos=this.DesiredPos}get DfDv(){return this.Weight*(this.ActualPos-this.DesiredPos)*2/this.Scale}Reinitialize(){this.ActiveConstraintCount=0,this.OffsetInBlock=0,this.ActualPos=this.DesiredPos}AddNeighbor(neighbor,weight){null==this.Neighbors&&(this.Neighbors=new Array),this.Neighbors.push(new NeighborAndWeight(neighbor,weight))}toString(){return dist.Qf.Format("{0} {1:F5} ({2:F5}) {3:F5} {4:F5}",this.Name,this.ActualPos,this.DesiredPos,this.Weight,this.Scale)}get Name(){return null==this.UserData?"-0-":this.UserData.toString()}SetConstraints(leftConstraints,rightConstraints){this.LeftConstraints=leftConstraints,this.RightConstraints=rightConstraints}CompareTo(other){return compareNumbers(this.Ordinal,other.Ordinal)}}class ViolationCache{get IsFull(){return this.numConstraints==ViolationCache.MaxConstraints}Clear(){this.LowViolation=0,this.numConstraints=0,this.constraints||(this.constraints=new Array(ViolationCache.MaxConstraints))}FilterBlock(blockToFilter){this.LowViolation=Number.MAX_VALUE;const fRet=this.numConstraints>0;for(let ii=this.numConstraints-1;ii>=0;ii--){const constraint=this.constraints[ii];if(constraint.Left.Block==blockToFilter||constraint.Right.Block==blockToFilter||constraint.IsActive||constraint.IsUnsatisfiable)ii<this.numConstraints-1&&(this.constraints[ii]=this.constraints[this.numConstraints-1]),this.numConstraints--;else{const violation=constraint.Left.ActualPos*constraint.Left.Scale+(constraint.Gap-constraint.Right.ActualPos*constraint.Right.Scale);violation<this.LowViolation&&(this.LowViolation=violation)}}return 0==this.numConstraints&&(this.LowViolation=0),fRet}FindIfGreater(targetViolation){let maxViolatedConstraint=null;for(let ii=0;ii<this.numConstraints;ii++){const constraint=this.constraints[ii],violation=constraint.Left.ActualPos*constraint.Left.Scale+(constraint.Gap-constraint.Right.ActualPos*constraint.Right.Scale);violation>targetViolation&&(targetViolation=violation,maxViolatedConstraint=constraint)}return maxViolatedConstraint}Insert(constraintToInsert,insertViolation){let indexOfLowestViolation=0,lowViolation=insertViolation,nextLowViolation=insertViolation;for(let ii=0;ii<this.numConstraints;ii++){const constraint=this.constraints[ii],cacheViolation=constraint.Left.ActualPos*constraint.Left.Scale+(constraint.Gap-constraint.Right.ActualPos*constraint.Right.Scale);cacheViolation<lowViolation?(nextLowViolation=lowViolation,indexOfLowestViolation=ii,lowViolation=cacheViolation):cacheViolation<nextLowViolation&&(nextLowViolation=cacheViolation)}this.IsFull?(this.constraints[indexOfLowestViolation]=constraintToInsert,this.LowViolation=nextLowViolation):(this.constraints[this.numConstraints++]=constraintToInsert,this.IsFull&&(this.LowViolation=lowViolation))}}ViolationCache.MaxConstraints=20;class ConstraintListForVariable{constructor(constraints,numberOfLeftConstraints){this.NumberOfLeftConstraints=0,this.Constraints=constraints,this.NumberOfLeftConstraints=numberOfLeftConstraints}}class Solver{constructor(){this.allBlocks=new BlockVector,this.allConstraints=new ConstraintVector,this.numberOfConstraints=0,this.numberOfVariables=0,this.equalityConstraints=new Array,this.loadedVariablesAndConstraintLists=new Map,this.emptyConstraintList=new Array(0),this.updatedConstraints=new Array,this.violationCache=new ViolationCache,this.violationCacheMinBlockCutoff=0,this.nextVariableOrdinal=0,this.solverParams=new Parameters,this.solverSolution=new Solution}get IsQpsc(){return this.hasNeighbourPairs||this.solverParams.Advanced.ForceQpsc}AddVariableAN(userData,desiredPos){return this.AddVariableANNN(userData,desiredPos,1,1)}AddVariableANN(userData,desiredPos,weight){return this.AddVariableANNN(userData,desiredPos,weight,1)}AddVariableANNN(userData,desiredPos,weight,scale){if(!this.allConstraints.IsEmpty)throw new Error("Cannot add Variables or Constraints once Solve() has been called");const varNew=new Variable(this.nextVariableOrdinal++,userData,desiredPos,weight,scale),block=new Block(varNew,this.allConstraints);return varNew.Block=block,this.allBlocks.Add(block),this.numberOfVariables++,this.loadedVariablesAndConstraintLists.set(varNew,new ConstraintListForVariable(new Array,0)),varNew}UpdateVariables(){for(const block of this.allBlocks.Vector)block.UpdateReferencePos()}get Variables(){return flatMap(this.allBlocks.Vector,(block=>block.Variables))}get VariableCount(){return this.numberOfVariables}*Constraints(){if(this.allConstraints.IsEmpty)for(const variable of this.loadedVariablesAndConstraintLists.keys()){const constraintsForVar=this.loadedVariablesAndConstraintLists.get(variable);if(null!=constraintsForVar.Constraints){const numConstraints=constraintsForVar.Constraints.length;for(let ii=0;ii<numConstraints;ii++){const constraint=constraintsForVar.Constraints[ii];if(variable==constraint.Left)return yield,constraint}}}else for(const constraint of this.allConstraints.Vector)yield constraint}get ConstraintCount(){return this.numberOfConstraints}AddEqualityConstraint(left,right,gap){return this.AddConstraintVVNB(left,right,gap,!0)}AddConstraintVVNB(left,right,gap,isEquality){if(!this.allConstraints.IsEmpty)throw new Error("Cannot add Variables or Constraints once Solve() has been called");if(left==right)throw new Error("Cannot add a constraint between a variable and itself");const constraintsForLeftVar=this.loadedVariablesAndConstraintLists.get(left),constraintsForRightVar=this.loadedVariablesAndConstraintLists.get(right),constraint=Constraint.constructorVVNB(left,right,gap,isEquality);return this.loadedVariablesAndConstraintLists.set(left,new ConstraintListForVariable(constraintsForLeftVar.Constraints,constraintsForLeftVar.NumberOfLeftConstraints+1)),constraintsForLeftVar.Constraints.push(constraint),constraintsForRightVar.Constraints.push(constraint),this.numberOfConstraints++,isEquality&&this.equalityConstraints.push(constraint),constraint}AddConstraint(left,right,gap){return this.AddConstraintVVNB(left,right,gap,!1)}SetConstraintUpdate(constraint,gap){gap!=constraint.Gap&&this.updatedConstraints.push([constraint,gap])}AddNeighborPair(variable1,variable2,relationshipWeight){if(relationshipWeight<=0||Number.isNaN(relationshipWeight)||!Number.isFinite(relationshipWeight))throw new Error("relationshipWeight");if(variable1==variable2)throw new Error;variable1.AddNeighbor(variable2,relationshipWeight),variable2.AddNeighbor(variable1,relationshipWeight),this.hasNeighbourPairs=!0}Solve(){return this.SolvePar(null)}SolvePar(solverParameters){solverParameters&&(this.solverParams=solverParameters.Clone()),this.solverParams.OuterProjectIterationsLimit<0&&(this.solverParams.OuterProjectIterationsLimit=100*(Math.log2(this.numberOfVariables)+1)),this.solverParams.InnerProjectIterationsLimit<0&&(this.solverParams.InnerProjectIterationsLimit=2*this.numberOfConstraints+100*(Math.log2(this.numberOfConstraints)+1));const isReSolve=!this.allConstraints.IsEmpty;if(this.CheckForUpdatedConstraints(),this.solverSolution=new Solution,this.solverSolution.MinInnerProjectIterations=Number.MAX_VALUE,this.allConstraints.MaxConstraintTreeDepth=0,this.allConstraints.SolverParameters=this.solverParams,0==this.numberOfConstraints){if(!this.IsQpsc)return this.solverSolution.Clone()}else isReSolve||this.SetupConstraints();return this.allConstraints.NumberOfUnsatisfiableConstraints=0,this.MergeEqualityConstraints(),this.IsQpsc?this.SolveQpsc():(this.SolveByStandaloneProject(),this.CalculateStandaloneProjectGoalFunctionValue()),this.solverSolution.MinInnerProjectIterations>this.solverSolution.MaxInnerProjectIterations&&(this.solverSolution.MinInnerProjectIterations=this.solverSolution.MaxInnerProjectIterations),this.solverSolution.NumberOfUnsatisfiableConstraints=this.allConstraints.NumberOfUnsatisfiableConstraints,this.solverSolution.MaxConstraintTreeDepth=this.allConstraints.MaxConstraintTreeDepth,this.solverSolution.Clone()}CheckForUpdatedConstraints(){if(0==this.updatedConstraints.length)return;let mustReinitializeBlocks=this.IsQpsc;for(const[key,value]of this.updatedConstraints){const constraint=key;constraint.UpdateGap(value),mustReinitializeBlocks||constraint.IsEquality?mustReinitializeBlocks=!0:this.SplitOnConstraintIfActive(constraint)}this.updatedConstraints=[],mustReinitializeBlocks&&this.ReinitializeBlocks()}SplitOnConstraintIfActive(constraint){if(constraint.IsActive){const newSplitBlock=constraint.Left.Block.SplitOnConstraint(constraint);null!=newSplitBlock&&this.allBlocks.Add(newSplitBlock)}}SetupConstraints(){this.allConstraints.Create(this.numberOfConstraints);for(const variable of this.loadedVariablesAndConstraintLists.keys()){const constraintsForVar=this.loadedVariablesAndConstraintLists.get(variable),constraints=constraintsForVar.Constraints;let numAllConstraints=0,numLeftConstraints=0,numRightConstraints=0;null!=constraints&&(numAllConstraints=constraints.length,numLeftConstraints=constraintsForVar.NumberOfLeftConstraints,numRightConstraints=numAllConstraints-numLeftConstraints);let leftConstraints=this.emptyConstraintList;0!=numLeftConstraints&&(leftConstraints=new Array(numLeftConstraints));let rightConstraints=this.emptyConstraintList;0!=numRightConstraints&&(rightConstraints=new Array(numRightConstraints)),variable.SetConstraints(leftConstraints,rightConstraints);let leftConstraintIndex=0,rightConstraintIndex=0;for(let loadedConstraintIndex=0;loadedConstraintIndex<numAllConstraints;loadedConstraintIndex++){const loadedConstraint=constraints[loadedConstraintIndex];variable==loadedConstraint.Left?leftConstraints[leftConstraintIndex++]=loadedConstraint:rightConstraints[rightConstraintIndex++]=loadedConstraint}for(const constraint of variable.LeftConstraints)this.allConstraints.Add(constraint)}this.loadedVariablesAndConstraintLists.clear(),this.violationCacheMinBlockCutoff=Number.MAX_VALUE,this.solverParams.Advanced.UseViolationCache&&this.solverParams.Advanced.ViolationCacheMinBlocksDivisor>0&&(this.violationCacheMinBlockCutoff=Math.min(this.allBlocks.Count/this.solverParams.Advanced.ViolationCacheMinBlocksDivisor,this.solverParams.Advanced.ViolationCacheMinBlocksCount))}SolveByStandaloneProject(){for(;;){let violationsFound;if(!this.RunProject(violationsFound))return;if(!this.SplitBlocks())break}}RunProject(violationsFound){return this.solverSolution.OuterProjectIterations++,this.Project(),!this.CheckForLimitsExceeded()}CheckForLimitsExceeded(){return this.solverParams.OuterProjectIterationsLimit>0&&this.solverSolution.OuterProjectIterations>=this.solverParams.OuterProjectIterationsLimit?(this.solverSolution.OuterProjectIterationsLimitExceeded=!0,!0):!!this.solverSolution.InnerProjectIterationsLimitExceeded}CalculateStandaloneProjectGoalFunctionValue(){this.solverSolution.GoalFunctionValue=0;const numBlocks=this.allBlocks.Count;for(let ii=0;ii<numBlocks;ii++){const block=this.allBlocks.item(ii),numVars=block.Variables.length;for(let jj=0;jj<numVars;jj++){const variable=block.Variables[jj];this.solverSolution.GoalFunctionValue=this.solverSolution.GoalFunctionValue+variable.Weight*(variable.ActualPos*variable.ActualPos),this.solverSolution.GoalFunctionValue=this.solverSolution.GoalFunctionValue-variable.Weight*(variable.DesiredPos*variable.ActualPos)*2}}}SolveQpsc(){if(this.solverSolution.AlgorithmUsed=this.solverParams.Advanced.ScaleInQpsc?SolverAlgorithm.QpscWithScaling:SolverAlgorithm.QpscWithoutScaling,!this.QpscMakeFeasible())return;const qpsc=new Qpsc(this.solverParams,this.numberOfVariables);for(const block of this.allBlocks.Vector)for(const variable of block.Variables)qpsc.AddVariable(variable);qpsc.VariablesComplete(),this.ReinitializeBlocks(),this.MergeEqualityConstraints();let foundSplit=!1;for(;(qpsc.PreProject()||foundSplit)&&(foundSplit=this.SplitBlocks(),this.RunProject(false))&&(qpsc.PostProject()||foundSplit););this.solverSolution.GoalFunctionValue=qpsc.QpscComplete()}QpscMakeFeasible(){return this.RunProject(undefined)}ReinitializeBlocks(){const oldBlocks=Array.from(this.allBlocks.Vector);this.allBlocks.Vector=[];for(const oldBlock of oldBlocks)for(const variable of oldBlock.Variables){variable.Reinitialize();const newBlock=new Block(variable,this.allConstraints);this.allBlocks.Add(newBlock)}this.allConstraints.Reinitialize(),this.violationCache.Clear()}MergeEqualityConstraints(){for(const constraint of this.equalityConstraints)constraint.Left.Block!=constraint.Right.Block?this.MergeBlocks(constraint):Math.abs(constraint.Violation)>this.solverParams.GapTolerance&&(constraint.IsUnsatisfiable=!0,this.allConstraints.NumberOfUnsatisfiableConstraints++)}Project(){if(0==this.numberOfConstraints)return!1;this.violationCache.Clear(),this.lastModifiedBlock=null;let useViolationCache=this.allBlocks.Count>this.violationCacheMinBlockCutoff,cIterations=1;let maxViolatedConstraint=this.GetMaxViolatedConstraint({maxViolation:0},useViolationCache);if(!maxViolatedConstraint)return!1;for(;maxViolatedConstraint;){if(maxViolatedConstraint.Left.Block==maxViolatedConstraint.Right.Block?(maxViolatedConstraint.Left.Block.Expand(maxViolatedConstraint),maxViolatedConstraint.IsUnsatisfiable&&this.violationCache.Clear(),this.lastModifiedBlock=maxViolatedConstraint.Left.Block):this.lastModifiedBlock=this.MergeBlocks(maxViolatedConstraint),this.solverParams.InnerProjectIterationsLimit>0&&cIterations>=this.solverParams.InnerProjectIterationsLimit){this.solverSolution.InnerProjectIterationsLimitExceeded=!0;break}useViolationCache=this.allBlocks.Count>this.violationCacheMinBlockCutoff,useViolationCache||this.violationCache.Clear(),cIterations++;const t={maxViolation:0};maxViolatedConstraint=this.GetMaxViolatedConstraint(t,useViolationCache)}return this.solverSolution.InnerProjectIterationsTotal=this.solverSolution.InnerProjectIterationsTotal+cIterations,this.solverSolution.MaxInnerProjectIterations<cIterations&&(this.solverSolution.MaxInnerProjectIterations=cIterations),this.solverSolution.MinInnerProjectIterations>cIterations&&(this.solverSolution.MinInnerProjectIterations=cIterations),!0}MergeBlocks(violatedConstraint){let blockTo=violatedConstraint.Left.Block,blockFrom=violatedConstraint.Right.Block,distance=violatedConstraint.Left.OffsetInBlock+(violatedConstraint.Gap-violatedConstraint.Right.OffsetInBlock);blockFrom.Variables.length>blockTo.Variables.length&&(blockTo=violatedConstraint.Right.Block,blockFrom=violatedConstraint.Left.Block,distance*=-1);const numVars=blockFrom.Variables.length;for(let ii=0;ii<numVars;ii++){const variable=blockFrom.Variables[ii];variable.OffsetInBlock=variable.OffsetInBlock+distance,blockTo.AddVariable(variable)}return blockTo.UpdateReferencePosFromSums(),this.allConstraints.ActivateConstraint(violatedConstraint),this.allBlocks.Remove(blockFrom),blockTo}SplitBlocks(){const newBlocks=new Array,numBlocks=this.allBlocks.Count;for(let ii=0;ii<numBlocks;ii++){const newSplitBlock=this.allBlocks.item(ii).Split(this.IsQpsc);null!=newSplitBlock&&newBlocks.push(newSplitBlock)}const numNewBlocks=newBlocks.length;for(let ii=0;ii<numNewBlocks;ii++){const block=newBlocks[ii];this.allBlocks.Add(block)}return 0!=newBlocks.length}GetMaxViolatedConstraint(t,useViolationCache){t.maxViolation=this.solverParams.GapTolerance;const maxViolatedConstraint=this.SearchViolationCache(t.maxViolation);return null!=maxViolatedConstraint?maxViolatedConstraint:this.SearchAllConstraints(t.maxViolation,useViolationCache)}SearchViolationCache(maxViolation){let maxViolatedConstraint=null;if(null==this.lastModifiedBlock)return;this.lastModifiedBlock.Variables.length<this.numberOfVariables+1&&this.violationCache.FilterBlock(this.lastModifiedBlock);const numVarsInBlock=this.lastModifiedBlock.Variables.length;for(let variableIndex=0;variableIndex<numVarsInBlock;variableIndex++){const variable=this.lastModifiedBlock.Variables[variableIndex];for(const constraint of variable.LeftConstraints)if(!constraint.IsActive&&!constraint.IsUnsatisfiable){greaterDistEps(constraint.Left.ActualPos*constraint.Left.Scale+(constraint.Gap-constraint.Right.ActualPos*constraint.Right.Scale),maxViolation)&&(null!=maxViolatedConstraint&&maxViolation>this.violationCache.LowViolation&&this.violationCache.Insert(maxViolatedConstraint,maxViolation),maxViolation=constraint.Violation,maxViolatedConstraint=constraint)}for(const constraint of variable.RightConstraints)if(!constraint.IsActive&&!constraint.IsUnsatisfiable&&constraint.Left.Block!=this.lastModifiedBlock){const violation=constraint.Left.ActualPos*constraint.Left.Scale+(constraint.Gap-constraint.Right.ActualPos*constraint.Right.Scale);greaterDistEps(violation,maxViolation)&&(null!=maxViolatedConstraint&&maxViolation>this.violationCache.LowViolation&&this.violationCache.Insert(maxViolatedConstraint,maxViolation),maxViolation=violation,maxViolatedConstraint=constraint)}}const cachedConstraint=this.violationCache.FindIfGreater(maxViolation);return null!=cachedConstraint&&(null!=maxViolatedConstraint&&maxViolation>this.violationCache.LowViolation&&this.violationCache.Insert(maxViolatedConstraint,maxViolation),maxViolatedConstraint=cachedConstraint),maxViolatedConstraint}SearchAllConstraints(maxViolation,useViolationCache){let maxViolatedConstraint=null;this.violationCache.Clear();for(const constraint of this.allConstraints.Vector){if(constraint.IsActive)break;if(constraint.IsUnsatisfiable)continue;const violation=constraint.Left.ActualPos*constraint.Left.Scale+(constraint.Gap-constraint.Right.ActualPos*constraint.Right.Scale);let cacheInsertConstraint=null,cacheInsertViolation=0;greaterDistEps(violation,maxViolation)&&(maxViolation>this.violationCache.LowViolation&&(cacheInsertConstraint=maxViolatedConstraint,cacheInsertViolation=maxViolation),maxViolation=violation,maxViolatedConstraint=constraint),useViolationCache&&(null==cacheInsertConstraint&&constraint!=maxViolatedConstraint&&(!this.violationCache.IsFull||violation>this.violationCache.LowViolation)&&(cacheInsertConstraint=constraint,cacheInsertViolation=violation),null!=cacheInsertConstraint&&cacheInsertViolation>this.violationCache.LowViolation&&this.violationCache.Insert(cacheInsertConstraint,cacheInsertViolation))}return maxViolatedConstraint}}class SolverShell{constructor(){this.variables=new Map,this.fixedVars=new Map,this.FailToAdjustEpsilon=.001,this.InitSolver()}AddVariableWithIdealPositionNNN(id,position,weight){this.variables.set(id,this.solver.AddVariableANN(id,position,weight))}AddVariableWithIdealPositionNN(id,position){this.AddVariableWithIdealPositionNNN(id,position,1)}AddLeftRightSeparationConstraintNNNB(idLeft,idRight,gap,isEquality){const varLeft=this.GetVariable(idLeft);if(null==varLeft)return;const varRight=this.GetVariable(idRight);null!=varRight&&this.solver.AddConstraintVVNB(varLeft,varRight,gap,isEquality)}AddLeftRightSeparationConstraintNNN(idLeft,idRight,gap){this.AddLeftRightSeparationConstraintNNNB(idLeft,idRight,gap,!1)}AddGoalTwoVariablesAreCloseNNN(id1,id2,weight){const var1=this.GetVariable(id1);if(null==var1)return;const var2=this.GetVariable(id2);null!=var2&&this.solver.AddNeighborPair(var1,var2,weight)}AddGoalTwoVariablesAreClose(id1,id2){this.AddGoalTwoVariablesAreCloseNNN(id1,id2,1)}GetVariable(i){return this.variables.get(i)}Solve(){this.SolveP(null)}SolveP(parameters){this.SolvePNS(parameters,{executionLimitExceeded:!1})}SolvePNS(parameters,t){let fixedVarsMoved;do{this.solution=null;let solverParameters=null;if(null!=parameters&&(solverParameters=parameters,null==solverParameters))throw new Error("parameters");this.solution=this.solver.SolvePar(solverParameters),t.executionLimitExceeded=this.solution.ExecutionLimitExceeded,fixedVarsMoved=this.AdjustConstraintsForMovedFixedVars()}while(fixedVarsMoved&&0==this.solution.ExecutionLimitExceeded);return 0==this.solution.ExecutionLimitExceeded}AdjustConstraintsForMovedFixedVars(){const movedFixedVars=new Set;for(const[k,v]of this.fixedVars.entries())SolverShell.Close(v,this.GetVariableResolvedPosition(k))||movedFixedVars.add(k);return 0!=movedFixedVars.size&&this.AdjustConstraintsForMovedFixedVarSet(movedFixedVars)}static Close(a,b){return Math.abs(a-b)<5e-4}AdjustConstraintsForMovedFixedVarSet(movedFixedVars){for(;movedFixedVars.size>0;){let fixedVar;for(const t of movedFixedVars){fixedVar=t;break}if(!this.AdjustSubtreeOfFixedVar(fixedVar,movedFixedVars))return!1}return!0}AdjustSubtreeOfFixedVar(fixedVar,movedFixedVars){const t={successInAdjusting:!1},neighbors=this.AdjustConstraintsOfNeighborsOfFixedVariable(fixedVar,t);if(!t.successInAdjusting)return!1;if(0==neighbors.length)return!1;for(const i of neighbors)movedFixedVars.delete(i);return!0}AdjustConstraintsOfNeighborsOfFixedVariable(fixedVar,t){const nbs=this.variables.get(fixedVar).Block.Variables,currentSpan=new RealNumberSpan,idealSpan=new RealNumberSpan;let scale=1;for(const u of nbs)this.fixedVars.has(u.UserData)&&(currentSpan.AddValue(u.ActualPos),idealSpan.AddValue(u.DesiredPos),idealSpan.length>0&&(scale=Math.max(scale,currentSpan.length/idealSpan.length)));return 1==scale&&(scale=2),t.successInAdjusting=this.FixActiveConstraints(nbs,scale),nbs.map((u=>u.UserData))}FixActiveConstraints(neighbs,scale){let ret=!1;for(const v of neighbs)for(const c of v.LeftConstraints)c.IsActive&&(c.Gap>this.FailToAdjustEpsilon&&(ret=!0),this.solver.SetConstraintUpdate(c,c.Gap/scale));return ret}GetVariableResolvedPosition(id){const v=this.GetVariable(id);return null==v?0:v.ActualPos}InitSolver(){this.solver=new Solver,this.variables.clear()}AddFixedVariable(id,position){this.AddVariableWithIdealPositionNNN(id,position,SolverShell.FixedVarWeight),this.fixedVars.set(id,position)}ContainsVariable(v){return this.variables.has(v)}GetVariableIdealPosition(v){return this.variables.get(v).DesiredPos}get Solution(){return this.solution}}SolverShell.FixedVarWeight=1e9;class UniformSolverVar{constructor(){this.lowBound=Number.NEGATIVE_INFINITY,this.upperBound=Number.POSITIVE_INFINITY}get Position(){return this.position}set Position(value){value<this.lowBound?this.position=this.lowBound:value>this.upperBound?this.position=this.upperBound:this.position=value}get LowBound(){return this.lowBound}set LowBound(value){this.lowBound=value}get UpperBound(){return this.upperBound}set UpperBound(value){this.upperBound=value}toString(){return this.lowBound+" "+this.Position+" "+this.upperBound}}class UniformOneDimensionalSolver{constructor(variableSeparation){this.idealPositions=new Map,this.varList=new Array,this.constraints=new Set,this.solverShell=new SolverShell,this.boundsToInt=new Map,this.varSepartion=variableSeparation}SetLowBound(bound,id){const v=this.Var(id);v.LowBound=Math.max(bound,v.LowBound)}Var(id){return this.varList[id]}SetUpperBound(id,bound){const v=this.Var(id);v.UpperBound=Math.min(bound,v.UpperBound)}Solve(){this.SolveByRegularSolver()}SolveByRegularSolver(){this.CreateVariablesForBounds();for(let i=0;i<this.varList.length;i++){const v=this.varList[i];v.IsFixed?this.solverShell.AddFixedVariable(i,v.Position):(this.solverShell.AddVariableWithIdealPositionNN(i,this.idealPositions.get(i)),v.LowBound!=Number.NEGATIVE_INFINITY&&this.constraints.add(new IntPair(this.GetBoundId(v.LowBound),i)),v.UpperBound!=Number.POSITIVE_INFINITY&&this.constraints.add(new IntPair(i,this.GetBoundId(v.UpperBound))))}this.CreateGraphAndRemoveCycles();for(const edge of this.graph.edges){let w=0;edge.x<this.varList.length&&(w+=this.varList[edge.x].Width),edge.y<this.varList.length&&(w+=this.varList[edge.y].Width),w/=2,this.solverShell.AddLeftRightSeparationConstraintNNN(edge.x,edge.y,this.varSepartion+w)}this.solverShell.Solve();for(let i=0;i<this.varList.length;i++)this.varList[i].Position=this.solverShell.GetVariableResolvedPosition(i)}GetBoundId(bound){return this.boundsToInt.get(bound)}CreateVariablesForBounds(){for(const v of this.varList)v.IsFixed||(v.LowBound!=Number.NEGATIVE_INFINITY&&this.RegisterBoundVar(v.LowBound),v.UpperBound!=Number.POSITIVE_INFINITY&&this.RegisterBoundVar(v.UpperBound))}RegisterBoundVar(bound){if(!this.boundsToInt.has(bound)){const varIndex=this.varList.length+this.boundsToInt.size;this.boundsToInt.set(bound,varIndex),this.solverShell.AddFixedVariable(varIndex,bound)}}CreateGraphAndRemoveCycles(){this.graph=mkGraphOnEdgesN(Array.from(this.constraints),this.varList.length+this.boundsToInt.size);const feedbackSet=CycleRemoval.getFeedbackSet(this.graph);if(null!=feedbackSet)for(const edge of feedbackSet)this.graph.removeEdge(edge)}GetVariablePosition(id){return this.varList[id].Position}AddConstraint(i,j){this.constraints.add(new IntPair(i,j))}AddVariableNNNN(id,currentPosition,idealPosition,width){this.idealPositions.set(id,idealPosition),this.AddVariableNNBN(id,currentPosition,!1,width)}AddFixedVariable(id,position){this.AddVariableNNBN(id,position,!0,0)}AddVariableNNBN(id,position,isFixed,width){const v=new UniformSolverVar;v.Position=position,v.IsFixed=isFixed,v.Width=width,this.varList.push(v)}}class AxisEdge extends VisibilityEdge{constructor(source,target){super(source,target),this.RightNeighbors=new Set,this.setOfLongestSegs=new Set,this.RightBound=Number.POSITIVE_INFINITY,this.LeftBound=Number.NEGATIVE_INFINITY,this.Direction=CompassVector.DirectionFromPointToPoint(source.point,target.point)}AddRightNeighbor(edge){this.RightNeighbors.add(edge)}get LongestNudgedSegments(){return this.setOfLongestSegs}AddLongestNudgedSegment(segment){this.setOfLongestSegs.add(segment)}BoundFromRight(rightbound){rightbound=Math.max(rightbound,this.LeftBound),this.RightBound=Math.min(rightbound,this.RightBound)}BoundFromLeft(leftbound){leftbound=Math.min(leftbound,this.RightBound),this.LeftBound=Math.max(leftbound,this.LeftBound)}}class LinkedPoint{constructor(point){this.Point=point}*GetEnumerator(){let p;for(p=this;null!=p;p=p.Next)yield p.Point}get X(){return this.Point.x}get Y(){return this.Point.y}InsertVerts(i,j,points){for(j--;i<j;j--)this.SetNewNext(points[j])}InsertVertsInReverse(i,j,points){for(i++;i<j;i++)this.SetNewNext(points[i])}SetNewNext(p){const nv=new LinkedPoint(p),tmp=this.Next;this.Next=nv,nv.Next=tmp}}class PathEdge{constructor(edgeForNudging,width){this.IsFixed=!1,this.Reversed=!1,this.index=-1,this.AxisEdge=edgeForNudging,this.Width=width}toString(){return this.Source+" "+this.Target}get LongestNudgedSegment(){return this.longestNudgedSegment}set LongestNudgedSegment(value){this.longestNudgedSegment=value,null!=this.longestNudgedSegment&&(this.longestNudgedSegment.AddEdge(this),this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment))}get Source(){return this.Reversed?this.AxisEdge.TargetPoint:this.AxisEdge.SourcePoint}get Target(){return this.Reversed?this.AxisEdge.SourcePoint:this.AxisEdge.TargetPoint}static VectorsAreParallel(a,b){return closeDistEps(a.x*b.y-a.y*b.x,0)}static EdgesAreParallel(edge,pathEdge){return PathEdge.VectorsAreParallel(edge.AxisEdge.TargetPoint.sub(edge.AxisEdge.SourcePoint),pathEdge.AxisEdge.TargetPoint.sub(pathEdge.AxisEdge.SourcePoint))}get Direction(){return this.Reversed?CompassVector.OppositeDir(this.AxisEdge.Direction):this.AxisEdge.Direction}get Index(){return this.index}set Index(value){this.index=value}}class CombinatorialNudger{constructor(paths){this.pathVisibilityGraph=new VisibilityGraph,this.axisEdgesToPathOrders=new Map,this.OriginalPaths=paths}get PathVisibilityGraph(){return this.pathVisibilityGraph}GetOrder(){return this.FillTheVisibilityGraphByWalkingThePaths(),this.InitPathOrder(),this.OrderPaths(),this.axisEdgesToPathOrders}FillTheVisibilityGraphByWalkingThePaths(){for(const path of this.OriginalPaths)this.FillTheVisibilityGraphByWalkingPath(path)}FillTheVisibilityGraphByWalkingPath(path){const pathEdgesEnum=this.CreatePathEdgesFromPoints(function*it(){if(path.PathPoints instanceof LinkedPoint)for(let p=path.PathPoints;null!=p;p=p.Next)yield p.Point;else for(const p of path.PathPoints)yield p}(),path.Width);let t=pathEdgesEnum.next();for(t.done||path.SetFirstEdge(t.value);0==(t=pathEdgesEnum.next()).done;)path.AddEdge(t.value)}*CreatePathEdgesFromPoints(pathPoints,width){let t=pathPoints.next(),p0=t.value;for(;!(t=pathPoints.next()).done;)yield this.CreatePathEdge(p0,t.value,width),p0=t.value}CreatePathEdge(p0,p1,width){switch(CompassVector.DirectionFromPointToPoint(p0,p1)){case Direction.East:case Direction.North:return new PathEdge(this.GetAxisEdge(p0,p1),width);case Direction.South:case Direction.West:{const e=new PathEdge(this.GetAxisEdge(p1,p0),width);return e.Reversed=!0,e}default:throw new Error("Not a rectilinear path")}}GetAxisEdge(p0,p1){return this.PathVisibilityGraph.AddEdgeF(p0,p1,((m,n)=>new AxisEdge(m,n)))}InitPathOrder(){for(const axisEdge of this.PathVisibilityGraph.Edges)this.axisEdgesToPathOrders.set(axisEdge,new Array);for(const p of this.OriginalPaths)for(const pathEdge of p.PathEdges())this.axisEdgesToPathOrders.get(pathEdge.AxisEdge).push(pathEdge)}OrderPaths(){for(const axisEdge of CombinatorialNudger.WalkGraphEdgesInTopologicalOrderIfPossible(this.PathVisibilityGraph))this.OrderPathEdgesSharingEdge(axisEdge)}OrderPathEdgesSharingEdge(edge){const pathOrder=this.PathOrderOfVisEdge(edge);pathOrder.sort(CombinatorialNudger.CompareTwoPathEdges);let i=0;for(const pathEdge of pathOrder)pathEdge.Index=i++}static CompareTwoPathEdges(x,y){if(x==y)return 0;const r=CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(x,y,x.AxisEdge,x.AxisEdge.Direction);return 0!=r?r:-CombinatorialNudger.CompareInDirectionStartingFromAxisEdge(x,y,x.AxisEdge,CompassVector.OppositeDir(x.AxisEdge.Direction))}static CompareInDirectionStartingFromAxisEdge(x,y,axisEdge,direction){for(;;){if(null==(x=CombinatorialNudger.GetNextPathEdgeInDirection(x,axisEdge,direction)))return 0;if(null==(y=CombinatorialNudger.GetNextPathEdgeInDirection(y,axisEdge,direction)))return 0;if(x.AxisEdge==y.AxisEdge){direction=CombinatorialNudger.FindContinuedDirection(axisEdge,direction,x.AxisEdge),axisEdge=x.AxisEdge;const r=CombinatorialNudger.GetExistingOrder(x,y);if(r==CombinatorialNudger.NotOrdered)continue;return direction==axisEdge.Direction?r:-r}const forkVertex=direction==axisEdge.Direction?axisEdge.Target:axisEdge.Source,xFork=CombinatorialNudger.OtherVertex(x.AxisEdge,forkVertex),yFork=CombinatorialNudger.OtherVertex(y.AxisEdge,forkVertex),projection=CombinatorialNudger.ProjectionForCompare(axisEdge,direction!=axisEdge.Direction);return compareNumbers(projection(xFork.point),projection(yFork.point))}}static FindContinuedDirection(edge,direction,nextAxisEdge){return edge.Direction==direction?nextAxisEdge.Source==edge.Target?nextAxisEdge.Direction:CompassVector.OppositeDir(nextAxisEdge.Direction):nextAxisEdge.Source==edge.Source?nextAxisEdge.Direction:CompassVector.OppositeDir(nextAxisEdge.Direction)}static OtherVertex(axisEdge,v){return axisEdge.Source==v?axisEdge.Target:axisEdge.Source}static ProjectionForCompare(axisEdge,isReversed){return axisEdge.Direction==Direction.North?isReversed?p=>-p.x:p=>p.x:isReversed?p=>p.y:p=>-p.y}static GetNextPathEdgeInDirection(e,axisEdge,direction){return axisEdge.Direction==direction?e.Reversed?e.Prev:e.Next:e.Reversed?e.Next:e.Prev}static GetExistingOrder(x,y){const xi=x.Index;if(-1==xi)return CombinatorialNudger.NotOrdered;return compareNumbers(xi,y.Index)}PathOrderOfVisEdge(axisEdge){return this.axisEdgesToPathOrders.get(axisEdge)}static InitQueueOfSources(queue,dictionary,graph){for(const v of graph.Vertices()){const inDegree=v.InEdgesLength();dictionary.set(v,inDegree),0==inDegree&&queue.enqueue(v)}}static*WalkGraphEdgesInTopologicalOrderIfPossible(visibilityGraph){const sourcesQueue=new src.o,inDegreeLeftUnprocessed=new Map;for(CombinatorialNudger.InitQueueOfSources(sourcesQueue,inDegreeLeftUnprocessed,visibilityGraph);sourcesQueue.length>0;){const visVertex=sourcesQueue.dequeue();for(const edge of visVertex.OutEdges){const incomingEdges=inDegreeLeftUnprocessed.get(edge.Target);inDegreeLeftUnprocessed.set(edge.Target,incomingEdges-1),1==incomingEdges&&sourcesQueue.enqueue(edge.Target),yield edge}}}}CombinatorialNudger.NotOrdered=Number.MAX_VALUE;class AxisEdgeHighPointEvent extends SweepEvent{constructor(edge,point){super(),this.site=point,this.AxisEdge=edge}get Site(){return this.site}}class AxisEdgeLowPointEvent extends SweepEvent{constructor(edge,point){super(),this.site=point,this.AxisEdge=edge}get Site(){return this.site}}class AxisEdgesContainer{constructor(source){this.edges=new Set,this.Source=source}get Edges(){return this.edges}AddEdge(edge){this.UpPoint=edge.TargetPoint,this.edges.add(edge)}RemoveAxis(edge){this.edges.delete(edge)}IsEmpty(){return 0==this.edges.size}}class FreeSpaceFinder extends LineSweeperBase{constructor(direction,obstacles,axisEdgesToObstaclesTheyOriginatedFrom,pathOrders,axisEdges){super(obstacles,new CompassVector(direction).ToPoint()),this.DirectionPerp=new CompassVector(direction).Right.ToPoint(),this.PathOrders=pathOrders,this.xProjection=direction==Direction.North?p=>p.x:p=>-p.y,this.edgeContainersTree=new RBTree(((a,b)=>this.CompareAA(a,b))),this.SweepPole=CompassVector.VectorDirection(this.SweepDirection),this.AxisEdges=axisEdges,this.AxisEdgesToObstaclesTheyOriginatedFrom=axisEdgesToObstaclesTheyOriginatedFrom}FindFreeSpace(){this.InitTheQueueOfEvents(),this.ProcessEvents()}ProcessEvents(){for(;this.EventQueue.Count>0;)this.ProcessEvent(this.EventQueue.Dequeue())}ProcessEvent(sweepEvent){sweepEvent instanceof VertexEvent?this.ProcessVertexEvent(sweepEvent):(this.Z=this.GetZP(sweepEvent.Site),sweepEvent instanceof AxisEdgeLowPointEvent?this.ProcessLowEdgeEvent(sweepEvent):this.ProcessHighEdgeEvent(sweepEvent))}ProcessHighEdgeEvent(edgeForNudgingHighPointEvent){const edge=edgeForNudgingHighPointEvent.AxisEdge;this.RemoveEdge(edge),this.ConstraintEdgeWithObstaclesAtZ(edge,edge.Target.point)}ProcessLowEdgeEvent(lowEdgeEvent){const edge=lowEdgeEvent.AxisEdge,containerNode=this.GetOrCreateAxisEdgesContainer(edge);containerNode.item.AddEdge(edge);const prev=this.edgeContainersTree.previous(containerNode);if(null!=prev)for(const prevEdge of prev.item.edges)for(const ed of containerNode.item.edges)this.TryToAddRightNeighbor(prevEdge,ed);const next=this.edgeContainersTree.next(containerNode);if(null!=next)for(const ed of containerNode.item.Edges)for(const neEdge of next.item.edges)this.TryToAddRightNeighbor(ed,neEdge);this.ConstraintEdgeWithObstaclesAtZ(edge,edge.Source.point)}TryToAddRightNeighbor(leftEdge,rightEdge){this.ProjectionsOfEdgesOverlap(leftEdge,rightEdge)&&leftEdge.AddRightNeighbor(rightEdge)}ProjectionsOfEdgesOverlap(leftEdge,rightEdge){return this.SweepPole==Direction.North?!(leftEdge.TargetPoint.y<rightEdge.SourcePoint.y-GeomConstants.distanceEpsilon||rightEdge.TargetPoint.y<leftEdge.SourcePoint.y-GeomConstants.distanceEpsilon):!(leftEdge.TargetPoint.x<rightEdge.SourcePoint.x-GeomConstants.distanceEpsilon||rightEdge.TargetPoint.x<leftEdge.SourcePoint.x-GeomConstants.distanceEpsilon)}GetObstacleBoundaries(color){return this.Obstacles.map((p=>debugCurve_DebugCurve.mkDebugCurveWCI(1,color,p)))}ConstraintEdgeWithObstaclesAtZ(edge,point){this.ConstraintEdgeWithObstaclesAtZFromLeft(edge,point),this.ConstraintEdgeWithObstaclesAtZFromRight(edge,point)}ConstraintEdgeWithObstaclesAtZFromRight(edge,point){const node=this.GetActiveSideFromRight(point);if(null==node)return;if(this.NotRestricting(edge,node.item.Polyline))return;const x=this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(node.item);edge.BoundFromRight(x.dot(this.DirectionPerp))}GetActiveSideFromRight(point){return this.LeftObstacleSideTree.findFirst((side=>FreeSpaceFinder.PointToTheLeftOfLineOrOnLineLocal(point,side.Start,side.End)))}ConstraintEdgeWithObstaclesAtZFromLeft(edge,point){const node=this.GetActiveSideFromLeft(point);if(null==node)return;if(this.NotRestricting(edge,node.item.Polyline))return;const x=this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(node.item);edge.BoundFromLeft(x.dot(this.DirectionPerp))}static PointToTheLeftOfLineOrOnLineLocal(a,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(a,linePoint0,linePoint1)>-FreeSpaceFinder.AreaComparisonEpsilon}static PointToTheRightOfLineOrOnLineLocal(a,linePoint0,linePoint1){return point_Point.signedDoubledTriangleArea(linePoint0,linePoint1,a)<FreeSpaceFinder.AreaComparisonEpsilon}GetActiveSideFromLeft(point){return this.RightObstacleSideTree.findLast((side=>FreeSpaceFinder.PointToTheRightOfLineOrOnLineLocal(point,side.Start,side.End)))}static EdgeMidPoint(edge){return point_Point.middle(edge.SourcePoint,edge.TargetPoint)}GetOrCreateAxisEdgesContainer(edge){const source=edge.Source.point,ret=this.GetAxisEdgesContainerNode(source);return null!=ret?ret:this.edgeContainersTree.insert(new AxisEdgesContainer(source))}GetAxisEdgesContainerNode(point){const prj=this.xProjection(point),ret=this.edgeContainersTree.findFirst((cont=>this.xProjection(cont.Source)>=prj-GeomConstants.distanceEpsilon/2));return null!=ret&&this.xProjection(ret.item.Source)<=prj+GeomConstants.distanceEpsilon/2?ret:null}ProcessVertexEvent(vertexEvent){this.Z=this.GetZS(vertexEvent),vertexEvent instanceof LeftVertexEvent?this.ProcessLeftVertex(vertexEvent,vertexEvent.Vertex.nextOnPolyline):(vertexEvent instanceof RightVertexEvent||this.ProcessLeftVertex(vertexEvent,vertexEvent.Vertex.nextOnPolyline),this.ProcessRightVertex(vertexEvent,vertexEvent.Vertex.prevOnPolyline))}ProcessRightVertex(rightVertexEvent,nextVertex){const site=rightVertexEvent.Site;this.ProcessPrevSegmentForRightVertex(rightVertexEvent,site);const delta=nextVertex.point.sub(rightVertexEvent.Site),deltaX=delta.dot(this.DirectionPerp),deltaZ=delta.dot(this.SweepDirection);deltaZ<=GeomConstants.distanceEpsilon?deltaX>0&&deltaZ>=0?this.EnqueueEvent(new RightVertexEvent(nextVertex)):this.RestrictEdgeContainerToTheRightOfEvent(rightVertexEvent.Vertex):(this.InsertRightSide(new RightObstacleSide(rightVertexEvent.Vertex)),this.EnqueueEvent(new RightVertexEvent(nextVertex)),this.RestrictEdgeContainerToTheRightOfEvent(rightVertexEvent.Vertex))}RestrictEdgeContainerToTheRightOfEvent(polylinePoint){const site=polylinePoint.point,siteX=this.xProjection(site),containerNode=this.edgeContainersTree.findFirst((container=>siteX<=this.xProjection(container.Source)));if(null!=containerNode)for(const edge of containerNode.item.Edges)this.NotRestricting(edge,polylinePoint.polyline)||edge.BoundFromLeft(this.DirectionPerp.dot(site))}NotRestricting(edge,polyline){return this.AxisEdgesToObstaclesTheyOriginatedFrom.get(edge)==polyline}ProcessPrevSegmentForRightVertex(rightVertexEvent,site){const prevSite=rightVertexEvent.Vertex.nextOnPolyline.point;site.sub(prevSite).dot(this.SweepDirection)>GeomConstants.distanceEpsilon&&this.RemoveRightSide(new RightObstacleSide(rightVertexEvent.Vertex.nextOnPolyline))}RemoveEdge(edge){const containerNode=this.GetAxisEdgesContainerNode(edge.Source.point);containerNode.item.RemoveAxis(edge),containerNode.item.IsEmpty()&&this.edgeContainersTree.deleteNodeInternal(containerNode)}ProcessLeftVertex(leftVertexEvent,nextVertex){const site=leftVertexEvent.Site;this.ProcessPrevSegmentForLeftVertex(leftVertexEvent,site);const delta=nextVertex.point.sub(leftVertexEvent.Site),deltaX=delta.dot(this.DirectionPerp),deltaZ=delta.dot(this.SweepDirection);deltaZ<=GeomConstants.distanceEpsilon?deltaX<0&&deltaZ>=0&&this.EnqueueEvent(new LeftVertexEvent(nextVertex)):(this.InsertLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex)),this.EnqueueEvent(new LeftVertexEvent(nextVertex))),this.RestrictEdgeFromTheLeftOfEvent(leftVertexEvent.Vertex)}RestrictEdgeFromTheLeftOfEvent(polylinePoint){const site=polylinePoint.point,containerNode=this.GetContainerNodeToTheLeftOfEvent(site);if(null!=containerNode)for(const edge of containerNode.item.Edges)this.NotRestricting(edge,polylinePoint.polyline)||edge.BoundFromRight(site.dot(this.DirectionPerp))}GetContainerNodeToTheLeftOfEvent(site){const siteX=this.xProjection(site);return this.edgeContainersTree.findLast((container=>this.xProjection(container.Source)<=siteX))}ProcessPrevSegmentForLeftVertex(leftVertexEvent,site){const prevSite=leftVertexEvent.Vertex.prevOnPolyline.point;site.sub(prevSite).dot(this.SweepDirection)>GeomConstants.distanceEpsilon&&this.RemoveLeftSide(new LeftObstacleSide(leftVertexEvent.Vertex.prevOnPolyline))}InitTheQueueOfEvents(){this.InitQueueOfEvents();for(const axisEdge of this.AxisEdges)this.EnqueueEventsForEdge(axisEdge)}EnqueueEventsForEdge(edge){this.EdgeIsParallelToSweepDir(edge)&&(this.EnqueueEvent(FreeSpaceFinder.EdgeLowPointEvent(edge,edge.Source.point)),this.EnqueueEvent(FreeSpaceFinder.EdgeHighPointEvent(edge,edge.Target.point)))}EdgeIsParallelToSweepDir(edge){return edge.Direction==this.SweepPole||edge.Direction==CompassVector.OppositeDir(this.SweepPole)}static EdgeHighPointEvent(edge,point){return new AxisEdgeHighPointEvent(edge,point)}static EdgeLowPointEvent(edge,point){return new AxisEdgeLowPointEvent(edge,point)}CompareAA(x,y){return compareNumbers(x.Source.dot(this.DirectionPerp),y.Source.dot(this.DirectionPerp))}}FreeSpaceFinder.AreaComparisonEpsilon=GeomConstants.intersectionEpsilon;class LongestNudgedSegment extends SegmentBase{constructor(variable){super(),this.CompassDirection=Direction.None,this.edges=new Array,this._isFixed=!1,this.Id=-1,this.IdealPosition=0,this.Id=variable}get Start(){return this.start}get End(){return this.end}get Edges(){return this.edges}AddEdge(edge){if(0==this.Edges.length){let dir=CompassVector.VectorDirectionPP(edge.Source,edge.Target);switch(dir){case Direction.South:dir=Direction.North;break;case Direction.West:dir=Direction.East}this.CompassDirection=dir,this.start=edge.Source,this.end=edge.Source}switch(this.CompassDirection){case Direction.North:this.TryPointForStartAndEndNorth(edge.Source),this.TryPointForStartAndEndNorth(edge.Target);break;case Direction.East:this.TryPointForStartAndEndEast(edge.Source),this.TryPointForStartAndEndEast(edge.Target)}this.Edges.push(edge)}TryPointForStartAndEndNorth(p){p.y<this.start.y?this.start=p:p.y>this.end.y&&(this.end=p)}TryPointForStartAndEndEast(p){p.x<this.start.x?this.start=p:p.x>this.end.x&&(this.end=p)}get IsFixed(){return this._isFixed}set IsFixed(value){this._isFixed=value}get Width(){let w=0;for(const e of this.edges)w=Math.max(w,e.Width);return w}GetLeftBound(){if(!this.IsFixed){let lb=Number.NEGATIVE_INFINITY;for(const edge of this.edges)lb=Math.max(lb,edge.AxisEdge.LeftBound);return lb}return this.CompassDirection==Direction.North?this.Edges[0].Source.x:-this.Edges[0].Source.y}GetRightBound(){if(!this.IsFixed){let rb=Number.POSITIVE_INFINITY;for(const edge of this.edges)rb=Math.min(rb,edge.AxisEdge.RightBound);return rb}return this.Position()}Position(){return this.CompassDirection==Direction.North?this.Edges[0].Source.x:-this.Edges[0].Source.y}}class LinkedPointSplitter{constructor(horizontalPoints,verticalPoints){this.tree=new RBTree(((a,b)=>compareNumbers(a.Point.x,b.Point.x))),this.VerticalPoints=verticalPoints,this.HorizontalPoints=horizontalPoints}SplitPoints(){0!=this.VerticalPoints.length&&0!=this.HorizontalPoints.length&&(this.InitEventQueue(),this.ProcessEvents())}ProcessEvents(){for(;!this.Queue.IsEmpty();){const t={priority:0},linkedPoint=this.Queue.DequeueAndGetPriority(t);this.ProcessEvent(linkedPoint,t.priority)}}ProcessEvent(linkedPoint,z){closeDistEps(linkedPoint.Next.Point.x,linkedPoint.Point.x)?z==LinkedPointSplitter.Low(linkedPoint)?this.ProcessLowLinkedPointEvent(linkedPoint):this.ProcessHighLinkedPointEvent(linkedPoint):this.IntersectWithTree(linkedPoint)}IntersectWithTree(horizontalPoint){let right,left,xAligned;const y=horizontalPoint.Y;if(horizontalPoint.Point.x<horizontalPoint.Next.Point.x?(left=horizontalPoint.Point.x,right=horizontalPoint.Next.Point.x,xAligned=!0):(right=horizontalPoint.Point.x,left=horizontalPoint.Next.Point.x,xAligned=!1),xAligned)for(let node=this.tree.findFirst((p=>left<=p.Point.x));null!=node&&node.item.Point.x<=right;node=this.tree.next(node)){const p=new point_Point(node.item.Point.x,y);horizontalPoint=LinkedPointSplitter.TrySplitHorizontalPoint(horizontalPoint,p,!0),LinkedPointSplitter.TrySplitVerticalPoint(node.item,p)}else for(let node=this.tree.findLast((p=>p.Point.x<=right));null!=node&&node.item.Point.x>=left;node=this.tree.previous(node)){const p=new point_Point(node.item.Point.x,y);horizontalPoint=LinkedPointSplitter.TrySplitHorizontalPoint(horizontalPoint,p,!1),LinkedPointSplitter.TrySplitVerticalPoint(node.item,p)}}static TrySplitVerticalPoint(linkedPoint,point){LinkedPointSplitter.Low(linkedPoint)+GeomConstants.distanceEpsilon<point.y&&point.y+GeomConstants.distanceEpsilon<LinkedPointSplitter.High(linkedPoint)&&linkedPoint.SetNewNext(point)}static TrySplitHorizontalPoint(horizontalPoint,point,xAligned){return xAligned&&horizontalPoint.X+GeomConstants.distanceEpsilon<point.x&&point.x+GeomConstants.distanceEpsilon<horizontalPoint.Next.X||!xAligned&&horizontalPoint.Next.X+GeomConstants.distanceEpsilon<point.x&&point.x+GeomConstants.distanceEpsilon<horizontalPoint.X?(horizontalPoint.SetNewNext(point),horizontalPoint.Next):horizontalPoint}ProcessHighLinkedPointEvent(linkedPoint){this.tree.remove(linkedPoint)}ProcessLowLinkedPointEvent(linkedPoint){this.tree.insert(linkedPoint)}InitEventQueue(){this.Queue=new GenericBinaryHeapPriorityQueue(compareNumbers);for(const vertPoint of this.VerticalPoints)this.Queue.Enqueue(vertPoint,LinkedPointSplitter.Low(vertPoint));for(const horizPoint of this.HorizontalPoints)this.Queue.Enqueue(horizPoint,horizPoint.Point.y)}static Low(vertPoint){return Math.min(vertPoint.Point.y,vertPoint.Next.Point.y)}static High(vertPoint){return Math.max(vertPoint.Point.y,vertPoint.Next.Point.y)}}class PathMerger{constructor(paths){this.verticesToPathOffsets=new PointMap,this.Paths=paths}MergePaths(){this.InitVerticesToPathOffsetsAndRemoveSelfCycles();for(const path of this.Paths)this.ProcessPath(path)}ProcessPath(path){const departedPaths=new Map;let prevLocationPathOffsets=null;for(let linkedPoint=path.PathPoints;null!=linkedPoint;linkedPoint=linkedPoint.Next){const pathOffsets=this.verticesToPathOffsets.get(linkedPoint.Point);if(null!=prevLocationPathOffsets){if(departedPaths.size>0)for(const[path0,v]of pathOffsets){const departerLinkedPoint=departedPaths.get(path0);departerLinkedPoint&&(this.CollapseLoopingPath(path0,departerLinkedPoint,v,path,linkedPoint),departedPaths.delete(path0))}for(const[k,v]of prevLocationPathOffsets)pathOffsets.has(k)||departedPaths.set(k,v)}prevLocationPathOffsets=pathOffsets}}CollapseLoopingPath(loopingPath,departureFromLooping,arrivalToLooping,stemPath,arrivalToStem){const departurePointOnStem=PathMerger.FindLinkedPointInPath(stemPath,departureFromLooping.Point),pointsToInsert=Array.from(PathMerger.GetPointsInBetween(departurePointOnStem,arrivalToStem));PathMerger.Before(departureFromLooping,arrivalToLooping)?(this.CleanDisappearedPiece(departureFromLooping,arrivalToLooping,loopingPath),this.ReplacePiece(departureFromLooping,arrivalToLooping,pointsToInsert,loopingPath)):(this.CleanDisappearedPiece(arrivalToLooping,departureFromLooping,loopingPath),this.ReplacePiece(arrivalToLooping,departureFromLooping,pointsToInsert.reverse(),loopingPath))}static*GetPointsInBetween(a,b){for(let i=a.Next;i!=b;i=i.Next)yield i.Point}ReplacePiece(a,b,points,loopingPath){let prevPoint=a;for(const point of points){const lp=new LinkedPoint(point);prevPoint.Next=lp,prevPoint=lp;this.verticesToPathOffsets.get(point).set(loopingPath,prevPoint)}prevPoint.Next=b}CleanDisappearedPiece(a,b,loopingPath){for(const point of PathMerger.GetPointsInBetween(a,b)){this.verticesToPathOffsets.get(point).delete(loopingPath)}}static Before(a,b){for(a=a.Next;null!=a;a=a.Next)if(a==b)return!0;return!1}static FindLinkedPointInPath(path,point){for(let linkedPoint=path.PathPoints;;linkedPoint=linkedPoint.Next)if(linkedPoint.Point.equal(point))return linkedPoint}InitVerticesToPathOffsetsAndRemoveSelfCycles(){for(const path of this.Paths)for(let linkedPoint=path.PathPoints;null!=linkedPoint;linkedPoint=linkedPoint.Next){let pathOffsets=this.verticesToPathOffsets.get(linkedPoint.Point);pathOffsets||this.verticesToPathOffsets.set(linkedPoint.Point,pathOffsets=new Map);const loopPoint=pathOffsets.get(path);loopPoint?(this.CleanDisappearedPiece(loopPoint,linkedPoint,path),loopPoint.Next=linkedPoint.Next):pathOffsets.set(path,linkedPoint)}}}class PointByDelegateComparer{constructor(projection){this.projection=projection}compare(x,y){return compareNumbers(this.projection(x),this.projection(y))}}class PathRefiner{static RefinePaths(paths,mergePaths){PathRefiner.AdjustPaths(paths);const pathsToFirstLinkedVertices=PathRefiner.CreatePathsToFirstLinkedVerticesMap(paths);PathRefiner.Refine(Array.from(pathsToFirstLinkedVertices.values())),PathRefiner.CrossVerticalAndHorizontalSegs(pathsToFirstLinkedVertices.values()),PathRefiner.ReconstructPathsFromLinkedVertices(pathsToFirstLinkedVertices),mergePaths&&new PathMerger(paths).MergePaths()}static AdjustPaths(paths){for(const path of paths)path.PathPoints=PathRefiner.AdjustPathPoints(path.PathPoints)}static AdjustPathPoints(points){if(!points||0==points.length)return;const arr=[];let p=GeomConstants.RoundPoint(points[0]);arr.push(p);for(let i=1;i<points.length;i++){const np=GeomConstants.RoundPoint(points[i]);p.equal(np)||(p=np,arr.push(p))}return arr}static CrossVerticalAndHorizontalSegs(pathsFirstLinked){const horizontalPoints=new Array,verticalPoints=new Array;for(const pnt of pathsFirstLinked)for(let p=pnt;null!=p.Next;p=p.Next)closeDistEps(p.Point.x,p.Next.Point.x)?verticalPoints.push(p):horizontalPoints.push(p);new LinkedPointSplitter(horizontalPoints,verticalPoints).SplitPoints()}static ReconstructPathsFromLinkedVertices(pathsToPathLinkedPoints){for(const[k,v]of pathsToPathLinkedPoints)k.PathPoints=v}static Refine(pathFirstPoints){PathRefiner.RefineInDirection(Direction.North,pathFirstPoints),PathRefiner.RefineInDirection(Direction.East,pathFirstPoints)}static*groupByProj(proj,linkedPointsInDirection){const map=new Map;for(const lp of linkedPointsInDirection){const p=proj(lp.Point);let arr=map.get(p);arr||(arr=new Array,map.set(p,arr)),arr.push(lp)}for(const v of map.values())yield v}static RefineInDirection(direction,pathFirstPoints){const t={projectionToPerp:void 0,projectionToDirection:void 0};PathRefiner.GetProjectionsDelegates(direction,t);const linkedPointsInDirection=Array.from(PathRefiner.GetAllLinkedVertsInDirection(t.projectionToPerp,pathFirstPoints)),colliniarBuckets=PathRefiner.groupByProj(t.projectionToPerp,linkedPointsInDirection);for(const pathLinkedPointBucket of colliniarBuckets)PathRefiner.RefineCollinearBucket(pathLinkedPointBucket,t.projectionToDirection)}static GetProjectionsDelegates(direction,t){direction==Direction.East?(t.projectionToDirection=p=>p.x,t.projectionToPerp=p=>p.y):(t.projectionToPerp=p=>p.x,t.projectionToDirection=p=>p.y)}static*GetAllLinkedVertsInDirection(projectionToPerp,initialVerts){for(const vert of initialVerts)for(let v=vert;null!=v.Next;v=v.Next)closeDistEps(projectionToPerp(v.Point),projectionToPerp(v.Next.Point))&&(yield v)}static RefineCollinearBucket(pathLinkedVertices,projectionToDirection){const dict=new SortedMap(new PointByDelegateComparer(projectionToDirection));for(const pathLinkedPoint of pathLinkedVertices)dict.has(pathLinkedPoint.Point)||dict.set(pathLinkedPoint.Point,0),dict.has(pathLinkedPoint.Next.Point)||dict.set(pathLinkedPoint.Next.Point,0);const arrayOfPoints=new Array(dict.size);let i=0;for(const point of dict.keys())arrayOfPoints[i++]=point;for(i=0;i<arrayOfPoints.length;i++)dict.set(arrayOfPoints[i],i);for(const pathLinkedVertex of pathLinkedVertices){i=dict.get(pathLinkedVertex.Point);const j=dict.get(pathLinkedVertex.Next.Point);Math.abs(j-i)>1&&PathRefiner.InsertPoints(pathLinkedVertex,arrayOfPoints,i,j)}}static InsertPoints(pathLinkedVertex,arrayOfPoints,i,j){i<j?pathLinkedVertex.InsertVerts(i,j,arrayOfPoints):pathLinkedVertex.InsertVertsInReverse(j,i,arrayOfPoints)}static CreatePathsToFirstLinkedVerticesMap(edgePaths){const dict=new Map;for(const path of edgePaths)dict.set(path,PathRefiner.CreateLinkedVertexOfEdgePath(path));return dict}static CreateLinkedVertexOfEdgePath(path){const arr=path.PathPoints;let pathPoint=new LinkedPoint(arr[0]);const first=pathPoint;for(let i=1;i<arr.length;i++)pathPoint.Next=new LinkedPoint(arr[i]),pathPoint=pathPoint.Next;return first}}class SegWithIndex{constructor(pts,i){this.Points=pts,this.I=i}static equal(a,b){return a.I==b.I&&a.Points==b.Points}get Start(){return this.Points[this.I]}get End(){return this.Points[this.I+1]}}class StaircaseRemover{constructor(paths,hierarchyOfObstacles){this.segTree=new RTree(null),this.crossedOutPaths=new Set,this.HierarchyOfObstacles=new RTree(hierarchyOfObstacles),this.Paths=paths}static RemoveStaircases(paths,hierarchyOfObstacles){new StaircaseRemover(paths,hierarchyOfObstacles).Calculate()}Calculate(){let success;this.InitHierarchies();do{success=!1;for(const path of this.Paths.filter((p=>!this.crossedOutPaths.has(p))))this.ProcessPath(path)&&(success=!0)}while(success)}ProcessPath(path){const t={pts:path.PathPoints,canHaveStaircase:!1};return this.ProcessPoints(t)?(path.PathPoints=t.pts,!0):(t.canHaveStaircase||this.crossedOutPaths.add(path),!1)}ProcessPoints(t){const staircaseStart=this.FindStaircaseStart(t);return!(staircaseStart<0)&&(t.pts=this.RemoveStaircasePN(t.pts,staircaseStart),!0)}FindStaircaseStart(t){if(t.canHaveStaircase=!1,t.pts.length<5)return-1;const segs=[new SegWithIndex(t.pts,0),new SegWithIndex(t.pts,1),new SegWithIndex(t.pts,2),new SegWithIndex(t.pts,3)];let segToReplace=0;for(let i=0;;){const w={canHaveStaircaseAtI:!1};if(this.IsStaircase(t.pts,i,segs,w))return t.canHaveStaircase=!0,i;if(t.canHaveStaircase=t.canHaveStaircase||w.canHaveStaircaseAtI,i++,t.pts.length<i+5)return-1;segs[segToReplace]=new SegWithIndex(t.pts,i+3),segToReplace++,segToReplace%=4}}static GetFlippedPoint(pts,offset){return closeDistEps(pts[offset].y,pts[offset+1].y)?new point_Point(pts[offset+4].x,pts[offset].y):new point_Point(pts[offset].x,pts[offset+4].y)}Crossing(a,b,segsToIgnore){return StaircaseRemover.IsCrossing(LineSegment.mkPP(a,b),this.segTree,segsToIgnore)}static IsCrossing(ls,rTree,segsToIgnore){for(const seg of rTree.GetAllIntersecting(ls.boundingBox))if(-1==segsToIgnore.findIndex((p=>p==seg)))return!0;return!1}IntersectObstacleHierarchyPPP(a,b,c){return this.IntersectObstacleHierarchyL(LineSegment.mkPP(a,b))||this.IntersectObstacleHierarchyL(LineSegment.mkPP(b,c))}IntersectObstacleHierarchyL(ls){return this.HierarchyOfObstacles.GetAllIntersecting(ls.boundingBox).some((poly=>null!=Curve.intersectionOne(ls,poly,!1)))}IsStaircase(pts,offset,segsToIgnore,w){const a=pts[offset],b=pts[offset+1];let c=pts[offset+2];const d=pts[offset+3],f=pts[offset+4];return w.canHaveStaircaseAtI=!1,CompassVector.DirectionFromPointToPoint(a,b)==CompassVector.DirectionFromPointToPoint(c,d)&&CompassVector.DirectionFromPointToPoint(b,c)==CompassVector.DirectionFromPointToPoint(d,f)&&(c=StaircaseRemover.GetFlippedPoint(pts,offset),!this.IntersectObstacleHierarchyPPP(b,c,d)&&(w.canHaveStaircaseAtI=!0,!this.Crossing(b,c,segsToIgnore)))}RemoveStaircasePN(pts,staircaseStart){const a=pts[staircaseStart],b=pts[staircaseStart+1],horiz=Math.abs(a.y-b.y)<GeomConstants.distanceEpsilon/2;return this.RemoveStaircasePNB(pts,staircaseStart,horiz)}RemoveStaircasePNB(pts,staircaseStart,horiz){this.RemoveSegs(pts);const ret=new Array(pts.length-2);!function ArrayCopyAAN(a,b,length){let i=0;for(;length-- >0;)b[i++]=a[i++]}(pts,ret,staircaseStart+1);const a=pts[staircaseStart+1],c=pts[staircaseStart+3];return ret[staircaseStart+1]=horiz?new point_Point(c.x,a.y):new point_Point(a.x,c.y),function ArrayCopyANANN(a,ai,b,bi,length){for(;length-- >0;)b[bi++]=a[ai++]}(pts,staircaseStart+4,ret,staircaseStart+2,ret.length-staircaseStart-2),this.InsertNewSegs(ret,staircaseStart),ret}RemoveSegs(pts){for(let i=0;i<pts.length-1;i++)this.RemoveSeg(new SegWithIndex(pts,i))}RemoveSeg(seg){this.segTree.Remove(StaircaseRemover.Rect(seg),seg)}InsertNewSegs(pts,staircaseStart){this.InsSeg(pts,staircaseStart),this.InsSeg(pts,staircaseStart+1)}InitHierarchies(){for(const path of this.Paths)this.InsertPathSegs(path)}InsertPathSegs(path){this.InsertSegs(path.PathPoints)}InsertSegs(pts){for(let i=0;i<pts.length-1;i++)this.InsSeg(pts,i)}InsSeg(pts,i){const seg=new SegWithIndex(pts,i);this.segTree.Add(StaircaseRemover.Rect(seg),seg)}static Rect(seg){return Rectangle.mkPP(seg.Start,seg.End)}}class Nudger{constructor(paths,cornerFitRad,obstacles,ancestorsSets){this.AncestorsSets=ancestorsSets,this.HierarchyOfGroups=CreateRectNodeOnArrayOfRectNodes(Array.from(ancestorsSets.keys()).filter((shape=>shape.IsGroup)).map((group=>mkRectangleNode(group,group.BoundingBox)))),this.Obstacles=obstacles,this.EdgeSeparation=2*cornerFitRad,this.Paths=paths,this.HierarchyOfObstacles=CreateRectNodeOnArrayOfRectNodes(obstacles.map((p=>mkRectangleNode(p,p.boundingBox)))),this.MapPathsToTheirObstacles()}get HasGroups(){return null!=this.HierarchyOfGroups&&this.HierarchyOfGroups.Count>0}MapPathsToTheirObstacles(){this.PathToObstacles=new Map;for(const path of this.Paths)this.MapPathToItsObstacles(path)}MapPathToItsObstacles(path){if(!path.PathPoints||0==path.PathPoints.length)return;const fr=path.PathPoints,startNode=this.HierarchyOfObstacles.FirstHitNodeWithPredicate(fr[0],Nudger.ObstacleTest),endNode=this.HierarchyOfObstacles.FirstHitNodeWithPredicate(fr[fr.length-1],Nudger.ObstacleTest);null!=startNode&&null!=endNode&&this.PathToObstacles.set(path,[startNode.UserData,endNode.UserData])}static ObstacleTest(pnt,polyline){return Curve.PointRelativeToCurveLocation(pnt,polyline)!=PointLocation.Outside?HitTestBehavior.Stop:HitTestBehavior.Continue}Calculate(direction,mergePaths){this.NudgingDirection=direction,PathRefiner.RefinePaths(this.Paths,mergePaths),this.GetPathOrdersAndPathGraph(),this.MapAxisEdgesToTheirObstacles(),this.DrawPaths()}MapAxisEdgesToTheirObstacles(){this.axisEdgesToObstaclesTheyOriginatedFrom=new Map;for(const path of this.Paths)this.MapPathEndAxisEdgesToTheirObstacles(path);for(const path of this.Paths)this.UmmapPathInteriourFromStrangerObstacles(path)}UmmapPathInteriourFromStrangerObstacles(path){const firstUnmappedEdge=this.FindFirstUnmappedEdge(path);if(null==firstUnmappedEdge)return;const lastUnmappedEdge=this.FindLastUnmappedEdge(path);for(let edge=firstUnmappedEdge;null!=edge&&edge!=lastUnmappedEdge;edge=edge.Next)this.axisEdgesToObstaclesTheyOriginatedFrom.delete(edge.AxisEdge)}FindLastUnmappedEdge(path){for(let edge=path.LastEdge;null!=edge;edge=edge.Prev)if(edge.AxisEdge.Direction!=this.NudgingDirection)return edge;return null}FindFirstUnmappedEdge(path){for(let edge=path.FirstEdge;null!=edge;edge=edge.Next)if(edge.AxisEdge.Direction!=this.NudgingDirection)return edge;return null}MapPathEndAxisEdgesToTheirObstacles(path){const coupleOfObstacles=this.PathToObstacles.get(path);coupleOfObstacles&&(this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(path,coupleOfObstacles[0]),this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(path,coupleOfObstacles[1]))}ProcessThePathEndToMapAxisEdgesToTheirObstacles(path,endPolyline){for(let edge=path.LastEdge;null!=edge&&CompassVector.DirectionsAreParallel(edge.Direction,this.NudgingDirection);edge=edge.Prev)this.axisEdgesToObstaclesTheyOriginatedFrom.set(edge.AxisEdge,endPolyline)}ProcessThePathStartToMapAxisEdgesToTheirObstacles(path,startPolyline){for(let edge=path.FirstEdge;null!=edge&&CompassVector.DirectionsAreParallel(edge.Direction,this.NudgingDirection);edge=edge.Next)this.axisEdgesToObstaclesTheyOriginatedFrom.set(edge.AxisEdge,startPolyline)}GetPathOrdersAndPathGraph(){const combinatorialNudger=new CombinatorialNudger(this.Paths);this.PathOrders=combinatorialNudger.GetOrder(),this.PathVisibilityGraph=combinatorialNudger.PathVisibilityGraph}static GetCurvesForShow(paths,obstacles){const ret=new Array;for(const path of paths){const poly=new Polyline;for(const point of path.PathPoints)poly.addPoint(point);ret.push(poly)}return ret.concat(Array.from(obstacles))}DrawPaths(){this.SetWidthsOfArrowheads(),this.CreateLongestNudgedSegments(),this.FindFreeSpaceInDirection(Array.from(this.PathVisibilityGraph.Edges)),this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals(),this.PositionShiftedEdges()}SetWidthsOfArrowheads(){for(const edgePath of this.Paths)Nudger.SetWidthsOfArrowheadsForEdge(edgePath)}static SetWidthsOfArrowheadsForEdge(path){const edgeGeom=path.GeomEdge;if(null!=edgeGeom.targetArrowhead){const pathEdge=path.LastEdge;pathEdge.Width=Math.max(edgeGeom.targetArrowhead.width,pathEdge.Width)}if(null!=edgeGeom.sourceArrowhead){const pathEdge=path.FirstEdge;pathEdge.Width=Math.max(edgeGeom.sourceArrowhead.width,pathEdge.Width)}}PositionShiftedEdges(){this.Solver=new UniformOneDimensionalSolver(this.EdgeSeparation);for(let i=0;i<this.LongestNudgedSegs.length;i++)this.CreateVariablesOfLongestSegment(this.LongestNudgedSegs[i]);this.CreateConstraintsOfTheOrder(),this.CreateConstraintsBetweenLongestSegments(),this.Solver.SolveByRegularSolver(),this.ShiftPathEdges()}MoveLongestSegsIdealPositionsInsideFeasibleIntervals(){for(let i=0;i<this.LongestNudgedSegs.length;i++){const seg=this.LongestNudgedSegs[i];Nudger.MoveLongestSegIdealPositionsInsideFeasibleInterval(seg)}}static MoveLongestSegIdealPositionsInsideFeasibleInterval(seg){if(seg.IsFixed)return;const leftBound=seg.GetLeftBound(),rightBound=seg.GetRightBound();seg.IdealPosition<leftBound?seg.IdealPosition=leftBound:seg.IdealPosition>rightBound&&(seg.IdealPosition=rightBound)}ShiftPathEdges(){for(const path of this.Paths)path.PathPoints=this.GetShiftedPoints(path)}GetShiftedPoints(path){return Nudger.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(path))}static Rectilinearise(a,b){if(a.x==b.x||a.y==b.y)return b;return Math.abs(a.x-b.x)<Math.abs(a.y-b.y)?new point_Point(a.x,b.y):new point_Point(b.x,a.y)}GetShiftedPointsSimple(path){const ret=[],edge=path.FirstEdge;ret.push(this.ShiftedPoint(edge.Source,edge.LongestNudgedSegment));for(const e of path.PathEdges())ret.push(this.ShiftedEdgePositionOfTarget(e));return ret}ShiftedEdgePositionOfTarget(e){return null!=e.LongestNudgedSegment||null==e.Next?this.ShiftedPoint(e.Target,e.LongestNudgedSegment):this.ShiftedPoint(e.Next.Source,e.Next.LongestNudgedSegment)}ShiftedPoint(point,segment){if(null==segment)return point;const t=this.Solver.GetVariablePosition(segment.Id);return this.NudgingDirection==Direction.North?new point_Point(t,point.y):new point_Point(point.x,-t)}static LineSegOfLongestSeg(ls,dir){const projectionToDir=dir==Direction.East?p=>p.x:p=>p.y,mm={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};for(const edge of ls.Edges)Nudger.UpdateMinMaxWithPoint(mm,projectionToDir,edge.Source),Nudger.UpdateMinMaxWithPoint(mm,projectionToDir,edge.Target);return dir==Direction.East?new LineSegment(mm.min,-ls.IdealPosition,mm.max,-ls.IdealPosition):new LineSegment(ls.IdealPosition,mm.min,ls.IdealPosition,mm.max)}static UpdateMinMaxWithPoint(mm,projectionToDir,point){const p=projectionToDir(point);mm.min>p&&(mm.min=p),mm.max<p&&(mm.max=p)}CreateConstraintsBetweenLongestSegments(){for(const segment of this.LongestNudgedSegs)this.CreateConstraintsBetweenLongestSegmentsForSegment(segment)}CreateConstraintsBetweenLongestSegmentsForSegment(segment){const rightNeighbors=new Set;for(const pathEdge of segment.Edges){const axisEdge=pathEdge.AxisEdge;if(null!=axisEdge)for(const rightNeiAxisEdge of axisEdge.RightNeighbors)for(const longSeg of rightNeiAxisEdge.LongestNudgedSegments)rightNeighbors.add(longSeg)}for(const seg of rightNeighbors)this.ConstraintTwoLongestSegs(segment,seg)}CreateConstraintsOfTheOrder(){for(const kv of this.PathOrders)Nudger.ParallelToDirection(kv[0],this.NudgingDirection)&&this.CreateConstraintsOfThePathOrder(kv[1])}static ParallelToDirection(edge,direction){switch(direction){case Direction.North:case Direction.South:return closeDistEps(edge.SourcePoint.x,edge.TargetPoint.x);default:return closeDistEps(edge.SourcePoint.y,edge.TargetPoint.y)}}CreateConstraintsOfThePathOrder(pathOrder){let prevEdge=null;for(const pathEdge of pathOrder.filter((p=>null!=p.LongestNudgedSegment)))null!=prevEdge&&this.ConstraintTwoLongestSegs(prevEdge.LongestNudgedSegment,pathEdge.LongestNudgedSegment),prevEdge=pathEdge}ConstraintTwoLongestSegs(prevSeg,seg){prevSeg.IsFixed&&seg.IsFixed||this.Solver.AddConstraint(prevSeg.Id,seg.Id)}CreateVariablesOfLongestSegment(segment){if(segment.IsFixed)this.Solver.AddFixedVariable(segment.Id,Nudger.SegmentPosition(segment,this.NudgingDirection));else{const leftBound=segment.GetLeftBound(),rightBound=segment.GetRightBound();leftBound>=rightBound?(this.Solver.AddFixedVariable(segment.Id,Nudger.SegmentPosition(segment,this.NudgingDirection)),segment.IsFixed=!0):(this.Solver.AddVariableNNNN(segment.Id,Nudger.SegmentPosition(segment,this.NudgingDirection),segment.IdealPosition,segment.Width),leftBound!=Number.NEGATIVE_INFINITY&&this.Solver.SetLowBound(leftBound,segment.Id),rightBound!=Number.POSITIVE_INFINITY&&this.Solver.SetUpperBound(segment.Id,rightBound))}}static SegmentPosition(segment,direction){return direction==Direction.North?segment.Start.x:-segment.Start.y}FindFreeSpaceInDirection(axisEdges){this.BoundAxisEdgesByRectsKnownInAdvance();new FreeSpaceFinder(this.NudgingDirection,this.Obstacles,this.axisEdgesToObstaclesTheyOriginatedFrom,this.PathOrders,axisEdges).FindFreeSpace()}BoundAxisEdgesByRectsKnownInAdvance(){for(const path of this.Paths)this.HasGroups&&this.BoundPathByMinCommonAncestors(path),this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(path)}BoundPathByMinCommonAncestors(path){for(const sh of this.GetMinCommonAncestors(path.GeomEdge)){const rect=sh.BoundingBox;for(const e of path.PathEdges()){const edge=e.AxisEdge;edge.Direction==this.NudgingDirection&&this.BoundAxisEdgeByRect(rect,edge)}}}GetMinCommonAncestors(edge){null==this.PortToShapes&&(this.PortToShapes=Nudger.MapPortsToShapes(this.AncestorsSets.keys()));const commonAncestors=function IntersectSets(a,b){const r=new Set;if(a.size<b.size)for(const x of a)b.has(x)&&r.add(x);else for(const x of b)a.has(x)&&r.add(x);return r}(this.AncestorsForPort(edge.sourcePort),this.AncestorsForPort(edge.targetPort));return Array.from(commonAncestors).filter((anc=>!anc.Children.some((child=>commonAncestors.has(child)))))}AncestorsForPort(port){const shape=this.PortToShapes.get(port);return shape?this.AncestorsSets.get(shape):new Set(this.HierarchyOfGroups.AllHitItems(Rectangle.mkPP(port.Location,port.Location),null))}BoundAxisEdgeAdjacentToObstaclePort(port,axisEdge){null==port.Curve?this.BoundAxisByPoint(port.Location,axisEdge):port.Curve.boundingBox.contains(port.Location)&&this.BoundAxisEdgeByRect(port.Curve.boundingBox,axisEdge)}BoundAxisByPoint(point,axisEdge){null!=axisEdge&&axisEdge.Direction==this.NudgingDirection&&(this.NudgingDirection==Direction.North?(axisEdge.BoundFromLeft(point.x),axisEdge.BoundFromRight(point.x)):(axisEdge.BoundFromLeft(-point.y),axisEdge.BoundFromRight(-point.y)))}BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(path){this.BoundAxisEdgeAdjacentToObstaclePort(path.GeomEdge.sourcePort,path.FirstEdge.AxisEdge),this.BoundAxisEdgeAdjacentToObstaclePort(path.GeomEdge.targetPort,path.LastEdge.AxisEdge)}BoundAxisEdgeByRect(rectangle,axisEdge){null!=axisEdge&&axisEdge.Direction==this.NudgingDirection&&(this.NudgingDirection==Direction.North?(axisEdge.BoundFromLeft(rectangle.left),axisEdge.BoundFromRight(rectangle.right)):(axisEdge.BoundFromLeft(-1*rectangle.top),axisEdge.BoundFromRight(-1*rectangle.bottom)))}CreateLongestNudgedSegments(){const projectionToPerp=this.NudgingDirection==Direction.East?p=>-p.y:p=>p.x;this.LongestNudgedSegs=new Array;for(let i=0;i<this.Paths.length;i++)this.CreateLongestNudgedSegmentsForPath(this.Paths[i],projectionToPerp)}CreateLongestNudgedSegmentsForPath(path,projectionToPerp){this.GoOverPathAndCreateLongSegs(path),Nudger.CalculateIdealPositionsForLongestSegs(path,projectionToPerp)}static CalculateIdealPositionsForLongestSegs(path,projectionToPerp){let currentLongSeg=null,ret=null,prevOffset=projectionToPerp(path.Start);for(const edge of path.PathEdges())if(null!=edge.LongestNudgedSegment){if(currentLongSeg=edge.LongestNudgedSegment,null!=ret){let t;Nudger.SetIdealPositionForSeg(ret,t=projectionToPerp(ret.start),prevOffset,projectionToPerp(currentLongSeg.Start)),prevOffset=t,ret=null}}else null!=currentLongSeg&&(ret=currentLongSeg,currentLongSeg=null);null!=ret?Nudger.SetIdealPositionForSeg(ret,projectionToPerp(ret.Start),prevOffset,projectionToPerp(path.End)):null!=currentLongSeg&&(currentLongSeg.IdealPosition=projectionToPerp(currentLongSeg.Start))}static SetIdealPositionForSeg(segment,segPosition,offset0,offset1){const max=Math.max(offset0,offset1),min=Math.min(offset0,offset1);min+GeomConstants.distanceEpsilon<segPosition?segment.IdealPosition=segPosition<max?.5*(max+min):max:segment.IdealPosition=min}GoOverPathAndCreateLongSegs(path){let currentLongestSeg=null;const oppositeDir=CompassVector.OppositeDir(this.NudgingDirection);for(const edge of path.PathEdges()){const edgeDir=edge.Direction;edgeDir==this.NudgingDirection||edgeDir==oppositeDir?(null==currentLongestSeg?(edge.LongestNudgedSegment=currentLongestSeg=new LongestNudgedSegment(this.LongestNudgedSegs.length),this.LongestNudgedSegs.push(currentLongestSeg)):edge.LongestNudgedSegment=currentLongestSeg,edge.IsFixed&&(currentLongestSeg.IsFixed=!0)):(edge.LongestNudgedSegment=null,currentLongestSeg=null)}}static BuildPolylineForPath(path){const t={points:path.PathPoints.map((p=>p.clone()))};return Nudger.ExtendPolylineToPorts(t,path),t.points}static ExtendPolylineToPorts(t,path){Nudger.ExtendPolylineToSourcePort(t,path.GeomEdge.sourcePort.Location),Nudger.ExtendPolylineToTargetPort(t,path.GeomEdge.targetPort.Location),t.points.length<2&&(t.points=new Array(2),t.points[0]=path.GeomEdge.sourcePort.Location,t.points[1]=path.GeomEdge.targetPort.Location)}static ExtendPolylineToTargetPort(t,location){const n=t.points.length-1,dir=CompassVector.VectorDirectionPP(t.points[n-1],t.points[n]);if(Nudger.ProjectionsAreClose(t.points[n-1],dir,location))return void(t.points=t.points.slice(0,n));const p=t.points[n];dir==Direction.East||dir==Direction.West?t.points[n]=new point_Point(location.x,p.y):t.points[n]=new point_Point(p.x,location.y)}static ProjectionsAreClose(a,dir,b){return dir==Direction.East||dir==Direction.West?closeDistEps(a.x,b.x):closeDistEps(a.y,b.y)}static ExtendPolylineToSourcePort(t,location){const dir=CompassVector.VectorDirectionPP(t.points[0],t.points[1]);if(Nudger.ProjectionsAreClose(t.points[1],dir,location))return void(t.points=t.points.slice(1));const p=t.points[0];dir==Direction.East||dir==Direction.West?t.points[0]=new point_Point(location.x,p.y):t.points[0]=new point_Point(p.x,location.y)}static RemoveSwitchbacksAndMiddlePoints(points){const ret=[];let a=points[0];ret.push(a);let b=points[1],prevDir=CompassVector.VectorDirectionPP(a,b),i=1;for(;++i<points.length;){const dir=CompassVector.VectorDirectionPP(b,points[i]);dir!=prevDir&&CompassVector.OppositeDir(dir)!=prevDir&&dir!=Direction.None&&(point_Point.closeDistEps(a,b)||ret.push(a=Nudger.Rectilinearise(a,b)),prevDir=dir),b=points[i]}return point_Point.closeDistEps(a,b)||ret.push(Nudger.Rectilinearise(a,b)),ret}static NudgePaths(paths,cornerFitRadius,paddedObstacles,ancestorsSets,removeStaircases){if(0==paths.length)return;const nudger=new Nudger(paths,cornerFitRadius,paddedObstacles,ancestorsSets);nudger.Calculate(Direction.North,!0),nudger.Calculate(Direction.East,!1),nudger.Calculate(Direction.North,!1),removeStaircases&&nudger.RemoveStaircases();for(const path of paths)path.GeomEdge.curve=Polyline.mkFromPoints(Nudger.BuildPolylineForPath(path))}RemoveStaircases(){StaircaseRemover.RemoveStaircases(this.Paths,this.HierarchyOfObstacles)}static MapPortsToShapes(listOfShapes){const portToShapes=new Map;for(const shape of listOfShapes)for(const port of shape.Ports)portToShapes.set(port,shape);return portToShapes}static*GetEdgePathFromPathEdgesAsDebugCurves(startWidth,endWidth,color,path){const points=path.ArrayOfPathPoints(),count=points.length,deltaW=count>1?(endWidth-startWidth)/(count-1):1;for(let i=0;i<points.length-1;i++)yield debugCurve_DebugCurve.mkDebugCurveTWCI(200,startWidth+deltaW*i,color,LineSegment.mkPP(points[i],points[i+1]))}}class PointAndCrossings{constructor(loc,crossings){this.Crossings=[],this.Location=loc,this.Crossings=crossings}}class PointAndCrossingsList{constructor(){this.ListOfPointsAndCrossings=[],this.index=0,this.ListOfPointsAndCrossings=new Array}Count(){return this.ListOfPointsAndCrossings.length}Add(intersect,crossings){this.ListOfPointsAndCrossings.push(new PointAndCrossings(intersect,crossings))}Pop(){return this.ListOfPointsAndCrossings[this.index++]}CurrentIsBeforeOrAt(comparand){return!(this.index>=this.ListOfPointsAndCrossings.length)&&PointComparer.ComparePP(this.ListOfPointsAndCrossings[this.index].Location,comparand)<=0}get First(){return this.ListOfPointsAndCrossings[0]}get Last(){return this.ListOfPointsAndCrossings[this.ListOfPointsAndCrossings.length-1]}Reset(){this.index=0}MergeFrom(other){if(this.Reset(),null==other)return;const thisMax=this.ListOfPointsAndCrossings.length;let thisIndex=0;const otherMax=other.ListOfPointsAndCrossings.length;let otherIndex=0;const newCrossingsList=new Array(this.ListOfPointsAndCrossings.length);for(;thisIndex<thisMax||otherIndex<otherMax;){if(thisIndex>=thisMax){newCrossingsList.push(other.ListOfPointsAndCrossings[otherIndex++]);continue}if(otherIndex>=otherMax){newCrossingsList.push(this.ListOfPointsAndCrossings[thisIndex++]);continue}const thisPac=this.ListOfPointsAndCrossings[thisIndex],otherPac=other.ListOfPointsAndCrossings[otherIndex],cmp=PointComparer.ComparePP(thisPac.Location,otherPac.Location);0==cmp?(newCrossingsList.push(thisPac),++thisIndex,++otherIndex):-1==cmp?(newCrossingsList.push(thisPac),++thisIndex):(newCrossingsList.push(otherPac),++otherIndex)}this.ListOfPointsAndCrossings=newCrossingsList}Trim(start,end){this.Reset(),null!=this.ListOfPointsAndCrossings&&0!=this.ListOfPointsAndCrossings.length&&(this.ListOfPointsAndCrossings=this.ListOfPointsAndCrossings.filter((pair=>PointComparer.ComparePP(pair.Location,start)>=0&&PointComparer.ComparePP(pair.Location,end)<=0)))}static ToCrossingArray(crossings,dirToInside){let numInDir=0;const crossingsCount=crossings.length;for(let ii=0;ii<crossingsCount;ii++)crossings[ii].DirectionToInside==dirToInside&&numInDir++;if(0==numInDir)return null;const vector=new Array(numInDir);let jj=0;for(let ii=0;ii<crossingsCount;ii++)crossings[ii].DirectionToInside==dirToInside&&(vector[jj++]=crossings[ii]);return vector}ToString(){return dist.Qf.Format("{0} [{1}]",this.ListOfPointsAndCrossings.length,this.index)}}class StaticGraphUtility{static EdgeDirectionVE(edge){return StaticGraphUtility.EdgeDirectionVV(edge.Source,edge.Target)}static EdgeDirectionVV(source,target){return PointComparer.GetDirections(source.point,target.point)}static GetEdgeEnd(edge,dir){return dir==StaticGraphUtility.EdgeDirectionVE(edge)?edge.Target:edge.Source}static FindAdjacentVertex(vertex,dir){for(const edge of vertex.InEdges)if(PointComparer.GetDirections(vertex.point,edge.SourcePoint)==dir)return edge.Source;for(const edge of vertex.OutEdges)if(PointComparer.GetDirections(vertex.point,edge.TargetPoint)==dir)return edge.Target;return null}static FindAdjacentEdge(a,dir){for(const edge of a.InEdges)if(PointComparer.GetDirections(edge.SourcePoint,a.point)==dir)return edge;for(const edge of a.OutEdges)if(PointComparer.GetDirections(a.point,edge.TargetPoint)==dir)return edge;return null}static FindBendPointBetween(sourcePoint,targetPoint,finalEdgeDir){return StaticGraphUtility.IsVerticalD(finalEdgeDir)?new point_Point(targetPoint.x,sourcePoint.y):new point_Point(sourcePoint.x,targetPoint.y)}static SegmentIntersectionPPP(first,second,from){const dir=PointComparer.GetDirections(first,second);return StaticGraphUtility.IsVerticalD(dir)?new point_Point(first.x,from.y):new point_Point(from.x,first.y)}static SegmentIntersectionSP(seg,from){return StaticGraphUtility.SegmentIntersectionPPP(seg.Start,seg.End,from)}static SegmentsIntersection(first,second){return StaticGraphUtility.IntervalsIntersect(first.Start,first.End,second.Start,second.End)}static SegmentsIntersectLL(first,second){return StaticGraphUtility.IntervalsIntersect(first.start,first.end,second.start,second.end)}static IntervalsOverlapSS(first,second){return StaticGraphUtility.IntervalsOverlapPPPP(first.Start,first.End,second.Start,second.End)}static IntervalsOverlapPPPP(start1,end1,start2,end2){return StaticGraphUtility.IntervalsAreCollinear(start1,end1,start2,end2)&&PointComparer.ComparePP(start1,end2)!=PointComparer.ComparePP(end1,start2)}static IntervalsAreCollinear(start1,end1,start2,end2){const vertical=StaticGraphUtility.IsVerticalPP(start1,end1);return StaticGraphUtility.IsVerticalPP(start2,end2)==vertical&&(vertical?PointComparer.Equal(start1.x,start2.x):PointComparer.Equal(start1.y,start2.y))}static IntervalsAreSame(start1,end1,start2,end2){return PointComparer.EqualPP(start1,start2)&&PointComparer.EqualPP(end1,end2)}static IntervalsIntersect(firstStart,firstEnd,secondStart,secondEnd){const intersect=StaticGraphUtility.SegmentIntersectionPPP(firstStart,firstEnd,secondStart);return StaticGraphUtility.PointIsOnSegmentPPP(firstStart,firstEnd,intersect)&&StaticGraphUtility.PointIsOnSegmentPPP(secondStart,secondEnd,intersect)?intersect:void 0}static SegmentIntersectionEP(edge,from){return StaticGraphUtility.SegmentIntersectionPPP(edge.SourcePoint,edge.TargetPoint,from)}static PointIsOnSegmentPPP(first,second,test){return PointComparer.EqualPP(first,test)||PointComparer.EqualPP(second,test)||PointComparer.GetDirections(first,test)==PointComparer.GetDirections(test,second)}static PointIsOnSegmentSP(seg,test){return StaticGraphUtility.PointIsOnSegmentPPP(seg.Start,seg.End,test)}static IsVerticalD(dir){return!!(dir&(Direction.North|Direction.South))}static IsVerticalE(edge){return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(edge.SourcePoint,edge.TargetPoint))}static IsVerticalPP(first,second){return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(first,second))}static IsVertical(seg){return StaticGraphUtility.IsVerticalD(PointComparer.GetDirections(seg.start,seg.end))}static IsAscending(dir){return!!(dir&(Direction.North|Direction.East))}static Slope(start,end,scanDir){const lineDir=end.sub(start);return lineDir.dot(scanDir.PerpDirectionAsPoint)/lineDir.dot(scanDir.DirectionAsPoint)}static SortAscending(a,b){const dir=PointComparer.GetDirections(a,b);return Direction.None==dir||StaticGraphUtility.IsAscending(dir)?[a,b]:[b,a]}static RectangleBorderIntersect(boundingBox,point,dir){switch(dir){case Direction.North:case Direction.South:return new point_Point(point.x,StaticGraphUtility.GetRectangleBound(boundingBox,dir));case Direction.East:case Direction.West:return new point_Point(StaticGraphUtility.GetRectangleBound(boundingBox,dir),point.y);default:throw new Error}}static GetRectangleBound(rect,dir){switch(dir){case Direction.North:return rect.top;case Direction.South:return rect.bottom;case Direction.East:return rect.right;case Direction.West:return rect.left;default:throw new Error}}static RectangleInteriorsIntersect(a,b){return PointComparer.Compare(a.bottom,b.top)<0&&PointComparer.Compare(b.bottom,a.top)<0&&PointComparer.Compare(a.left,b.right)<0&&PointComparer.Compare(b.left,a.right)<0}static PointIsInRectangleInterior(point,rect){return PointComparer.Compare(point.y,rect.top)<0&&PointComparer.Compare(rect.bottom,point.y)<0&&PointComparer.Compare(point.x,rect.right)<0&&PointComparer.Compare(rect.left,point.x)<0}}class ScanDirection{constructor(directionAlongScanLine){this.Dir=directionAlongScanLine,this.DirectionAsPoint=CompassVector.toPoint(this.Dir),this.PerpDirection=Direction.North==directionAlongScanLine?Direction.East:Direction.North,this.PerpDirectionAsPoint=CompassVector.toPoint(this.PerpDirection),this.OppositeDirection=CompassVector.OppositeDir(directionAlongScanLine)}get Dir(){return this.dir}set Dir(value){this.dir=value}get IsHorizontal(){return Direction.East==this.Dir}get IsVertical(){return Direction.North==this.Dir}Compare(lhs,rhs){const cmp=this.ComparePerpCoord(lhs,rhs);return 0!=cmp?cmp:this.CompareScanCoord(lhs,rhs)}CompareScanCoord(lhs,rhs){return PointComparer.Compare(lhs.sub(rhs).dot(this.DirectionAsPoint),0)}ComparePerpCoord(lhs,rhs){return PointComparer.Compare(lhs.sub(rhs).dot(this.PerpDirectionAsPoint),0)}IsFlatS(seg){return this.IsFlatPP(seg.Start,seg.End)}IsFlatPP(start,end){return PointComparer.Equal(end.sub(start).dot(this.PerpDirectionAsPoint),0)}IsPerpendicularS(seg){return this.IsPerpendicularPP(seg.Start,seg.End)}IsPerpendicularPP(start,end){return PointComparer.Equal(end.sub(start).dot(this.DirectionAsPoint),0)}Coord(point){return point.dot(this.DirectionAsPoint)}Min(first,second){return this.Compare(first,second)<=0?first:second}Max(first,second){return this.Compare(first,second)>=0?first:second}get PerpendicularInstance(){return this.IsHorizontal?ScanDirection.VerticalInstance:ScanDirection.HorizontalInstance}static GetInstance(dir){return StaticGraphUtility.IsVerticalD(dir)?ScanDirection.VerticalInstance:ScanDirection.HorizontalInstance}ToString(){return this.Dir.toString()}}ScanDirection.HorizontalInstance=new ScanDirection(Direction.East),ScanDirection.VerticalInstance=new ScanDirection(Direction.North);class ScanSegment extends SegmentBase{constructor(start,end,weight,gbcList){super(),this.Update(start,end),this.Weight=weight,this.GroupBoundaryPointAndCrossingsList=gbcList}static mk(start,end){return new ScanSegment(start,end,ScanSegment.NormalWeight,null)}get Start(){return this.startPoint}get End(){return this.endPoint}get IsVertical(){return ScanSegment.IsVerticalSegment(this.Start,this.End)}get ScanDirection(){return this.IsVertical?ScanDirection.VerticalInstance:ScanDirection.HorizontalInstance}get IsOverlapped(){return ScanSegment.OverlappedWeight==this.Weight}get IsReflection(){return ScanSegment.ReflectionWeight==this.Weight}static IsVerticalSegment(start,end){return start.x==end.x}MergeGroupBoundaryCrossingList(other){null!=other&&(null==this.GroupBoundaryPointAndCrossingsList&&(this.GroupBoundaryPointAndCrossingsList=new PointAndCrossingsList),this.GroupBoundaryPointAndCrossingsList.MergeFrom(other))}TrimGroupBoundaryCrossingList(){null!=this.GroupBoundaryPointAndCrossingsList&&this.GroupBoundaryPointAndCrossingsList.Trim(this.Start,this.End)}Update(start,end){this.startPoint=start,this.endPoint=end}SetInitialVisibilityVertex(newVertex){this.LowestVisibilityVertex=newVertex,this.HighestVisibilityVertex=newVertex}AppendVisibilityVertex(vg,newVertex){if(null==this.HighestVisibilityVertex)this.AddGroupCrossingsBeforeHighestVisibilityVertex(vg,newVertex)||this.SetInitialVisibilityVertex(newVertex);else{if(PointComparer.IsPureLower(newVertex.point,this.HighestVisibilityVertex.point))return;this.AddGroupCrossingsBeforeHighestVisibilityVertex(vg,newVertex)||this.AppendHighestVisibilityVertex(newVertex)}}AddVisibilityEdge(source,target){const edge=new VisibilityEdge(source,target,this.Weight);return VisibilityGraph.AddEdge(edge),edge}AppendHighestVisibilityVertex(newVertex){PointComparer.EqualPP(this.HighestVisibilityVertex.point,newVertex.point)||(this.AddVisibilityEdge(this.HighestVisibilityVertex,newVertex),this.HighestVisibilityVertex=newVertex)}LoadStartOverlapVertexIfNeeded(vg){if(this.NeedStartOverlapVertex){const vertex=vg.FindVertex(this.Start);this.AppendVisibilityVertex(vg,null!=vertex?vertex:vg.AddVertexP(this.Start))}}LoadEndOverlapVertexIfNeeded(vg){if(this.NeedEndOverlapVertex){const vertex=vg.FindVertex(this.End);this.AppendVisibilityVertex(vg,null!=vertex?vertex:vg.AddVertexP(this.End))}}OnSegmentIntersectorBegin(vg){this.AppendGroupCrossingsThroughPoint(vg,this.Start)||this.LoadStartOverlapVertexIfNeeded(vg)}OnSegmentIntersectorEnd(vg){this.AppendGroupCrossingsThroughPoint(vg,this.End),this.GroupBoundaryPointAndCrossingsList=null,(null==this.HighestVisibilityVertex||PointComparer.IsPureLower(this.HighestVisibilityVertex.point,this.End))&&this.LoadEndOverlapVertexIfNeeded(vg)}static Subsume(t,newStart,newEnd,weight,gbcList,scanDir,tree,ot){return ot.extendStart=!0,ot.extendEnd=!0,null!=t.seg&&(!!StaticGraphUtility.IntervalsOverlapPPPP(t.seg.Start,t.seg.End,newStart,newEnd)&&(t.seg.Weight!=weight?t.seg.Start==newStart&&t.seg.End==newEnd&&(t.seg.Weight=Math.min(t.seg.Weight,weight),!0):(ot.extendStart=-1==scanDir.CompareScanCoord(newStart,t.seg.Start),ot.extendEnd=1==scanDir.CompareScanCoord(newEnd,t.seg.End),(ot.extendStart||ot.extendEnd)&&(tree.Remove(t.seg),t.seg.startPoint=scanDir.Min(t.seg.Start,newStart),t.seg.endPoint=scanDir.Max(t.seg.End,newEnd),t.seg=tree.InsertUnique(t.seg).item,t.seg.MergeGroupBoundaryCrossingList(gbcList)),!0)))}IntersectsSegment(seg){return null!=StaticGraphUtility.SegmentsIntersection(this,seg)}toString(){return"["+this.Start+" -> "+this.End+(this.IsOverlapped?" olap":" free")+"]"}ContainsPoint(test){return PointComparer.EqualPP(this.Start,test)||PointComparer.EqualPP(this.End,test)||PointComparer.GetDirections(this.Start,test)==PointComparer.GetDirections(test,this.End)}get HasSparsePerpendicularCoords(){return null!=this.sparsePerpendicularCoords&&this.sparsePerpendicularCoords.size>0}CreatePointFromPerpCoord(perpCoord){return this.IsVertical?new point_Point(this.Start.x,perpCoord):new point_Point(perpCoord,this.Start.y)}AddSparseVertexCoord(perpCoord){null==this.sparsePerpendicularCoords&&(this.sparsePerpendicularCoords=new Set),this.sparsePerpendicularCoords.add(perpCoord)}AddSparseEndpoint(coord){return!this.sparsePerpendicularCoords.has(coord)&&(this.sparsePerpendicularCoords.add(coord),!0)}CreateSparseVerticesAndEdges(vg){var _a;if(null!=this.sparsePerpendicularCoords){this.AppendGroupCrossingsThroughPoint(vg,this.Start);for(const perpCoord of Array.from(this.sparsePerpendicularCoords.values()).sort(compareNumbers)){const vertexLocation=this.CreatePointFromPerpCoord(perpCoord);this.AppendVisibilityVertex(vg,null!==(_a=vg.FindVertex(vertexLocation))&&void 0!==_a?_a:vg.AddVertexP(vertexLocation))}this.AppendGroupCrossingsThroughPoint(vg,this.End),this.GroupBoundaryPointAndCrossingsList=null,this.sparsePerpendicularCoords.clear(),this.sparsePerpendicularCoords=null}}HasVisibility(){return null!=this.LowestVisibilityVertex}AddGroupCrossingsBeforeHighestVisibilityVertex(vg,newVertex){return!!this.AppendGroupCrossingsThroughPoint(vg,newVertex.point)&&(PointComparer.IsPureLower(this.HighestVisibilityVertex.point,newVertex.point)&&(this.AddVisibilityEdge(this.HighestVisibilityVertex,newVertex),this.HighestVisibilityVertex=newVertex),!0)}AppendGroupCrossingsThroughPoint(vg,lastPoint){var _a;if(null==this.GroupBoundaryPointAndCrossingsList)return!1;let found=!1;for(;this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(lastPoint);){const pac=this.GroupBoundaryPointAndCrossingsList.Pop();let lowDirCrossings=null,highDirCrossings=null;PointComparer.ComparePP(pac.Location,this.Start)>0&&(lowDirCrossings=PointAndCrossingsList.ToCrossingArray(pac.Crossings,this.ScanDirection.OppositeDirection)),PointComparer.ComparePP(pac.Location,this.End)<0&&(highDirCrossings=PointAndCrossingsList.ToCrossingArray(pac.Crossings,this.ScanDirection.Dir)),found=!0;const crossingVertex=null!==(_a=vg.FindVertex(pac.Location))&&void 0!==_a?_a:vg.AddVertexP(pac.Location);vg.AddVertexP(pac.Location),null!=lowDirCrossings||null!=highDirCrossings?(this.AddLowCrossings(vg,crossingVertex,lowDirCrossings),this.AddHighCrossings(vg,crossingVertex,highDirCrossings)):null==this.LowestVisibilityVertex?this.SetInitialVisibilityVertex(crossingVertex):this.AppendHighestVisibilityVertex(crossingVertex)}return found}static GetCrossingInteriorVertex(vg,crossingVertex,crossing){var _a;const interiorPoint=crossing.GetInteriorVertexPoint(crossingVertex.point);return null!==(_a=vg.FindVertex(interiorPoint))&&void 0!==_a?_a:vg.AddVertexP(interiorPoint)}AddCrossingEdge(vg,lowVertex,highVertex,crossings){let edge=null;null!=this.HighestVisibilityVertex&&(PointComparer.EqualPP(this.HighestVisibilityVertex.point,highVertex.point)?edge=vg.FindEdgePP(lowVertex.point,highVertex.point):this.AppendHighestVisibilityVertex(lowVertex)),null==edge&&(edge=this.AddVisibilityEdge(lowVertex,highVertex));const crossingsArray=crossings.map((c=>c.Group.InputShape)),prevIsPassable=edge.IsPassable;edge.IsPassable=null==prevIsPassable?()=>{for(const s of crossingsArray)if(s.IsTransparent)return!0;return!1}:()=>{for(const s of crossingsArray)if(s.IsTransparent||prevIsPassable())return!0;return!1},null==this.LowestVisibilityVertex&&this.SetInitialVisibilityVertex(lowVertex),this.HighestVisibilityVertex=highVertex}AddLowCrossings(vg,crossingVertex,crossings){if(null!=crossings){const interiorVertex=ScanSegment.GetCrossingInteriorVertex(vg,crossingVertex,crossings[0]);this.AddCrossingEdge(vg,interiorVertex,crossingVertex,crossings)}}AddHighCrossings(vg,crossingVertex,crossings){if(null!=crossings){const interiorVertex=ScanSegment.GetCrossingInteriorVertex(vg,crossingVertex,crossings[0]);this.AddCrossingEdge(vg,crossingVertex,interiorVertex,crossings)}}}ScanSegment.NormalWeight=VisibilityEdge.DefaultWeight,ScanSegment.ReflectionWeight=5,ScanSegment.OverlappedWeight=500;class VertexEntry{constructor(vertex,prevEntry,length,numberOfBends,cost){this.IsClosed=!1,this.Vertex=vertex,this.Direction=null!=prevEntry?CompassVector.DirectionFromPointToPoint(prevEntry.Vertex.point,vertex.point):Direction.None,this.ResetEntry(prevEntry,length,numberOfBends,cost)}ResetEntry(prevEntry,length,numberOfBends,cost){this.PreviousEntry=prevEntry,this.Length=length,this.NumberOfBends=numberOfBends,this.Cost=cost}get PreviousVertex(){return null==this.PreviousEntry?null:this.PreviousEntry.Vertex}toString(){return this.Vertex.point+" "+this.Direction+" "+this.IsClosed+" "+this.Cost}}class NextNeighbor{constructor(){this.Clear()}Set(v,w){this.Vertex=v,this.Weight=w}Clear(){this.Vertex=null,this.Weight=Number.NaN}}class SsstRectilinearPath{constructor(){this.nextNeighbors=[new NextNeighbor,new NextNeighbor,new NextNeighbor],this.LengthImportance=1,this.BendsImportance=1}CombinedCost(length,numberOfBends){return this.LengthImportance*length+this.BendsImportance*numberOfBends}TotalCostFromSourceToVertex(length,numberOfBends){return this.CombinedCost(length,numberOfBends)+this.sourceCostAdjustment}InitPath(sourceVertexEntries,source,target){if(source==target||!this.InitEntryDirectionsAtTarget(target))return!1;this.Target=target,this.Source=source;const cost=this.TotalCostFromSourceToVertex(0,0)+this.HeuristicDistanceFromVertexToTarget(source.point,Direction.None);return!(cost>=this.upperBoundOnCost)&&(this.queue=new GenericBinaryHeapPriorityQueue(compareNumbers),this.visitedVertices=[source],null==sourceVertexEntries?this.EnqueueInitialVerticesFromSource(cost):this.EnqueueInitialVerticesFromSourceEntries(sourceVertexEntries),this.queue.count>0)}InitEntryDirectionsAtTarget(vert){this.EntryDirectionsToTarget=Direction.None;for(const edge of vert.OutEdges)this.EntryDirectionsToTarget=this.EntryDirectionsToTarget|CompassVector.DirectionFromPointToPoint(edge.TargetPoint,vert.point);for(const edge of vert.InEdges)this.EntryDirectionsToTarget=this.EntryDirectionsToTarget|CompassVector.DirectionFromPointToPoint(edge.SourcePoint,vert.point);return this.EntryDirectionsToTarget!=Direction.None}static IsInDirs(direction,dirs){return direction==(direction&dirs)}MultistageAdjustedCostBound(bestCost){return Number.isFinite(bestCost)?bestCost+this.BendsImportance:bestCost}HeuristicDistanceFromVertexToTarget(point,entryDirToVertex){const vectorToTarget=this.Target.point.sub(point);if(closeDistEps(vectorToTarget.x,0)&&closeDistEps(vectorToTarget.y,0))return this.targetCostAdjustment;const dirToTarget=CompassVector.VectorDirection(vectorToTarget);let numberOfBends;return entryDirToVertex==Direction.None?(entryDirToVertex=Direction.East|Direction.North|Direction.West|Direction.South,numberOfBends=this.GetNumberOfBends(entryDirToVertex,dirToTarget)):numberOfBends=this.GetNumberOfBends(entryDirToVertex,dirToTarget),this.CombinedCost(SsstRectilinearPath.ManhattanDistance(point,this.Target.point),numberOfBends)+this.targetCostAdjustment}GetNumberOfBends(entryDirToVertex,dirToTarget){return CompassVector.IsPureDirection(dirToTarget)?this.GetNumberOfBendsForPureDirection(entryDirToVertex,dirToTarget):SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget,entryDirToVertex,this.EntryDirectionsToTarget)}GetNumberOfBendsForPureDirection(entryDirToVertex,dirToTarget){return(dirToTarget&entryDirToVertex)==dirToTarget?SsstRectilinearPath.IsInDirs(dirToTarget,this.EntryDirectionsToTarget)?0:SsstRectilinearPath.IsInDirs(SsstRectilinearPath.Left(dirToTarget),this.EntryDirectionsToTarget)||SsstRectilinearPath.IsInDirs(SsstRectilinearPath.Right(dirToTarget),this.EntryDirectionsToTarget)?2:4:this.GetNumberOfBendsForPureDirection(SsstRectilinearPath.AddOneTurn[entryDirToVertex],dirToTarget)+1}static GetBendsForNotPureDirection(dirToTarget,entryDirToVertex,entryDirectionsToTarget){const a=dirToTarget&entryDirToVertex;if(a==Direction.None)return SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget,SsstRectilinearPath.AddOneTurn[entryDirToVertex],entryDirectionsToTarget)+1;const b=dirToTarget&entryDirectionsToTarget;return b==Direction.None?SsstRectilinearPath.GetBendsForNotPureDirection(dirToTarget,entryDirToVertex,SsstRectilinearPath.AddOneTurn[entryDirectionsToTarget])+1:(a|b)==dirToTarget?1:2}static Left(direction){switch(direction){case Direction.None:return Direction.None;case Direction.North:return Direction.West;case Direction.East:return Direction.North;case Direction.South:return Direction.East;case Direction.West:return Direction.South;default:throw new Error("direction")}}static Right(direction){switch(direction){case Direction.None:return Direction.None;case Direction.North:return Direction.East;case Direction.East:return Direction.South;case Direction.South:return Direction.West;case Direction.West:return Direction.North;default:throw new Error("direction")}}static RestorePathV(t){return SsstRectilinearPath.RestorePath(t,null)}static RestorePath(t,firstVertexInStage){if(null==t.entry)return[];const list=new Array;let skippedCollinearEntry=!1,lastEntryDir=Direction.None;for(;;){lastEntryDir==t.entry.Direction?skippedCollinearEntry=!0:(skippedCollinearEntry=!1,list.push(t.entry.Vertex.point),lastEntryDir=t.entry.Direction);const previousEntry=t.entry.PreviousEntry;if(null==previousEntry||t.entry.Vertex==firstVertexInStage)break;t.entry=previousEntry}return skippedCollinearEntry&&list.push(t.entry.Vertex.point),list.reverse(),list}QueueReversedEntryToNeighborVertexIfNeeded(bestEntry,entryFromNeighbor,weight){const t={numberOfBends:0,length:0},neigVer=entryFromNeighbor.PreviousVertex,dirToNeighbor=SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry,neigVer,weight,t);if(this.CombinedCost(t.length,t.numberOfBends)<this.CombinedCost(entryFromNeighbor.Length,entryFromNeighbor.NumberOfBends)||1==bestEntry.Vertex.Degree){const cost=this.TotalCostFromSourceToVertex(t.length,t.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(neigVer.point,dirToNeighbor);this.EnqueueEntry(bestEntry,neigVer,t.length,t.numberOfBends,cost)}}UpdateEntryToNeighborVertexIfNeeded(bestEntry,neigEntry,weight){const t={numberOfBends:0,length:0},dirToNeighbor=SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry,neigEntry.Vertex,weight,t);if(this.CombinedCost(t.length,t.numberOfBends)<this.CombinedCost(neigEntry.Length,neigEntry.NumberOfBends)){const newCost=this.TotalCostFromSourceToVertex(t.length,t.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(neigEntry.Vertex.point,dirToNeighbor);neigEntry.ResetEntry(bestEntry,t.length,t.numberOfBends,newCost),this.queue.DecreasePriority(neigEntry,newCost)}}CreateAndEnqueueEntryToNeighborVertex(bestEntry,neigVer,weight){const t={numberOfBends:0,length:0},dirToNeighbor=SsstRectilinearPath.GetLengthAndNumberOfBendsToNeighborVertex(bestEntry,neigVer,weight,t),cost=this.TotalCostFromSourceToVertex(t.length,t.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(neigVer.point,dirToNeighbor);cost<this.upperBoundOnCost&&(null==neigVer.VertexEntries&&this.visitedVertices.push(neigVer),this.EnqueueEntry(bestEntry,neigVer,t.length,t.numberOfBends,cost))}EnqueueEntry(bestEntry,neigVer,length,numberOfBends,cost){const entry=new VertexEntry(neigVer,bestEntry,length,numberOfBends,cost);neigVer.SetVertexEntry(entry),this.queue.Enqueue(entry,entry.Cost)}static GetLengthAndNumberOfBendsToNeighborVertex(prevEntry,vertex,weight,t){t.length=prevEntry.Length+SsstRectilinearPath.ManhattanDistance(prevEntry.Vertex.point,vertex.point)*weight;const directionToVertex=CompassVector.DirectionFromPointToPoint(prevEntry.Vertex.point,vertex.point);return t.numberOfBends=prevEntry.NumberOfBends,prevEntry.Direction!=Direction.None&&directionToVertex!=prevEntry.Direction&&t.numberOfBends++,directionToVertex}static ManhattanDistance(a,b){return Math.abs(b.x-a.x)+Math.abs(b.y-a.y)}GetPathWithCost(sourceVertexEntries,source,adjustmentToSourceCost,targetVertexEntries,target,adjustmentToTargetCost,priorBestCost){if(this.upperBoundOnCost=priorBestCost,this.sourceCostAdjustment=adjustmentToSourceCost,this.targetCostAdjustment=adjustmentToTargetCost,!this.InitPath(sourceVertexEntries,source,target))return null;for(;this.queue.count>0;){const bestEntry=this.queue.Dequeue(),bestVertex=bestEntry.Vertex;if(bestVertex==this.Target){if(null==targetVertexEntries)return this.Cleanup(),bestEntry;if(bestEntry.Direction,this.EntryDirectionsToTarget==Direction.None){let i=0;for(const t of this.Target.VertexEntries)targetVertexEntries[i++]=t;return this.Cleanup(),null}this.upperBoundOnCost=Math.min(this.MultistageAdjustedCostBound(bestEntry.Cost),this.upperBoundOnCost);continue}bestEntry.IsClosed=!0;for(const bendNeighbor of this.nextNeighbors)bendNeighbor.Clear();const preferredBendDir=SsstRectilinearPath.Right(bestEntry.Direction);this.ExtendPathAlongInEdges(bestEntry,bestVertex.InEdges,preferredBendDir),this.ExtendPathAlongOutEdges(bestEntry,bestVertex.OutEdges,preferredBendDir);for(const bendNeighbor of this.nextNeighbors)null!=bendNeighbor.Vertex&&this.ExtendPathToNeighborVertex(bestEntry,bendNeighbor.Vertex,bendNeighbor.Weight)}if(null!=targetVertexEntries&&null!=this.Target.VertexEntries)for(let i=0;i<this.Target.VertexEntries.length;i++)targetVertexEntries[i]=this.Target.VertexEntries[i];return this.Cleanup(),null}ExtendPathAlongInEdges(bestEntry,edges,preferredBendDir){for(const edge of edges)this.ExtendPathAlongEdge(bestEntry,edge,!0,preferredBendDir)}ExtendPathAlongOutEdges(bestEntry,edges,preferredBendDir){let outEdgeNode=edges.isEmpty()?null:edges.treeMinimum();for(;null!=outEdgeNode;outEdgeNode=edges.next(outEdgeNode))this.ExtendPathAlongEdge(bestEntry,outEdgeNode.item,!1,preferredBendDir)}ExtendPathAlongEdge(bestEntry,edge,isInEdges,preferredBendDir){if(!SsstRectilinearPath.IsPassable(edge))return;const neigVer=isInEdges?edge.Source:edge.Target;if(neigVer==bestEntry.PreviousVertex){if(bestEntry.Vertex.Degree>1||bestEntry.Vertex!=this.Source)return;return void this.ExtendPathToNeighborVertex(bestEntry,neigVer,edge.Weight)}const neigDir=CompassVector.DirectionFromPointToPoint(bestEntry.Vertex.point,neigVer.point);let nextNeighbor=this.nextNeighbors[2];neigDir!=bestEntry.Direction&&(nextNeighbor=this.nextNeighbors[neigDir==preferredBendDir?1:0]),nextNeighbor.Set(neigVer,edge.Weight)}EnqueueInitialVerticesFromSource(cost){const bestEntry=new VertexEntry(this.Source,null,0,0,cost);for(const edge of this.Source.OutEdges)SsstRectilinearPath.IsPassable(edge)&&this.ExtendPathToNeighborVertex(bestEntry,edge.Target,edge.Weight);for(const edge of this.Source.InEdges)SsstRectilinearPath.IsPassable(edge)&&this.ExtendPathToNeighborVertex(bestEntry,edge.Source,edge.Weight)}EnqueueInitialVerticesFromSourceEntries(sourceEntries){for(const entry of sourceEntries)null!=entry&&this.queue.Enqueue(entry,entry.Cost)}ExtendPathToNeighborVertex(bestEntry,neigVer,weight){const dirToNeighbor=CompassVector.DirectionFromPointToPoint(bestEntry.Vertex.point,neigVer.point),neigEntry=null!=neigVer.VertexEntries?neigVer.VertexEntries[CompassVector.ToIndex(dirToNeighbor)]:null;null==neigEntry?this.CreateAndEnqueueReversedEntryToNeighborVertex(bestEntry,neigVer,weight)||this.CreateAndEnqueueEntryToNeighborVertex(bestEntry,neigVer,weight):neigEntry.IsClosed||this.UpdateEntryToNeighborVertexIfNeeded(bestEntry,neigEntry,weight)}CreateAndEnqueueReversedEntryToNeighborVertex(bestEntry,neigVer,weight){if(null!=bestEntry.Vertex.VertexEntries){const dirFromNeighbor=CompassVector.DirectionFromPointToPoint(neigVer.point,bestEntry.Vertex.point),entryFromNeighbor=bestEntry.Vertex.VertexEntries[CompassVector.ToIndex(dirFromNeighbor)];if(null!=entryFromNeighbor)return this.QueueReversedEntryToNeighborVertexIfNeeded(bestEntry,entryFromNeighbor,weight),!0}return!1}static IsPassable(edge){return null==edge.IsPassable||edge.IsPassable()}Cleanup(){for(const v of this.visitedVertices)v.RemoveVertexEntries();this.visitedVertices=[],this.queue=null}}SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance=4,SsstRectilinearPath.AddOneTurn=[Direction.None,Direction.North|Direction.East|Direction.West,Direction.North|Direction.East|Direction.South,15,Direction.East|Direction.South|Direction.West,15,15,15,13,15,15,15,15,15,15,15];class MsmtRectilinearPath{constructor(bendPenalty){this.bendPenaltyAsAPercentageOfDistance=SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance,this.currentPassTargetEntries=new Array(4),this.bendPenaltyAsAPercentageOfDistance=bendPenalty}GetPath(sources,targets){const t={entry:this.GetPathStage(null,sources,null,targets)};return SsstRectilinearPath.RestorePathV(t)}GetPathStage(sourceVertexEntries,sources,targetVertexEntries,targets){const ssstCalculator=new SsstRectilinearPath,t={bestEntry:null,bestCost:Number.MAX_VALUE/ScanSegment.OverlappedWeight};let bestPathCostRatio=Number.POSITIVE_INFINITY;const sourceCenter=MsmtRectilinearPath.Barycenter(sources),targetCenter=MsmtRectilinearPath.Barycenter(targets),distance=SsstRectilinearPath.ManhattanDistance(sourceCenter,targetCenter);ssstCalculator.BendsImportance=Math.max(.001,distance*(.01*this.bendPenaltyAsAPercentageOfDistance));const interiorLengthAdjustment=ssstCalculator.LengthImportance,tempTargetEntries=null!=targetVertexEntries?this.currentPassTargetEntries:null,stPairs=[];for(const s of sources)for(const t of targets)stPairs.push([s,t]);stPairs.sort((([a,b],[c,d])=>md(a,b)-md(c,d)));for(const[sv,tv]of stPairs){if(point_Point.closeDistEps(sv.point,tv.point))continue;const sourceCostAdjustment=mdP(sv,sourceCenter)*interiorLengthAdjustment,targetCostAdjustment=mdP(tv,targetCenter)*interiorLengthAdjustment;let adjustedBestCost=t.bestCost;if(null!=targetVertexEntries){for(let i=0;i<tempTargetEntries.length;i++)tempTargetEntries[i]=null;adjustedBestCost=ssstCalculator.MultistageAdjustedCostBound(t.bestCost)}const lastEntry=ssstCalculator.GetPathWithCost(sourceVertexEntries,sv,sourceCostAdjustment,tempTargetEntries,tv,targetCostAdjustment,adjustedBestCost);if(null!=tempTargetEntries){MsmtRectilinearPath.UpdateTargetEntriesForEachDirection(targetVertexEntries,tempTargetEntries,t);continue}if(null==lastEntry)continue;const costRatio=lastEntry.Cost/md(sv,tv);(lastEntry.Cost<t.bestCost||closeDistEps(lastEntry.Cost,t.bestCost)&&costRatio<bestPathCostRatio)&&(t.bestCost=lastEntry.Cost,t.bestEntry=lastEntry,bestPathCostRatio=lastEntry.Cost/md(sv,tv))}return t.bestEntry;function md(s,t){return SsstRectilinearPath.ManhattanDistance(s.point,t.point)}function mdP(s,t){return SsstRectilinearPath.ManhattanDistance(s.point,t)}}static UpdateTargetEntriesForEachDirection(targetVertexEntries,tempTargetEntries,t){for(let ii=0;ii<tempTargetEntries.length;ii++){const tempEntry=tempTargetEntries[ii];null!=tempEntry&&((null==targetVertexEntries[ii]||tempEntry.Cost<targetVertexEntries[ii].Cost)&&(targetVertexEntries[ii]=tempEntry,tempEntry.Cost<t.bestCost&&(t.bestCost=tempEntry.Cost,t.bestEntry=tempEntry)))}}static Barycenter(vertices){let center=new point_Point(0,0);for(const vertex of vertices)center=center.add(vertex.point);return center.div(vertices.length)}}class Path{constructor(edgeGeometry){this.GeomEdge=edgeGeometry}get PathPoints(){return this._pathPoints}set PathPoints(value){this._pathPoints=value}get Width(){return this.GeomEdge.lineWidth}get End(){return this.LastEdge.Target}get Start(){return this.FirstEdge.Source}ArrayOfPathPoints(){return this._pathPoints instanceof LinkedPoint?Array.from(iteratePoints(this._pathPoints)):this._pathPoints}*PathEdges(){for(let e=this.FirstEdge;null!=e;e=e.Next)yield e}AddEdge(edge){edge.Path=this,this.LastEdge.Next=edge,edge.Prev=this.LastEdge,this.LastEdge=edge}SetFirstEdge(edge){this.FirstEdge=edge,this.LastEdge=edge,edge.Path=this}toString(){const sb=new dist.fe;this.PathPoints instanceof LinkedPoint&&sb.Append("L");for(const p of iteratePoints(this.PathPoints))sb.Append(p.toString());return sb.ToString()}}function*iteratePoints(pathPoints){if(pathPoints instanceof LinkedPoint)for(let p=pathPoints;null!=p;p=p.Next)yield p.Point;else for(const p of pathPoints)yield p}class BasicObstacleSide extends ObstacleSide{constructor(obstacle,startVertex,scanDir,traverseClockwise){super(startVertex),this.Slope=0,this.SlopeInverse=0,this.Obstacle=obstacle,this.endVertex=traverseClockwise?startVertex.nextOnPolyline:startVertex.prevOnPolyline,scanDir.IsPerpendicularPP(startVertex.point,this.endVertex.point)||(this.Slope=StaticGraphUtility.Slope(startVertex.point,this.endVertex.point,scanDir),this.SlopeInverse=1/this.Slope)}get Obstacle(){return this.obstacle}set Obstacle(value){this.obstacle=value}get EndVertex(){return this.endVertex}}class LowObstacleSide extends BasicObstacleSide{constructor(obstacle,startVertex,scanDir){super(obstacle,startVertex,scanDir,scanDir.IsHorizontal)}}class HighObstacleSide extends BasicObstacleSide{constructor(obstacle,startVertex,scanDir){super(obstacle,startVertex,scanDir,scanDir.IsVertical)}}class Obstacle{constructor(shape,makeRect,padding){if(null!=shape){if(makeRect){const paddedBox=shape.BoundingBox.clone();paddedBox.pad(padding),this.PaddedPolyline=Curve.polyFromBox(paddedBox)}else this.PaddedPolyline=InteractiveObstacleCalculator.PaddedPolylineBoundaryOfNode(shape.BoundaryCurve,padding);Obstacle.RoundVerticesAndSimplify(this.PaddedPolyline),this.IsRectangle=this.IsPolylineRectangle(),this.InputShape=shape,this.Ports=new Set(this.InputShape.Ports)}}get PaddedPolyline(){return this._PaddedPolyline}set PaddedPolyline(value){this._PaddedPolyline=value}GetPortChanges(t){return t.addedPorts=substractSets(this.InputShape.Ports,this.Ports),t.removedPorts=substractSets(this.Ports,this.InputShape.Ports),(0!=t.addedPorts.size||0!=t.removedPorts.size)&&(this.Ports=new Set(this.InputShape.Ports),!0)}get IsInConvexHull(){return null!=this.ConvexHull}get IsGroup(){return null!=this.InputShape&&this.InputShape.IsGroup}get VisibilityBoundingBox(){return this.VisibilityPolyline.boundingBox}get VisibilityPolyline(){return null!=this.ConvexHull?this.ConvexHull.Polyline:this.PaddedPolyline}static CreateSentinel(a,b,scanDir,scanlineOrdinal){const sentinel=Obstacle.mk(a,b,scanlineOrdinal);return sentinel.CreateInitialSides(sentinel.PaddedPolyline.startPoint,scanDir),sentinel}CreateInitialSides(startPoint,scanDir){this.ActiveLowSide=new LowObstacleSide(this,startPoint,scanDir),this.ActiveHighSide=new HighObstacleSide(this,startPoint,scanDir),scanDir.IsFlatS(this.ActiveHighSide)&&(this.ActiveHighSide=new HighObstacleSide(this,this.ActiveHighSide.EndVertex,scanDir))}static mk(a,b,scanlineOrdinal){const obs=new Obstacle(null,!1,0);return obs.PaddedPolyline=Polyline.mkClosedFromPoints([GeomConstants.RoundPoint(a),GeomConstants.RoundPoint(b)]),obs.Ordinal=scanlineOrdinal,obs}IsPolylineRectangle(){if(4!=this.PaddedPolyline.count)return!1;let ppt=this.PaddedPolyline.startPoint,nextPpt=ppt.nextOnPolyline,dir=CompassVector.VectorDirectionPP(ppt.point,nextPpt.point);if(!CompassVector.IsPureDirection(dir))return!1;do{ppt=nextPpt,nextPpt=ppt.nextOnPolyline;const nextDir=CompassVector.DirectionFromPointToPoint(ppt.point,nextPpt.point);if(nextDir!=CompassVector.RotateRight(dir))return!1;dir=nextDir}while(ppt!=this.PaddedPolyline.startPoint);return!0}static RoundVerticesAndSimplify(polyline){let ppt=polyline.startPoint;do{ppt.point=GeomConstants.RoundPoint(ppt.point),ppt=ppt.nextOnPolyline}while(ppt!=polyline.startPoint);Obstacle.RemoveCloseAndCollinearVerticesInPlace(polyline),polyline.setInitIsRequired()}get IsPrimaryObstacle(){return null==this.ConvexHull||this==this.ConvexHull.PrimaryObstacle}static RemoveCloseAndCollinearVerticesInPlace(polyline){const epsilon=10*GeomConstants.intersectionEpsilon;for(let pp=polyline.startPoint.next;null!=pp;pp=pp.next)point_Point.close(pp.prev.point,pp.point,epsilon)&&(null==pp.next?polyline.RemoveEndPoint():(pp.prev.next=pp.next,pp.next.prev=pp.prev));return point_Point.close(polyline.start,polyline.end,epsilon)&&polyline.RemoveStartPoint(),InteractiveEdgeRouter.RemoveCollinearVertices(polyline),null!=polyline.endPoint.prev&&polyline.endPoint.prev!=polyline.startPoint&&point_Point.getTriangleOrientation(polyline.endPoint.prev.point,polyline.end,polyline.start)==point_TriangleOrientation.Collinear&&polyline.RemoveEndPoint(),null!=polyline.startPoint.next&&polyline.endPoint.prev!=polyline.startPoint&&point_Point.getTriangleOrientation(polyline.end,polyline.start,polyline.startPoint.next.point)==point_TriangleOrientation.Collinear&&polyline.RemoveStartPoint(),polyline.setInitIsRequired(),polyline}get isOverlapped(){return null!=this.clump&&this.clump.length>0}get IsSentinel(){return null==this.InputShape}IsInSameClump(other){return this.isOverlapped&&this.clump==other.clump}Close(){this.ActiveLowSide=null,this.ActiveHighSide=null}SetConvexHull(hull){this.clump=null,this.IsRectangle=!1,this.ConvexHull=hull,this.looseVisibilityPolyline=null}static CreateLoosePolyline(polyline){const loosePolyline=InteractiveObstacleCalculator.CreatePaddedPolyline(polyline,10*GeomConstants.intersectionEpsilon);return Obstacle.RoundVerticesAndSimplify(loosePolyline),loosePolyline}get IsTransparentAncestor(){return null!=this.InputShape&&this.InputShape.IsTransparent}set IsTransparentAncestor(value){this.InputShape.IsTransparent=value}}Obstacle.FirstSentinelOrdinal=1,Obstacle.FirstNonSentinelOrdinal=10;class ObstaclePortEntrance{constructor(oport,unpaddedBorderIntersect,outDir,obstacleTree){this.IsOverlapped=!1,this.unpaddedToPaddedBorderWeight=ScanSegment.NormalWeight,this.ObstaclePort=oport,this.UnpaddedBorderIntersect=unpaddedBorderIntersect,this.OutwardDirection=outDir;const lineSeg=LineSegment.mkPP(this.UnpaddedBorderIntersect,StaticGraphUtility.RectangleBorderIntersect(oport.Obstacle.VisibilityBoundingBox,this.UnpaddedBorderIntersect,outDir)),xxs=Curve.getAllIntersections(lineSeg,oport.Obstacle.VisibilityPolyline,!0);this.VisibilityBorderIntersect=GeomConstants.RoundPoint(xxs[0].x);const t={pacList:null};this.MaxVisibilitySegment=obstacleTree.CreateMaxVisibilitySegment(this.VisibilityBorderIntersect,this.OutwardDirection,t),this.pointAndCrossingsList=t.pacList,(this.Obstacle.isOverlapped||this.Obstacle.IsGroup&&!this.Obstacle.IsInConvexHull)&&(this.IsOverlapped=obstacleTree.IntersectionIsInsideAnotherObstacle(null,this.Obstacle,this.VisibilityBorderIntersect,ScanDirection.GetInstance(this.OutwardDirection)),(!this.Obstacle.IsGroup||this.IsOverlapped||this.InteriorEdgeCrossesObstacle(obstacleTree))&&(this.unpaddedToPaddedBorderWeight=ScanSegment.OverlappedWeight)),this.Obstacle.IsInConvexHull&&this.unpaddedToPaddedBorderWeight==ScanSegment.NormalWeight&&this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(obstacleTree)}get Obstacle(){return this.ObstaclePort.Obstacle}get InitialWeight(){return this.IsOverlapped?ScanSegment.OverlappedWeight:ScanSegment.NormalWeight}get IsCollinearWithPort(){return CompassVector.IsPureDirection(PointComparer.GetDirections(this.VisibilityBorderIntersect,this.ObstaclePort.Location))}get IsVertical(){return StaticGraphUtility.IsVertical(this.MaxVisibilitySegment)}get WantVisibilityIntersection(){return!this.IsOverlapped&&this.CanExtend&&(!this.ObstaclePort.HasCollinearEntrances||this.IsCollinearWithPort)}get CanExtend(){return PointComparer.GetDirections(this.MaxVisibilitySegment.start,this.MaxVisibilitySegment.end)!=Direction.None}SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(obstacleTree){(this.Obstacle.IsGroup?this.InteriorEdgeCrossesObstacle(obstacleTree):this.InteriorEdgeCrossesConvexHullSiblings())&&(this.unpaddedToPaddedBorderWeight=ScanSegment.OverlappedWeight)}InteriorEdgeCrossesObstacle(obstacleTree){const rect=Rectangle.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);return this.InteriorEdgeCrossesObstacleRFI(rect,(obs=>obs.VisibilityPolyline),Array.from(obstacleTree.Root.GetLeafRectangleNodesIntersectingRectangle(rect)).filter((node=>!node.UserData.IsGroup&&node.UserData!=this.Obstacle)).map((node=>node.UserData)))}InteriorEdgeCrossesConvexHullSiblings(){const rect=Rectangle.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);return this.InteriorEdgeCrossesObstacleRFI(rect,(obs=>obs.PaddedPolyline),this.Obstacle.ConvexHull.Obstacles.filter((obs=>obs!=this.Obstacle)))}InteriorEdgeCrossesObstacleRFI(rect,whichPolylineToUse,candidates){let lineSeg=null;for(const blocker of candidates){const blockerPolyline=whichPolylineToUse(blocker);if(!StaticGraphUtility.RectangleInteriorsIntersect(rect,blockerPolyline.boundingBox))continue;lineSeg=null!=lineSeg?lineSeg:LineSegment.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);if(null!=Curve.intersectionOne(lineSeg,blockerPolyline,!1))return!0;if(PointLocation.Outside!=Curve.PointRelativeToCurveLocation(this.UnpaddedBorderIntersect,blockerPolyline))return!0}return!1}get HasGroupCrossings(){return null!=this.pointAndCrossingsList&&this.pointAndCrossingsList.Count()>0}HasGroupCrossingBeforePoint(point){if(!this.HasGroupCrossings)return!1;const pac=StaticGraphUtility.IsAscending(this.OutwardDirection)?this.pointAndCrossingsList.First:this.pointAndCrossingsList.Last;return PointComparer.GetDirections(this.MaxVisibilitySegment.start,pac.Location)==PointComparer.GetDirections(pac.Location,point)}AddToAdjacentVertex(transUtil,targetVertex,limitRect,routeToCenter){let borderVertex=transUtil.VisGraph.FindVertex(this.VisibilityBorderIntersect);null==borderVertex?(this.OutwardDirection==PointComparer.GetDirections(targetVertex.point,this.VisibilityBorderIntersect)?(this.VisibilityBorderIntersect=targetVertex.point,borderVertex=targetVertex):(borderVertex=transUtil.FindOrAddVertex(this.VisibilityBorderIntersect),transUtil.FindOrAddEdge(borderVertex,targetVertex,this.InitialWeight)),this.ExtendEdgeChain(transUtil,borderVertex,targetVertex,limitRect,routeToCenter)):this.ExtendEdgeChain(transUtil,borderVertex,borderVertex,limitRect,routeToCenter)}ExtendEdgeChain(transUtil,paddedBorderVertex,targetVertex,limitRect,routeToCenter){transUtil.ExtendEdgeChainVRLPB(targetVertex,limitRect,this.MaxVisibilitySegment,this.pointAndCrossingsList,this.IsOverlapped);const unpaddedBorderVertex=transUtil.FindOrAddVertex(this.UnpaddedBorderIntersect);transUtil.FindOrAddEdge(unpaddedBorderVertex,paddedBorderVertex,this.unpaddedToPaddedBorderWeight),routeToCenter&&transUtil.ConnectVertexToTargetVertex(this.ObstaclePort.CenterVertex,unpaddedBorderVertex,this.OutwardDirection,this.InitialWeight)}toString(){return dist.Qf.Format("{0} {1}~{2} {3}",this.ObstaclePort.Location,this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect,this.OutwardDirection)}}class ObstaclePort{constructor(port,obstacle){this.HasCollinearEntrances=!1,this.VisibilityRectangle=Rectangle.mkEmpty(),this.Port=port,this.Obstacle=obstacle,this.PortEntrances=new Array,this.Location=GeomConstants.RoundPoint(this.Port.Location)}CreatePortEntrance(unpaddedBorderIntersect,outDir,obstacleTree){const entrance=new ObstaclePortEntrance(this,unpaddedBorderIntersect,outDir,obstacleTree);this.PortEntrances.push(entrance),this.VisibilityRectangle.add(entrance.MaxVisibilitySegment.end),this.HasCollinearEntrances=this.HasCollinearEntrances||entrance.IsCollinearWithPort}ClearVisibility(){this.PortEntrances=[]}AddToGraph(transUtil,routeToCenter){routeToCenter&&(this.CenterVertex=transUtil.FindOrAddVertex(this.Location))}RemoveFromGraph(){this.CenterVertex=null}get LocationHasChanged(){return!point_Point.closeDistEps(this.Location,GeomConstants.RoundPoint(this.Port.Location))}get PortCurve(){return this.Port.Curve}get PortLocation(){return this.Port.Location}toString(){return this.Port+this.Obstacle.toString()}}class FreePoint{constructor(transUtil,point){this.maxVisibilitySegmentsAndCrossings=new Array(4),this.OutOfBoundsDirectionFromGraph=Direction.None,this.GetVertex(transUtil,point)}get Point(){return this.Vertex.point}get InitialWeight(){return this.IsOverlapped?ScanSegment.OverlappedWeight:ScanSegment.NormalWeight}get IsOutOfBounds(){return Direction.None!=this.OutOfBoundsDirectionFromGraph}GetVertex(transUtil,point){this.Vertex=transUtil.FindOrAddVertex(point)}AddEdgeToAdjacentEdge(transUtil,targetEdge,dirToExtend,limitRect){const targetIntersect=StaticGraphUtility.SegmentIntersectionEP(targetEdge,this.Point);let targetVertex=transUtil.VisGraph.FindVertex(targetIntersect);return null!=targetVertex?this.AddToAdjacentVertex(transUtil,targetVertex,dirToExtend,limitRect):targetVertex=transUtil.AddEdgeToTargetEdge(this.Vertex,targetEdge,targetIntersect),this.ExtendEdgeChain(transUtil,targetVertex,dirToExtend,limitRect),targetVertex}AddToAdjacentVertex(transUtil,targetVertex,dirToExtend,limitRect){PointComparer.EqualPP(this.Point,targetVertex.point)||transUtil.FindOrAddEdge(this.Vertex,targetVertex,this.InitialWeight),this.ExtendEdgeChain(transUtil,targetVertex,dirToExtend,limitRect)}ExtendEdgeChain(transUtil,targetVertex,dirToExtend,limitRect){let extendOverlapped=this.IsOverlapped;extendOverlapped&&(extendOverlapped=transUtil.ObstacleTree.PointIsInsideAnObstaclePD(targetVertex.point,dirToExtend));const segmentAndCrossings=this.GetSegmentAndCrossings(this.IsOverlapped?targetVertex:this.Vertex,dirToExtend,transUtil);transUtil.ExtendEdgeChainVRLPB(targetVertex,limitRect,segmentAndCrossings[0],segmentAndCrossings[1],extendOverlapped)}GetSegmentAndCrossings(startVertex,dirToExtend,transUtil){const dirIndex=CompassVector.ToIndex(dirToExtend);let segmentAndCrossings=this.maxVisibilitySegmentsAndCrossings[dirIndex];if(null==segmentAndCrossings){const t={pacList:null};segmentAndCrossings=[transUtil.ObstacleTree.CreateMaxVisibilitySegment(startVertex.point,dirToExtend,t),t.pacList],this.maxVisibilitySegmentsAndCrossings[dirIndex]=segmentAndCrossings}else PointComparer.GetDirections(startVertex.point,segmentAndCrossings[0].start)==dirToExtend&&(segmentAndCrossings[0].start=startVertex.point);return segmentAndCrossings}MaxVisibilityInDirectionForNonOverlappedFreePoint(dirToExtend,transUtil){return this.GetSegmentAndCrossings(this.Vertex,dirToExtend,transUtil)[0].end}AddOobEdgesFromGraphCorner(transUtil,cornerPoint){const dirs=PointComparer.GetDirections(cornerPoint,this.Vertex.point),cornerVertex=transUtil.VisGraph.FindVertex(cornerPoint);transUtil.ConnectVertexToTargetVertex(cornerVertex,this.Vertex,dirs&(Direction.North|Direction.South),ScanSegment.NormalWeight),transUtil.ConnectVertexToTargetVertex(cornerVertex,this.Vertex,dirs&(Direction.East|Direction.West),ScanSegment.NormalWeight)}RemoveFromGraph(){this.Vertex=null}toString(){return this.Vertex.toString()}}class GroupBoundaryCrossing{constructor(group,dirToInside){this.BoundaryWidth=GeomConstants.distanceEpsilon,this.Group=group,this.DirectionToInside=dirToInside}GetInteriorVertexPoint(outerVertex){return GeomConstants.RoundPoint(outerVertex.add(CompassVector.toPoint(this.DirectionToInside).mul(this.BoundaryWidth)))}toString(){return dist.Qf.Format("{0} {1}",this.DirectionToInside,this.Group)}}GroupBoundaryCrossing.BoundaryWidth=GeomConstants.distanceEpsilon;class AxisCoordinateEvent extends SweepEvent{constructor(p){super(),this.site=p}get Site(){return this.site}}class BasicVertexEvent extends VertexEvent{constructor(obstacle,p){super(p),this.Obstacle=obstacle}}class OpenVertexEvent extends BasicVertexEvent{constructor(obstacle,p){super(obstacle,p)}}class ScanSegmentVectorItem{constructor(coord){this.Coord=coord}AddPendingPerpendicularCoord(coord){null==this.pendingPerpCoords&&(this.pendingPerpCoords=new Array),this.pendingPerpCoords.push(coord)}ResetForIntersections(){this.CurrentSegment=this.FirstSegment}get IsHorizontal(){return!this.FirstSegment.IsVertical}TraverseToSegmentContainingPoint(point){if(this.CurrentSegment.ContainsPoint(point))return!0;const pointCoord=this.IsHorizontal?point.y:point.x;if(!PointComparer.Equal(this.Coord,pointCoord)){for(;this.MoveNext(););return!1}for(;;){if((null==this.CurrentSegment.NextSegment||PointComparer.GetDirections(this.CurrentSegment.End,point)==PointComparer.GetDirections(point,this.CurrentSegment.NextSegment.Start))&&point_Point.closeIntersections(this.CurrentSegment.End,point))return this.CurrentSegment.Update(this.CurrentSegment.Start,point),!0;if(!this.MoveNext())return!1;if(this.CurrentSegment.ContainsPoint(point))return!0;if(PointComparer.IsPureLower(point,this.CurrentSegment.Start))return this.CurrentSegment.Update(point,this.CurrentSegment.End),!0}}MoveNext(){return this.CurrentSegment=this.CurrentSegment.NextSegment,this.HasCurrent}get HasCurrent(){return null!=this.CurrentSegment}PointIsCurrentEndAndNextStart(point){return point.equal(this.CurrentSegment.End)&&null!=this.CurrentSegment.NextSegment&&point.equal(this.CurrentSegment.NextSegment.Start)}AddPerpendicularCoord(perpCoord){const point=this.IsHorizontal?new point_Point(perpCoord,this.Coord):new point_Point(this.Coord,perpCoord);this.TraverseToSegmentContainingPoint(point),this.CurrentSegment.AddSparseVertexCoord(perpCoord)}toString(){return null==this.FirstSegment?"-0- "+this.Coord:this.IsHorizontal?"(H) Y == "+this.Coord:"(V) X == "}AppendScanSegment(segment){null==this.FirstSegment?this.FirstSegment=segment:this.CurrentSegment.NextSegment=segment,this.CurrentSegment=segment}AddPendingPerpendicularCoordsToScanSegments(){if(null!=this.pendingPerpCoords){this.ResetForIntersections();for(const point of this.pendingPerpCoords)this.AddPerpendicularCoord(point)}}}class ScanSegmentVector{constructor(coordMap,isHorizontal){this.CurrentSlotIndex=0,this.vector=[],this.IsHorizontal=isHorizontal;const coords=Array.from(coordMap).sort(((a,b)=>a>b?1:a<b?-1:0));for(const c of coords)this.vector.push(new ScanSegmentVectorItem(c))}get Length(){return this.vector.length}get CurrentSlot(){return this.vector[this.CurrentSlotIndex]}Item(slot){return this.vector[slot]}CreateScanSegment(start,end,weight,gbcList){this.CurrentSlot.AppendScanSegment(new ScanSegment(start,end,weight,gbcList))}ScanSegmentsCompleteForCurrentSlot(){this.CurrentSlotIndex++}ScanSegmentsComplete(){for(const item of this.vector)item.AddPendingPerpendicularCoordsToScanSegments()}Items(){return this.vector}ResetForIntersections(){for(const t of this.vector)t.ResetForIntersections()}FindNearest(coord,directionIfMiss){let low=0,high=this.vector.length-1;if(coord<=this.vector[low].Coord)return low;if(coord>=this.vector[high].Coord)return high;for(;high-low>2;){const mid=low+(high-low>>1),item=this.vector[mid];if(coord<item.Coord)high=mid;else{if(!(coord>item.Coord))return mid;low=mid}}for(low++;low<=high;low++){const item=this.vector[low];if(coord<item.Coord)return directionIfMiss>0?low:low-1;if(coord==item.Coord)break}return low}CreateSparseVerticesAndEdges(vg){for(const item of this.vector){item.ResetForIntersections();for(let segment=item.FirstSegment;null!=segment;segment=segment.NextSegment)segment.CreateSparseVerticesAndEdges(vg)}}GetParallelCoord(site){return this.IsHorizontal?site.y:site.x}GetPerpendicularCoord(site){return this.IsHorizontal?site.x:site.y}ConnectAdjoiningSegmentEndpoints(){for(const item of this.vector){item.ResetForIntersections();let prevSegment=item.FirstSegment;for(let segment=prevSegment.NextSegment;null!=segment;segment=segment.NextSegment){if(segment.HasSparsePerpendicularCoords&&prevSegment.HasSparsePerpendicularCoords&&segment.Start==prevSegment.End){const perpCoord=this.GetPerpendicularCoord(segment.Start);prevSegment.AddSparseEndpoint(perpCoord),segment.AddSparseEndpoint(perpCoord)}prevSegment=segment}}}toString(){return(this.IsHorizontal?"(H) count":"(V) count == ")+this.vector.length}}class BasicReflectionEvent extends SweepEvent{constructor(initialObstacle,reflectingObstacle,site){super(),this.InitialObstacle=initialObstacle,this.ReflectingObstacle=reflectingObstacle,this.site=site}static mk(previousSite,reflectingObstacle,site){const ret=new BasicReflectionEvent(previousSite.ReflectingObstacle,reflectingObstacle,site);return ret.PreviousSite=previousSite,ret}IsStaircaseStep(reflectionTarget){return this.InitialObstacle==reflectionTarget}get Site(){return this.site}}class EventQueue{constructor(){this.eventTree=new BinaryHeapWithComparer(((a,b)=>this.Compare(a,b)))}Reset(scanDir){this.scanDirection=scanDir}Enqueue(evt){this.eventTree.Enqueue(evt)}Dequeue(){return this.eventTree.Dequeue()}get Count(){return this.eventTree.Count}Compare(lhs,rhs){if(lhs==rhs)return 0;if(null==lhs)return-1;if(null==rhs)return 1;let cmp=this.scanDirection.ComparePerpCoord(lhs.Site,rhs.Site);if(cmp)return cmp;return cmp=(lhs instanceof BasicReflectionEvent?0:1)-(rhs instanceof BasicReflectionEvent?0:1),cmp||this.scanDirection.CompareScanCoord(lhs.Site,rhs.Site)}}class GroupBoundaryCrossingMap{constructor(){this.pointCrossingMap=new PointMap,this.pointList=new Array}AddIntersection(intersection,group,dirToInside){let crossings=this.pointCrossingMap.get(intersection);crossings||(crossings=new Array,this.pointCrossingMap.set(intersection,crossings));const crossingsCount=crossings.length;for(let ii=0;ii<crossingsCount;ii++){const crossing=crossings[ii];if(crossing.Group==group)return crossing}const newCrossing=new GroupBoundaryCrossing(group,dirToInside);return crossings.push(newCrossing),newCrossing}Clear(){this.pointCrossingMap.clear()}GetOrderedListBetween(start,end){if(0==this.pointCrossingMap.size)return null;if(PointComparer.ComparePP(start,end)>0){const temp=start;start=end,end=temp}this.pointList=[];for(const intersection of this.pointCrossingMap.keys())PointComparer.ComparePP(intersection,start)>=0&&PointComparer.ComparePP(intersection,end)<=0&&this.pointList.push(intersection);this.pointList.sort(((a,b)=>a.compareTo(b)));const pointAndCrossingList=new PointAndCrossingsList,numCrossings=this.pointList.length;for(let ii=0;ii<numCrossings;ii++){const intersect=this.pointList[ii];pointAndCrossingList.Add(intersect,this.pointCrossingMap.get(intersect))}return pointAndCrossingList}toString(){return dist.Qf.Format("{0}",this.pointCrossingMap.size)}}class HighReflectionEvent extends BasicReflectionEvent{constructor(previousSite,targetSide,site){super(previousSite.ReflectingObstacle,targetSide.Obstacle,site),this.Side=targetSide}}class LookaheadScan{constructor(scanDir){this.staleSites=new Array,this.scanDirection=scanDir,this.eventTree=new RBTree(((a,b)=>this.CompareBB(a,b))),this.findFirstPred=n=>this.CompareToFindFirstPoint(n.Site)>=0}Add(initialSite){this.eventTree.insert(initialSite)}MarkStaleSite(siteEvent){this.staleSites.push(siteEvent)}RemoveStaleSites(){const cSites=this.staleSites.length;if(cSites>0){for(let ii=0;ii<cSites;ii++)this.RemoveExact(this.staleSites[ii]);this.staleSites=[]}}RemoveSitesForFlatBottom(low,high){for(let node=this.FindFirstInRange(low,high);null!=node;node=this.FindNextInRange(node,high))this.MarkStaleSite(node.item);this.RemoveStaleSites()}Find(site){return this.FindFirstInRange(site,site)}RemoveExact(initialSite){const node=this.eventTree.find(initialSite);return null!=node&&node.item.Site==initialSite.Site&&(this.eventTree.deleteNodeInternal(node),!0)}FindFirstInRange(low,high){this.findFirstPoint=low;const nextNode=this.eventTree.findFirst(this.findFirstPred);return null!=nextNode&&this.Compare(nextNode.item.Site,high)<=0?nextNode:null}CompareToFindFirstPoint(treeItem){return this.Compare(treeItem,this.findFirstPoint)}FindNextInRange(prev,high){const nextNode=this.eventTree.next(prev);return null!=nextNode&&this.Compare(nextNode.item.Site,high)<=0?nextNode:null}CompareBB(lhs,rhs){return this.scanDirection.CompareScanCoord(lhs.Site,rhs.Site)}Compare(lhs,rhs){return this.scanDirection.CompareScanCoord(lhs,rhs)}}class LowBendVertexEvent extends BasicVertexEvent{constructor(obstacle,p){super(obstacle,p)}}class HighBendVertexEvent extends BasicVertexEvent{constructor(obstacle,p){super(obstacle,p)}}class CloseVertexEvent extends BasicVertexEvent{constructor(obstacle,p){super(obstacle,p)}}class LowReflectionEvent extends BasicReflectionEvent{constructor(previousSite,targetSide,site){super(previousSite.ReflectingObstacle,targetSide.obstacle,site),this.Side=targetSide}}class NeighborSides{get LowNeighborSide(){return null==this.LowNeighbor?null:this.LowNeighbor.item}get HighNeighborSide(){return null==this.HighNeighbor?null:this.HighNeighbor.item}Clear(){this.LowNeighbor=null,this.LowOverlapEnd=null,this.GroupSideInterveningBeforeLowNeighbor=null,this.HighNeighbor=null,this.HighOverlapEnd=null,this.GroupSideInterveningBeforeHighNeighbor=null}SetSides(dir,neighborNode,overlapEndNode,interveningGroupSide){if(StaticGraphUtility.IsAscending(dir))return this.HighNeighbor=neighborNode,this.HighOverlapEnd=overlapEndNode,void(this.GroupSideInterveningBeforeHighNeighbor=interveningGroupSide);this.LowNeighbor=neighborNode,this.LowOverlapEnd=overlapEndNode,this.GroupSideInterveningBeforeLowNeighbor=interveningGroupSide}}class OverlapConvexHull{constructor(polyline,obstacles){this.Polyline=polyline,this.Obstacles=Array.from(obstacles),this.PrimaryObstacle=this.Obstacles[0],Obstacle.RoundVerticesAndSimplify(this.Polyline)}}class SpliceUtility{static MungeClosestIntersectionInfo(rayOrigin,closestIntersection,isHorizontal){const bbox=closestIntersection.seg1.boundingBox,closest=GeomConstants.RoundPoint(closestIntersection.x).clone();return isHorizontal?new point_Point(SpliceUtility.MungeIntersect(rayOrigin.x,closest.x,bbox.left,bbox.right),closest.y):new point_Point(closest.x,SpliceUtility.MungeIntersect(rayOrigin.y,closest.y,bbox.bottom,bbox.top))}static MungeIntersect(site,intersect,start,end){if(site<intersect){const min=Math.min(start,end);intersect<min&&(intersect=min)}else if(site>intersect){const max=Math.max(start,end);intersect>max&&(intersect=max)}return GeomConstants.RoundDouble(intersect)}}class ObstacleTree{constructor(){this.CurrentGroupBoundaryCrossingMap=new GroupBoundaryCrossingMap,this.overlapPairs=new IntPairSet,this.hasOverlaps=!1,this.lookupIntPair=new IntPair(-1,-1)}get GraphBox(){return this.Root.irect}Init(obstacles,ancestorSets,idToObstacleMap){this.CreateObstacleListAndOrdinals(obstacles),this.AncestorSets=ancestorSets,this.CreateRoot(),this.shapeIdToObstacleMap=idToObstacleMap}CreateObstacleListAndOrdinals(obstacles){this.allObstacles=Array.from(obstacles);let scanlineOrdinal=Obstacle.FirstNonSentinelOrdinal;for(const obstacle of this.allObstacles)obstacle.Ordinal=scanlineOrdinal++}OrdinalToObstacle(index){return this.allObstacles[index-Obstacle.FirstNonSentinelOrdinal]}CreateRoot(){this.Root=ObstacleTree.CalculateHierarchy(this.GetAllObstacles()),this.OverlapsExist()&&(this.AccreteClumps(),this.AccreteConvexHulls(),this.GrowGroupsToAccommodateOverlaps(),this.Root=ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs=>obs.IsPrimaryObstacle))))}OverlapsExist(){return null!=this.Root&&(CrossRectangleNodesSameType(this.Root,this.Root,((a,b)=>this.CheckForInitialOverlaps(a,b))),this.hasOverlaps)}OverlapPairAlreadyFound(a,b){return this.lookupIntPair.x=b.Ordinal,this.lookupIntPair.y=a.Ordinal,this.overlapPairs.has(this.lookupIntPair)}CheckForInitialOverlaps(a,b){if(this.hasOverlaps)return;const t={bIsInsideA:!1,aIsInsideB:!1};ObstacleTree.ObstaclesIntersect(a,b,t)?this.hasOverlaps=!0:(t.aIsInsideB||t.bIsInsideA)&&(a.IsGroup&&b.IsGroup||a.IsGroup&&t.bIsInsideA||b.IsGroup&&t.aIsInsideB||(this.hasOverlaps=!0))}AccreteClumps(){this.AccumulateObstaclesForClumps(),this.CreateClumps()}AccreteConvexHulls(){for(;;)if(this.AccumulateObstaclesForConvexHulls(),!this.CreateConvexHulls())return}static CalculateHierarchy(obstacles){return CreateRectNodeOnArrayOfRectNodes(Array.from(obstacles).map((obs=>mkRectangleNode(obs,obs.VisibilityBoundingBox))))}AccumulateObstaclesForClumps(){this.overlapPairs.clear();const rectangularObstacles=ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs=>!obs.IsGroup&&obs.IsRectangle)));null!=rectangularObstacles&&CrossRectangleNodes(rectangularObstacles,rectangularObstacles,((a,b)=>this.EvaluateOverlappedPairForClump(a,b)))}EvaluateOverlappedPairForClump(a,b){if(a==b||this.OverlapPairAlreadyFound(a,b))return;const t={bIsInsideA:!1,aIsInsideB:!1};(ObstacleTree.ObstaclesIntersect(a,b,t)||t.aIsInsideB||t.bIsInsideA)&&this.overlapPairs.add(new IntPair(a.Ordinal,b.Ordinal))}AccumulateObstaclesForConvexHulls(){this.overlapPairs.clear();const allPrimaryNonGroupObstacles=ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs=>obs.IsPrimaryObstacle&&!obs.IsGroup)));null!=allPrimaryNonGroupObstacles&&CrossRectangleNodes(allPrimaryNonGroupObstacles,allPrimaryNonGroupObstacles,((a,b)=>this.EvaluateOverlappedPairForConvexHull(a,b)))}EvaluateOverlappedPairForConvexHull(a,b){if(a==b||this.OverlapPairAlreadyFound(a,b))return;const t={bIsInsideA:!1,aIsInsideB:!1};(ObstacleTree.ObstaclesIntersect(a,b,t)||t.aIsInsideB||t.bIsInsideA)&&(!a.IsInConvexHull&&!b.IsInConvexHull&&a.IsRectangle&&b.IsRectangle||(this.overlapPairs.add(new IntPair(a.Ordinal,b.Ordinal)),this.AddClumpToConvexHull(a),this.AddClumpToConvexHull(b),this.AddConvexHullToConvexHull(a),this.AddConvexHullToConvexHull(b)))}GrowGroupsToAccommodateOverlaps(){for(;;)if(this.AccumulateObstaclesForGroupOverlaps(),!this.GrowGroupsToResolveOverlaps())return}AccumulateObstaclesForGroupOverlaps(){const groupObstacles=ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs=>obs.IsGroup))),allPrimaryObstacles=ObstacleTree.CalculateHierarchy(this.GetAllObstacles().filter((obs=>obs.IsPrimaryObstacle)));null!=groupObstacles&&null!=allPrimaryObstacles&&CrossRectangleNodes(groupObstacles,allPrimaryObstacles,((a,b)=>this.EvaluateOverlappedPairForGroup(a,b)))}EvaluateOverlappedPairForGroup(a,b){if(a==b||this.OverlapPairAlreadyFound(a,b))return;const t={bIsInsideA:!1,aIsInsideB:!1},curvesIntersect=ObstacleTree.ObstaclesIntersect(a,b,t);(curvesIntersect||t.aIsInsideB||t.bIsInsideA)&&(a.IsRectangle&&b.IsRectangle?b.IsGroup||(t.aIsInsideB||ObstacleTree.FirstRectangleContainsACornerOfTheOther(b.VisibilityBoundingBox,a.VisibilityBoundingBox))&&(b.OverlapsGroupCorner=!0):(curvesIntersect||!b.IsGroup&&!t.bIsInsideA)&&this.overlapPairs.add(new IntPair(a.Ordinal,b.Ordinal)))}static FirstRectangleContainsACornerOfTheOther(a,b){return a.contains(b.leftBottom)||a.contains(b.leftTop)||a.contains(b.rightTop)||a.contains(b.rightBottom)}static FirstPolylineStartIsInsideSecondPolyline(first,second){return Curve.PointRelativeToCurveLocation(first.start,second)!=PointLocation.Outside}AddClumpToConvexHull(obstacle){if(obstacle.isOverlapped){for(const sibling of obstacle.clump.filter((sib=>sib.Ordinal!=obstacle.Ordinal)))this.overlapPairs.add(new IntPair(obstacle.Ordinal,sibling.Ordinal));obstacle.clump=[]}}AddConvexHullToConvexHull(obstacle){if(obstacle.IsInConvexHull){for(const sibling of obstacle.ConvexHull.Obstacles.filter((sib=>sib.Ordinal!=obstacle.Ordinal)))this.overlapPairs.add(new IntPair(obstacle.Ordinal,sibling.Ordinal));obstacle.ConvexHull.Obstacles=[]}}CreateClumps(){const connectedComponents=GetConnectedComponents(mkGraphOnEdges(Array.from(this.overlapPairs.values())));for(const component of connectedComponents){if(1==component.length)continue;const clump=component.map((i=>this.OrdinalToObstacle(i)));for(const obstacle of clump)obstacle.clump=clump}}CreateConvexHulls(){let found=!1;const connectedComponents=GetConnectedComponents(mkGraphOnEdges(Array.from(this.overlapPairs.values())));for(const component of connectedComponents){if(1==component.length)continue;found=!0;const obstacles=component.map(this.OrdinalToObstacle),points=flatMap(obstacles,(p=>Array.from(p.VisibilityPolyline))),och=new OverlapConvexHull(ConvexHull.createConvexHullAsClosedPolyline(points),obstacles);for(const obstacle of obstacles)obstacle.SetConvexHull(och)}return found}GrowGroupsToResolveOverlaps(){let found=!1;for(const pair of this.overlapPairs.values()){found=!0;const a=this.OrdinalToObstacle(pair.x),b=this.OrdinalToObstacle(pair.y);ObstacleTree.ResolveGroupAndGroupOverlap(a,b)||ObstacleTree.ResolveGroupAndObstacleOverlap(a,b)}return this.overlapPairs.clear(),found}static ResolveGroupAndGroupOverlap(a,b){return!!b.IsGroup&&(a.VisibilityPolyline.boundingBox.area>b.VisibilityPolyline.boundingBox.area?ObstacleTree.ResolveGroupAndObstacleOverlap(a,b):ObstacleTree.ResolveGroupAndObstacleOverlap(b,a),!0)}static ResolveGroupAndObstacleOverlap(group,obstacle){let loosePolyline=obstacle.looseVisibilityPolyline;ObstacleTree.GrowGroupAroundLoosePolyline(group,loosePolyline);const t={bIsInsideA:!1,aIsInsideB:!1};for(;ObstacleTree.ObstaclesIntersect(obstacle,group,t)||!t.aIsInsideB;)loosePolyline=Obstacle.CreateLoosePolyline(loosePolyline),ObstacleTree.GrowGroupAroundLoosePolyline(group,loosePolyline)}static GrowGroupAroundLoosePolyline(group,loosePolyline){const points=Array.from(group.VisibilityPolyline).concat(Array.from(loosePolyline));group.SetConvexHull(new OverlapConvexHull(ConvexHull.createConvexHullAsClosedPolyline(points),[group]))}static ObstaclesIntersect(a,b,t){return Curve.CurvesIntersect(a.VisibilityPolyline,b.VisibilityPolyline)?(t.aIsInsideB=!1,t.bIsInsideA=!1,!0):(t.aIsInsideB=ObstacleTree.FirstPolylineStartIsInsideSecondPolyline(a.VisibilityPolyline,b.VisibilityPolyline),t.bIsInsideA=!t.aIsInsideB&&ObstacleTree.FirstPolylineStartIsInsideSecondPolyline(b.VisibilityPolyline,a.VisibilityPolyline),(!a.IsRectangle||!b.IsRectangle)&&(!!ObstacleTree.ObstaclesAreCloseEnoughToBeConsideredTouching(a,b,t.aIsInsideB,t.bIsInsideA)&&(t.aIsInsideB=!1,t.bIsInsideA=!1,!0)))}static ObstaclesAreCloseEnoughToBeConsideredTouching(a,b,aIsInsideB,bIsInsideA){if(!aIsInsideB&&!bIsInsideA)return Curve.CurvesIntersect(a.looseVisibilityPolyline,b.VisibilityPolyline);const innerLoosePolyline=aIsInsideB?a.looseVisibilityPolyline:b.looseVisibilityPolyline,outerPolyline=aIsInsideB?b.VisibilityPolyline:a.VisibilityPolyline;for(const innerPoint of innerLoosePolyline)if(Curve.PointRelativeToCurveLocation(innerPoint,outerPolyline)==PointLocation.Outside){const outerParamPoint=Curve.ClosestPoint(outerPolyline,innerPoint);if(!point_Point.closeIntersections(innerPoint,outerParamPoint))return!0}return!1}AdjustSpatialAncestors(){if(this.SpatialAncestorsAdjusted)return!1;for(const group of this.GetAllGroups()){const groupBox=group.VisibilityBoundingBox;for(const obstacle of this.Root.GetNodeItemsIntersectingRectangle(groupBox))if(obstacle!=group&&Curve.ClosedCurveInteriorsIntersect(obstacle.VisibilityPolyline,group.VisibilityPolyline)){if(obstacle.IsInConvexHull)for(const sibling of obstacle.ConvexHull.Obstacles)this.AncestorSets.get(sibling.InputShape).add(group.InputShape);this.AncestorSets.get(obstacle.InputShape).add(group.InputShape)}}let nonSpatialGroups=new Array;for(const child of this.Root.GetAllLeaves()){const childBox=child.VisibilityBoundingBox;nonSpatialGroups=nonSpatialGroups.concat(Array.from(this.AncestorSets.get(child.InputShape)).filter((anc=>!childBox.intersects(this.shapeIdToObstacleMap.get(anc).VisibilityBoundingBox))));for(const group of nonSpatialGroups)this.AncestorSets.get(child.InputShape).delete(group);nonSpatialGroups=[]}return this.SpatialAncestorsAdjusted=!0,!0}GetAllGroups(){return this.GetAllObstacles().filter((obs=>obs.IsGroup))}Clear(){this.Root=null,this.AncestorSets=null}CreateMaxVisibilitySegment(startPoint,dir,t){const graphBoxBorderIntersect=StaticGraphUtility.RectangleBorderIntersect(this.GraphBox,startPoint,dir);if(PointComparer.GetDirections(startPoint,graphBoxBorderIntersect)==Direction.None)return t.pacList=null,LineSegment.mkPP(startPoint,startPoint);const segment=this.RestrictSegmentWithObstacles(startPoint,graphBoxBorderIntersect);return t.pacList=this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(segment.start,segment.end),segment}GetAllObstacles(){return this.allObstacles}GetAllPrimaryObstacles(){return this.Root.GetAllLeaves()}IntersectionIsInsideAnotherObstacle(sideObstacle,eventObstacle,intersect,scanDirection){this.insideHitTestIgnoreObstacle1=eventObstacle,this.insideHitTestIgnoreObstacle2=sideObstacle,this.insideHitTestScanDirection=scanDirection;return null!=this.Root.FirstHitNodeWithPredicate(intersect,this.InsideObstacleHitTest.bind(this))}PointIsInsideAnObstaclePD(intersect,direction){return this.PointIsInsideAnObstacle(intersect,ScanDirection.GetInstance(direction))}PointIsInsideAnObstacle(intersect,scanDirection){this.insideHitTestIgnoreObstacle1=null,this.insideHitTestIgnoreObstacle2=null,this.insideHitTestScanDirection=scanDirection;return null!=this.Root.FirstHitNodeWithPredicate(intersect,this.InsideObstacleHitTest.bind(this))}InsideObstacleHitTest(location,obstacle){if(obstacle==this.insideHitTestIgnoreObstacle1||obstacle==this.insideHitTestIgnoreObstacle2)return HitTestBehavior.Continue;if(obstacle.IsGroup)return HitTestBehavior.Continue;if(!StaticGraphUtility.PointIsInRectangleInterior(location,obstacle.VisibilityBoundingBox))return HitTestBehavior.Continue;const high=StaticGraphUtility.RectangleBorderIntersect(obstacle.VisibilityBoundingBox,location,this.insideHitTestScanDirection.dir).add(this.insideHitTestScanDirection.DirectionAsPoint),low=StaticGraphUtility.RectangleBorderIntersect(obstacle.VisibilityBoundingBox,location,this.insideHitTestScanDirection.OppositeDirection).sub(this.insideHitTestScanDirection.DirectionAsPoint),testSeg=LineSegment.mkPP(low,high),xxs=Curve.getAllIntersections(testSeg,obstacle.VisibilityPolyline,!0);if(2==xxs.length){const firstInt=GeomConstants.RoundPoint(xxs[0].x),secondInt=GeomConstants.RoundPoint(xxs[1].x);if(!PointComparer.EqualPP(location,firstInt)&&!PointComparer.EqualPP(location,secondInt)&&location.compareTo(firstInt)!=location.compareTo(secondInt)&&!closeDistEps(Math.floor(xxs[0].par1),Math.floor(xxs[1].par1)))return HitTestBehavior.Stop}return HitTestBehavior.Continue}SegmentCrossesAnObstacle(startPoint,endPoint){this.stopAtGroups=!0,this.wantGroupCrossings=!1;const obstacleIntersectSeg=this.RestrictSegmentPrivate(startPoint,endPoint);return!PointComparer.EqualPP(obstacleIntersectSeg.end,endPoint)}SegmentCrossesANonGroupObstacle(startPoint,endPoint){this.stopAtGroups=!1,this.wantGroupCrossings=!1;const obstacleIntersectSeg=this.RestrictSegmentPrivate(startPoint,endPoint);return!PointComparer.EqualPP(obstacleIntersectSeg.end,endPoint)}RestrictSegmentWithObstacles(startPoint,endPoint){return this.stopAtGroups=!1,this.wantGroupCrossings=!0,this.RestrictSegmentPrivate(startPoint,endPoint)}RestrictSegmentPrivate(startPoint,endPoint){return this.GetRestrictedIntersectionTestSegment(startPoint,endPoint),this.currentRestrictedRay=LineSegment.mkPP(startPoint,endPoint),this.restrictedRayLengthSquared=startPoint.sub(endPoint).lengthSquared,this.CurrentGroupBoundaryCrossingMap.Clear(),this.RecurseRestrictRayWithObstacles(this.Root),this.currentRestrictedRay}GetRestrictedIntersectionTestSegment(startPoint,endPoint){const segDir=PointComparer.GetDirections(startPoint,endPoint),startX=Direction.West==segDir?this.GraphBox.right:Direction.East==segDir?this.GraphBox.left:startPoint.x,endX=Direction.West==segDir?this.GraphBox.left:Direction.East==segDir?this.GraphBox.right:endPoint.x,startY=Direction.South==segDir?2*this.GraphBox.top:Direction.North==segDir?this.GraphBox.bottom:startPoint.y,endY=Direction.South==segDir?this.GraphBox.bottom:Direction.North==segDir?this.GraphBox.top:startPoint.y;this.restrictedIntersectionTestSegment=LineSegment.mkPP(new point_Point(startX,startY),new point_Point(endX,endY))}RecurseRestrictRayWithObstacles(rectNode){if(!StaticGraphUtility.RectangleInteriorsIntersect(this.currentRestrictedRay.boundingBox,rectNode.irect))return;const obstacle=rectNode.UserData;if(null!=obstacle){const intersections=Curve.getAllIntersections(this.restrictedIntersectionTestSegment,obstacle.VisibilityPolyline,!0);return!obstacle.IsGroup||this.stopAtGroups?void this.LookForCloserNonGroupIntersectionToRestrictRay(intersections):void(this.wantGroupCrossings&&this.AddGroupIntersectionsToRestrictedRay(obstacle,intersections))}this.RecurseRestrictRayWithObstacles(rectNode.Left),this.RecurseRestrictRayWithObstacles(rectNode.Right)}LookForCloserNonGroupIntersectionToRestrictRay(intersections){let numberOfGoodIntersections=0,closestIntersectionInfo=null,localLeastDistSquared=this.restrictedRayLengthSquared;const testDirection=PointComparer.GetDirections(this.restrictedIntersectionTestSegment.start,this.restrictedIntersectionTestSegment.end);for(const intersectionInfo of intersections){const intersect=GeomConstants.RoundPoint(intersectionInfo.x),dirToIntersect=PointComparer.GetDirections(this.currentRestrictedRay.start,intersect);if(dirToIntersect==CompassVector.OppositeDir(testDirection))continue;if(numberOfGoodIntersections++,Direction.None==dirToIntersect){localLeastDistSquared=0,closestIntersectionInfo=intersectionInfo;continue}const distSquared=intersect.sub(this.currentRestrictedRay.start).lengthSquared;if(distSquared<localLeastDistSquared){if(intersectionInfo.x.sub(this.currentRestrictedRay.start).lengthSquared<GeomConstants.squareOfDistanceEpsilon)continue;localLeastDistSquared=distSquared,closestIntersectionInfo=intersectionInfo}}if(null!=closestIntersectionInfo){if(1==numberOfGoodIntersections){const intersect=GeomConstants.RoundPoint(closestIntersectionInfo.x);if(point_Point.closeIntersections(intersect,this.currentRestrictedRay.start)||point_Point.closeIntersections(intersect,this.currentRestrictedRay.end))return}this.restrictedRayLengthSquared=localLeastDistSquared,this.currentRestrictedRay.end=SpliceUtility.MungeClosestIntersectionInfo(this.currentRestrictedRay.start,closestIntersectionInfo,!StaticGraphUtility.IsVerticalPP(this.currentRestrictedRay.start,this.currentRestrictedRay.end))}}AddGroupIntersectionsToRestrictedRay(obstacle,intersections){for(const intersectionInfo of intersections){const intersect=GeomConstants.RoundPoint(intersectionInfo.x);if(intersect.sub(this.currentRestrictedRay.start).lengthSquared>this.restrictedRayLengthSquared)continue;const dirTowardIntersect=PointComparer.GetDirections(this.currentRestrictedRay.start,this.currentRestrictedRay.end),polyline=intersectionInfo.seg1;let dirToInsideOfGroup=dirTowardIntersect;CompassVector.VectorDirection(polyline.derivative(intersectionInfo.par1))&CompassVector.RotateRight(dirTowardIntersect)&&(dirToInsideOfGroup=CompassVector.OppositeDir(dirToInsideOfGroup)),this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect,obstacle,dirToInsideOfGroup)}}}class RectilinearScanLine{constructor(scanDir,start){this.scanDirection=scanDir,this.SideTree=new RBTree(((a,b)=>this.Compare(a,b))),this.linePositionAtLastInsertOrRemove=start}Insert(side,scanPos){this.linePositionAtLastInsertOrRemove=scanPos;return this.SideTree.insert(side)}get Count(){return this.SideTree.count}Remove(side,scanPos){this.linePositionAtLastInsertOrRemove=scanPos,this.SideTree.remove(side)}Find(side){return-1==this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove,side.Start)?null:this.SideTree.find(side)}NextLowB(side){return this.NextLowR(this.Find(side))}NextLowR(sideNode){return this.SideTree.previous(sideNode)}NextHighB(side){return this.NextHighR(this.Find(side))}NextHighR(sideNode){return this.SideTree.next(sideNode)}Next(dir,sideNode){return StaticGraphUtility.IsAscending(dir)?this.SideTree.next(sideNode):this.SideTree.previous(sideNode)}Lowest(){return this.SideTree.treeMinimum()}Compare(first,second){if(first.Obstacle==second.Obstacle)return first==second?0:first instanceof LowObstacleSide?-1:1;const firstIntersect=VisibilityGraphGenerator.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove,first,this.scanDirection),secondIntersect=VisibilityGraphGenerator.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove,second,this.scanDirection);let cmp=firstIntersect.compareTo(secondIntersect);if(0==cmp){cmp=function compareBooleans(a,b){return(a?1:0)-(b?1:0)}(first instanceof LowObstacleSide,second instanceof LowObstacleSide),0==cmp&&(cmp=compareNumbers(first.Obstacle.Ordinal,second.Obstacle.Ordinal))}return cmp}}class ScanSegmentTree{constructor(scanDir){this.lookupSegment=ScanSegment.mk(new point_Point(0,0),new point_Point(0,1)),this.ScanDirection=scanDir,this.segmentTree=new RBTree(((a,b)=>this.Compare(a,b))),this.findIntersectorPred=a=>this.CompareIntersector(a),this.findPointPred=a=>this.CompareToPoint(a)}get Segments(){return this.segmentTree.allNodes()}InsertUnique(seg){this.AssertValidSegmentForInsertion(seg);const node=this.segmentTree.find(seg);return null!=node?node:this.segmentTree.insert(seg)}AssertValidSegmentForInsertion(seg){}Remove(seg){this.segmentTree.remove(seg)}Find(start,end){this.lookupSegment.Update(start,end);const node=this.segmentTree.find(this.lookupSegment);return null!=node&&PointComparer.EqualPP(node.item.End,end)?node.item:null}FindLowestIntersector(start,end){const node=this.FindLowestIntersectorNode(start,end);return null!=node?node.item:null}FindLowestIntersectorNode(start,end){this.lookupSegment.Update(start,start);let node=this.segmentTree.findLast(this.findIntersectorPred);if(PointComparer.EqualPP(start,end))null!=node&&this.ScanDirection.Compare(node.item.End,start)<0&&(node=null);else for(this.lookupSegment.Update(start,end);null!=node&&!node.item.IntersectsSegment(this.lookupSegment);){if(this.ScanDirection.Compare(node.item.Start,end)>0)return null;node=this.segmentTree.next(node)}return node}FindHighestIntersector(start,end){this.lookupSegment.Update(end,end);let node=this.segmentTree.findLast(this.findIntersectorPred);if(PointComparer.EqualPP(start,end))null!=node&&this.ScanDirection.Compare(node.item.End,start)<0&&(node=null);else for(this.lookupSegment.Update(start,end);null!=node&&!node.item.IntersectsSegment(this.lookupSegment);){if(this.ScanDirection.Compare(node.item.End,start)<0)return null;node=this.segmentTree.previous(node)}return null!=node?node.item:null}CompareIntersector(seg){return this.ScanDirection.Compare(seg.Start,this.lookupSegment.Start)<=0}FindSegmentContainingPoint(location,allowUnfound){return this.FindSegmentOverlappingPoints(location,location,allowUnfound)}FindSegmentOverlappingPoints(start,end,allowUnfound){this.lookupSegment.Update(start,end);const node=this.segmentTree.findFirst(this.findPointPred);if(null!=node){const seg=node.item;if(this.ScanDirection.Compare(seg.Start,end)<=0)return seg}return null}CompareToPoint(treeSeg){return this.ScanDirection.Compare(treeSeg.End,this.lookupSegment.Start)>=0}MergeAndRemoveNextNode(currentSegment,nextSegNode){return-1==this.ScanDirection.Compare(currentSegment.End,nextSegNode.item.End)&&currentSegment.Update(currentSegment.Start,nextSegNode.item.End),currentSegment.MergeGroupBoundaryCrossingList(nextSegNode.item.GroupBoundaryPointAndCrossingsList),this.segmentTree.deleteNodeInternal(nextSegNode),this.segmentTree.find(currentSegment)}MergeSegments(){if(this.segmentTree.count<2)return;let currentSegNode=this.segmentTree.treeMinimum(),nextSegNode=this.segmentTree.next(currentSegNode);for(;null!=nextSegNode;nextSegNode=this.segmentTree.next(currentSegNode)){switch(this.ScanDirection.Compare(nextSegNode.item.Start,currentSegNode.item.End)){case 1:currentSegNode=nextSegNode;break;case 0:nextSegNode.item.IsOverlapped==currentSegNode.item.IsOverlapped?currentSegNode=this.MergeAndRemoveNextNode(currentSegNode.item,nextSegNode):(currentSegNode.item.NeedEndOverlapVertex=!0,nextSegNode.item.NeedStartOverlapVertex=!0,currentSegNode=nextSegNode);break;default:if(currentSegNode.item.IsOverlapped!=nextSegNode.item.IsOverlapped){if(currentSegNode.item.IsOverlapped)currentSegNode.item.Start==nextSegNode.item.Start?currentSegNode=this.MergeAndRemoveNextNode(nextSegNode.item,currentSegNode):(currentSegNode.item.Update(currentSegNode.item.Start,nextSegNode.item.Start),currentSegNode=nextSegNode);else if(currentSegNode.item.End==nextSegNode.item.End)currentSegNode=this.MergeAndRemoveNextNode(currentSegNode.item,nextSegNode);else{const nextSegment=nextSegNode.item,currentSegment=currentSegNode.item;this.segmentTree.deleteNodeInternal(nextSegNode),nextSegment.Update(currentSegment.End,nextSegment.End),this.segmentTree.insert(nextSegment),nextSegment.TrimGroupBoundaryCrossingList(),currentSegNode=this.segmentTree.find(currentSegment)}break}currentSegNode=this.MergeAndRemoveNextNode(currentSegNode.item,nextSegNode)}}}Compare(first,second){if(first==second)return 0;if(null==first)return-1;if(null==second)return 1;let cmp=this.ScanDirection.Compare(first.Start,second.Start);return 0==cmp&&(cmp=-1*this.ScanDirection.Compare(first.End,second.End)),cmp}}class VisibilityVertexRectilinear extends VisibilityVertex{constructor(point){super(point)}SetVertexEntry(entry){null==this.VertexEntries&&(this.VertexEntries=new Array(4)),this.VertexEntries[CompassVector.ToIndex(entry.Direction)]=entry}RemoveVertexEntries(){this.VertexEntries=null}}class VisibilityGraphGenerator{constructor(wantReflections){this.ObstacleTree=new ObstacleTree,this.CurrentGroupBoundaryCrossingMap=new GroupBoundaryCrossingMap,this.LowNeighborSides=new NeighborSides,this.HighNeighborSides=new NeighborSides,this.ScanDirection=ScanDirection.HorizontalInstance,this.eventQueue=new EventQueue,this.HorizontalScanSegments=new ScanSegmentTree(ScanDirection.HorizontalInstance),this.VerticalScanSegments=new ScanSegmentTree(ScanDirection.VerticalInstance),this.wantReflections=wantReflections}get ParallelScanSegments(){return this.ScanDirection.IsHorizontal?this.HorizontalScanSegments:this.VerticalScanSegments}get PerpendicularScanSegments(){return this.ScanDirection.IsHorizontal?this.VerticalScanSegments:this.HorizontalScanSegments}static NewVisibilityGraph(){const ret=new VisibilityGraph;return ret.VertexFactory=point=>new VisibilityVertexRectilinear(point),ret}GenerateVisibilityGraph(){if(null==this.ObstacleTree.Root)return;this.InitializeEventQueue(ScanDirection.HorizontalInstance);let scanlineSentinelOrdinal=Obstacle.FirstSentinelOrdinal,lowerCorner=new point_Point(this.ObstacleTree.GraphBox.left-VisibilityGraphGenerator.SentinelOffset,this.ObstacleTree.GraphBox.bottom-VisibilityGraphGenerator.SentinelOffset),upperCorner=new point_Point(this.ObstacleTree.GraphBox.left-VisibilityGraphGenerator.SentinelOffset,this.ObstacleTree.GraphBox.top+VisibilityGraphGenerator.SentinelOffset),sentinel=Obstacle.CreateSentinel(lowerCorner,upperCorner,this.ScanDirection,scanlineSentinelOrdinal++);this.scanLine.Insert(sentinel.ActiveHighSide,this.ObstacleTree.GraphBox.leftBottom),lowerCorner=new point_Point(this.ObstacleTree.GraphBox.right+VisibilityGraphGenerator.SentinelOffset,this.ObstacleTree.GraphBox.bottom-VisibilityGraphGenerator.SentinelOffset),upperCorner=new point_Point(this.ObstacleTree.GraphBox.right+VisibilityGraphGenerator.SentinelOffset,this.ObstacleTree.GraphBox.top+VisibilityGraphGenerator.SentinelOffset),sentinel=Obstacle.CreateSentinel(lowerCorner,upperCorner,this.ScanDirection,scanlineSentinelOrdinal++),this.scanLine.Insert(sentinel.ActiveLowSide,this.ObstacleTree.GraphBox.leftBottom),this.ProcessEvents(),this.InitializeEventQueue(ScanDirection.VerticalInstance),lowerCorner=new point_Point(this.ObstacleTree.GraphBox.left-VisibilityGraphGenerator.SentinelOffset,this.ObstacleTree.GraphBox.bottom-VisibilityGraphGenerator.SentinelOffset),upperCorner=new point_Point(this.ObstacleTree.GraphBox.right+VisibilityGraphGenerator.SentinelOffset,this.ObstacleTree.GraphBox.bottom-VisibilityGraphGenerator.SentinelOffset),sentinel=Obstacle.CreateSentinel(lowerCorner,upperCorner,this.ScanDirection,scanlineSentinelOrdinal++),this.scanLine.Insert(sentinel.ActiveHighSide,this.ObstacleTree.GraphBox.leftBottom),lowerCorner=new point_Point(this.ObstacleTree.GraphBox.left-VisibilityGraphGenerator.SentinelOffset,this.ObstacleTree.GraphBox.top+VisibilityGraphGenerator.SentinelOffset),upperCorner=new point_Point(this.ObstacleTree.GraphBox.right+VisibilityGraphGenerator.SentinelOffset,this.ObstacleTree.GraphBox.top+VisibilityGraphGenerator.SentinelOffset),sentinel=Obstacle.CreateSentinel(lowerCorner,upperCorner,this.ScanDirection,scanlineSentinelOrdinal),this.scanLine.Insert(sentinel.ActiveLowSide,this.ObstacleTree.GraphBox.leftBottom),this.ProcessEvents()}static ScanLineIntersectSidePBS(site,side,scanDir){const dir=side.Direction;let ix=side.Start.x,iy=side.Start.y;return scanDir.IsHorizontal?(ix+=dir.x/dir.y*(site.y-side.Start.y),ix=SpliceUtility.MungeIntersect(site.x,ix,side.Start.x,side.End.x),iy=site.y):(ix=site.x,iy+=dir.y/dir.x*(site.x-side.Start.x),iy=SpliceUtility.MungeIntersect(site.y,iy,side.Start.y,side.End.y)),new point_Point(ix,iy)}GetOpenVertex(poly){let lowest=poly.startPoint,next=this.TraversePolylineForEvents(lowest),iPrevCmp=this.PointCompare(next.point,lowest.point);for(;;next=this.TraversePolylineForEvents(next)){const iCurCmp=this.PointCompare(next.point,lowest.point);if(iCurCmp<=0)lowest=next;else if(iCurCmp>0&&iPrevCmp<=0)break;iPrevCmp=iCurCmp}return lowest}TraversePolylineForEvents(polyPoint){return this.ScanDirection.IsHorizontal?polyPoint.nextOnPolyline:polyPoint.prevOnPolyline}InitializeEventQueue(scanDir){this.ScanDirection=scanDir,this.eventQueue.Reset(this.ScanDirection),this.EnqueueBottomVertexEvents(),this.scanLine=new RectilinearScanLine(this.ScanDirection,this.ObstacleTree.GraphBox.leftBottom),this.lookaheadScan=new LookaheadScan(this.ScanDirection)}EnqueueBottomVertexEvents(){for(const obstacle of this.ObstacleTree.GetAllPrimaryObstacles()){const bottomVertex=this.GetOpenVertex(obstacle.VisibilityPolyline);this.eventQueue.Enqueue(new OpenVertexEvent(obstacle,bottomVertex))}}IsFlat(side){return this.ScanDirection.IsFlatS(side)}IsPerpendicular(side){return this.ScanDirection.IsPerpendicularS(side)}ScanLineIntersectSide(site,side){return VisibilityGraphGenerator.ScanLineIntersectSidePBS(site,side,this.ScanDirection)}SideReflectsUpward(side){return side instanceof LowObstacleSide?this.ScanDirection.Coord(side.End)>this.ScanDirection.Coord(side.Start):this.ScanDirection.Coord(side.End)<this.ScanDirection.Coord(side.Start)}SideReflectsDownward(side){return side instanceof LowObstacleSide?this.ScanDirection.Coord(side.End)<this.ScanDirection.Coord(side.Start):this.ScanDirection.Coord(side.End)>this.ScanDirection.Coord(side.Start)}StoreLookaheadSite(initialObstacle,reflectingSide,reflectionSite,wantExtreme){if(this.wantReflections&&!this.IsPerpendicular(reflectingSide)){if(!wantExtreme&&!StaticGraphUtility.PointIsInRectangleInterior(reflectionSite,reflectingSide.Obstacle.VisibilityBoundingBox))return;this.SideReflectsUpward(reflectingSide)&&null==this.lookaheadScan.Find(reflectionSite)&&this.lookaheadScan.Add(new BasicReflectionEvent(initialObstacle,reflectingSide.Obstacle,reflectionSite))}}LoadReflectionEvents(sideToQueue){this.LoadReflectionEventsBB(sideToQueue,sideToQueue)}LoadReflectionEventsBB(sideToQueue,sideWithRange){if(null==sideToQueue||this.SideReflectsUpward(sideToQueue)||this.IsPerpendicular(sideToQueue))return;const bbox1=Rectangle.mkPP(sideToQueue.Start,sideToQueue.End),bbox2=Rectangle.mkPP(sideWithRange.Start,sideWithRange.End);if(this.ScanDirection.IsHorizontal?!bbox1.intersectsOnX(bbox2):!bbox1.intersectsOnY(bbox2))return;const bboxIntersect=Rectangle.intersect(bbox1,bbox2),low=bboxIntersect.leftBottom,high=bboxIntersect.rightTop;let lookaheadSiteNode=this.lookaheadScan.FindFirstInRange(low,high);for(;null!=lookaheadSiteNode;){const intersect=VisibilityGraphGenerator.ScanLineIntersectSidePBS(lookaheadSiteNode.item.Site,sideToQueue,this.ScanDirection.PerpendicularInstance);this.ScanDirection.ComparePerpCoord(intersect,lookaheadSiteNode.item.Site)>0?this.AddReflectionEvent(lookaheadSiteNode.item,sideToQueue,intersect):lookaheadSiteNode.item.ReflectingObstacle!=sideToQueue.Obstacle&&this.lookaheadScan.MarkStaleSite(lookaheadSiteNode.item),lookaheadSiteNode=this.lookaheadScan.FindNextInRange(lookaheadSiteNode,high)}this.lookaheadScan.RemoveStaleSites()}AddPerpendicularReflectionSegment(currentEvent,eventSide,nborSide){if(this.lookaheadScan.RemoveExact(currentEvent.PreviousSite)){if(null==eventSide)return!1;if(currentEvent.PreviousSite.IsStaircaseStep(currentEvent.ReflectingObstacle)){if(!StaticGraphUtility.PointIsInRectangleInterior(currentEvent.Site,currentEvent.ReflectingObstacle.VisibilityBoundingBox))return!1;if(!this.InsertPerpendicularReflectionSegment(currentEvent.PreviousSite.Site,currentEvent.Site))return!1;if(null!=nborSide&&currentEvent.IsStaircaseStep(nborSide.Obstacle))return this.ScanLineCrossesObstacle(currentEvent.Site,nborSide.Obstacle)}}return!1}AddParallelReflectionSegment(eventObstacle,lowNborSide,highNborSide,action){{const intersect=this.ScanLineIntersectSide(action.Site,null!=lowNborSide?lowNborSide:highNborSide),start=null!=lowNborSide?intersect:action.Site,end=null!=lowNborSide?action.Site:intersect;return null==lowNborSide?lowNborSide=this.scanLine.NextLowB(highNborSide).item:highNborSide=this.scanLine.NextHighB(lowNborSide).item,this.InsertParallelReflectionSegment(start,end,eventObstacle,lowNborSide,highNborSide,action)}}AddReflectionEvent(previousSite,side,site){const lowSide=side;null!=lowSide?this.eventQueue.Enqueue(new LowReflectionEvent(previousSite,lowSide,site)):this.eventQueue.Enqueue(new HighReflectionEvent(previousSite,side,site))}AddSideToScanLine(side,scanPos){const node=this.scanLine.Insert(side,scanPos);return this.LoadReflectionEvents(side),node}RemoveSideFromScanLine(sideNode,scanPos){this.scanLine.Remove(sideNode.item,scanPos)}PointCompare(lhs,rhs){return this.ScanDirection.Compare(lhs,rhs)}Clear(){this.ObstacleTree.Clear(),this.eventQueue=new EventQueue,this.HorizontalScanSegments=new ScanSegmentTree(ScanDirection.HorizontalInstance),this.VerticalScanSegments=new ScanSegmentTree(ScanDirection.VerticalInstance),this.VisibilityGraph=null}ProcessEvents(){for(;this.eventQueue.Count>0;){const evt=this.eventQueue.Dequeue();evt instanceof OpenVertexEvent?this.ProcessEventO(evt):evt instanceof LowBendVertexEvent?this.ProcessEventLB(evt):evt instanceof HighBendVertexEvent?this.ProcessEventHB(evt):evt instanceof CloseVertexEvent?this.ProcessEventCV(evt):evt instanceof LowReflectionEvent?this.ProcessEventLR(evt):evt instanceof HighReflectionEvent?this.ProcessEventHR(evt):this.ProcessCustomEvent(evt),this.LowNeighborSides.Clear(),this.HighNeighborSides.Clear()}}ProcessCustomEvent(evt){}ScanLineCrossesObstacle(eventSite,obstacle){return this.ScanDirection.ComparePerpCoord(eventSite,obstacle.VisibilityBoundingBox.leftBottom)>0&&this.ScanDirection.ComparePerpCoord(eventSite,obstacle.VisibilityBoundingBox.rightTop)<0}FindInitialNeighborSides(sideNode,t){t.lowNborSideNode=this.scanLine.NextLowR(sideNode),t.highNborSideNode=this.scanLine.NextHighR(sideNode)}FindNeighborsBRR(vertexEvent,lowSideNode,highSideNode){this.LowNeighborSides.Clear(),this.HighNeighborSides.Clear(),this.FindNeighbors(vertexEvent,lowSideNode,this.LowNeighborSides),this.FindNeighbors(vertexEvent,highSideNode,this.HighNeighborSides)}FindNeighbors(vertexEvent,sideNode,neighborSides){const sideReferencePoint=vertexEvent instanceof OpenVertexEvent?sideNode.item.Start:sideNode.item.End,t={lowNborSideNode:null,highNborSideNode:null};this.FindInitialNeighborSides(sideNode,t),this.SkipToNeighbor(this.ScanDirection.OppositeDirection,sideNode.item,sideReferencePoint,t.lowNborSideNode,neighborSides),this.SkipToNeighbor(this.ScanDirection.Dir,sideNode.item,sideReferencePoint,t.highNborSideNode,neighborSides)}SkipToNeighbor(nborSearchDir,side,sideReferencePoint,nborNode,neighborSides){let overlapSideNode=null,interveningGroupSide=null;for(;;nborNode=this.scanLine.Next(nborSearchDir,nborNode))if(nborNode.item.Obstacle!=side.Obstacle)if(nborNode.item.Obstacle.IsGroup)this.ProcessGroupSideEncounteredOnTraversalToNeighbor(nborNode,sideReferencePoint,nborSearchDir)&&null==interveningGroupSide&&(interveningGroupSide=nborNode.item);else{if(nborNode.item instanceof HighObstacleSide!=StaticGraphUtility.IsAscending(nborSearchDir))break;this.ScanLineCrossesObstacle(sideReferencePoint,nborNode.item.Obstacle)&&(overlapSideNode=nborNode,interveningGroupSide=null)}neighborSides.SetSides(nborSearchDir,nborNode,overlapSideNode,interveningGroupSide)}ProcessGroupSideEncounteredOnTraversalToNeighbor(nborNode,sideReferencePoint,nborSearchDir){if(!this.ScanLineCrossesObstacle(sideReferencePoint,nborNode.item.Obstacle))return!1;const dirToInsideOfGroup=nborNode.item instanceof LowObstacleSide==StaticGraphUtility.IsAscending(nborSearchDir)?nborSearchDir:CompassVector.OppositeDir(nborSearchDir),intersect=this.ScanLineIntersectSide(sideReferencePoint,nborNode.item);return this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect,nborNode.item.Obstacle,dirToInsideOfGroup),!0}FindNeighborsAndProcessVertexEvent(lowSideNode,highSideNode,vertexEvent){this.CurrentGroupBoundaryCrossingMap.Clear(),this.FindNeighborsBRR(vertexEvent,lowSideNode,highSideNode),this.ProcessVertexEvent(lowSideNode,highSideNode,vertexEvent),this.CurrentGroupBoundaryCrossingMap.Clear()}ProcessEventO(openVertEvent){var _a,_b;const obstacle=openVertEvent.Obstacle;obstacle.CreateInitialSides(openVertEvent.Vertex,this.ScanDirection),this.AddSideToScanLine(obstacle.ActiveLowSide,openVertEvent.Site);const highSideNode=this.AddSideToScanLine(obstacle.ActiveHighSide,openVertEvent.Site),lowSideNode=this.scanLine.Find(obstacle.ActiveLowSide);this.FindNeighborsAndProcessVertexEvent(lowSideNode,highSideNode,openVertEvent);const lowReflector=null!==(_a=this.LowNeighborSides.GroupSideInterveningBeforeLowNeighbor)&&void 0!==_a?_a:this.LowNeighborSides.LowNeighborSide;this.SideReflectsUpward(lowReflector)&&this.LoadReflectionEvents(obstacle.ActiveLowSide);const highReflector=null!==(_b=this.HighNeighborSides.GroupSideInterveningBeforeHighNeighbor)&&void 0!==_b?_b:this.HighNeighborSides.HighNeighborSide;if(this.SideReflectsUpward(highReflector)&&this.LoadReflectionEvents(obstacle.ActiveHighSide),obstacle.ActiveHighSide.Start!=obstacle.ActiveLowSide.Start){const tempSide=new HighObstacleSide(obstacle,openVertEvent.Vertex,this.ScanDirection);this.lookaheadScan.RemoveSitesForFlatBottom(tempSide.Start,tempSide.End)}this.EnqueueLowBendVertexEvent(obstacle.ActiveLowSide),this.EnqueueHighBendOrCloseVertexEvent(obstacle.ActiveHighSide)}ProcessEventLB(lowVertEvent){const obstacle=lowVertEvent.Obstacle,lowSide=new LowObstacleSide(obstacle,lowVertEvent.Vertex,this.ScanDirection);this.ScanDirection.ComparePerpCoord(lowSide.End,lowSide.Start)>0&&(this.RemoveSideFromScanLine(this.scanLine.Find(obstacle.ActiveLowSide),lowVertEvent.Site),this.AddSideToScanLine(lowSide,lowVertEvent.Site),obstacle.ActiveLowSide=lowSide,this.EnqueueLowBendVertexEvent(lowSide))}EnqueueLowBendVertexEvent(lowSide){this.eventQueue.Enqueue(new LowBendVertexEvent(lowSide.Obstacle,lowSide.EndVertex))}ProcessEventHB(highVertEvent){const obstacle=highVertEvent.Obstacle,highSide=new HighObstacleSide(obstacle,highVertEvent.Vertex,this.ScanDirection);this.RemoveSideFromScanLine(this.scanLine.Find(obstacle.ActiveHighSide),highVertEvent.Site);const highSideNode=this.AddSideToScanLine(highSide,highVertEvent.Site);if(obstacle.ActiveHighSide=highSide,this.EnqueueHighBendOrCloseVertexEvent(obstacle.ActiveHighSide),this.wantReflections&&this.ScanDirection.IsHorizontal&&highSide.Start.x==obstacle.VisibilityBoundingBox.right&&this.SideReflectsUpward(highSide)){const nborSideNode=this.scanLine.NextHighR(highSideNode);nborSideNode.item instanceof LowObstacleSide&&this.SideReflectsDownward(nborSideNode.item)&&(obstacle.isOverlapped&&this.ObstacleTree.PointIsInsideAnObstacle(highSide.Start,this.ScanDirection)||(this.StoreLookaheadSite(nborSideNode.item.Obstacle,highSide,highSide.Start,!0),this.LoadReflectionEvents(nborSideNode.item)))}}EnqueueHighBendOrCloseVertexEvent(highSide){const obstacle=highSide.Obstacle,nextHighSideEnd=this.ScanDirection.IsHorizontal?highSide.EndVertex.prevOnPolyline:highSide.EndVertex.nextOnPolyline;this.ScanDirection.ComparePerpCoord(nextHighSideEnd.point,highSide.End)>0?this.eventQueue.Enqueue(new HighBendVertexEvent(obstacle,highSide.EndVertex)):this.eventQueue.Enqueue(new CloseVertexEvent(obstacle,highSide.EndVertex))}CreateCloseEventSegmentsAndFindNeighbors(closeVertEvent){const obstacle=closeVertEvent.Obstacle;let lowSideNode=this.scanLine.Find(obstacle.ActiveLowSide),highSideNode=this.scanLine.Find(obstacle.ActiveHighSide);if(1==this.scanLine.Compare(obstacle.ActiveLowSide,obstacle.ActiveHighSide)){const temp=lowSideNode;lowSideNode=highSideNode,highSideNode=temp}if(this.FindNeighborsAndProcessVertexEvent(lowSideNode,highSideNode,closeVertEvent),this.wantReflections&&obstacle.isOverlapped)for(let nextNode=this.scanLine.NextHighR(lowSideNode);nextNode.item!=highSideNode.item;nextNode=this.scanLine.NextHighR(nextNode))this.LoadReflectionEvents(nextNode.item);this.scanLine.Remove(obstacle.ActiveLowSide,closeVertEvent.Site),this.scanLine.Remove(obstacle.ActiveHighSide,closeVertEvent.Site)}ProcessEventCV(closeVertEvent){this.CreateCloseEventSegmentsAndFindNeighbors(closeVertEvent);const lowNborSide=this.LowNeighborSides.LowNeighbor.item,highNborSide=this.HighNeighborSides.HighNeighbor.item,obstacle=closeVertEvent.Obstacle;this.LoadReflectionEvents(lowNborSide),this.LoadReflectionEvents(highNborSide),obstacle.Close()}ProcessEventLR(lowIntEvent){const obstacle=lowIntEvent.Side.Obstacle,lowNborSide=this.scanLine.NextLowB(lowIntEvent.Side).item;this.AddPerpendicularReflectionSegment(lowIntEvent,lowIntEvent.Side,lowNborSide)&&this.AddParallelReflectionSegment(obstacle,lowNborSide,null,lowIntEvent)&&this.LoadReflectionEvents(obstacle.ActiveLowSide)}ProcessEventHR(highIntEvent){const obstacle=highIntEvent.Side.Obstacle,highNborSide=this.scanLine.NextHighB(highIntEvent.Side).item;this.AddPerpendicularReflectionSegment(highIntEvent,highIntEvent.Side,highNborSide)&&this.AddParallelReflectionSegment(obstacle,null,highNborSide,highIntEvent)&&this.LoadReflectionEvents(obstacle.ActiveHighSide)}MakeInBoundsLocation(location){const xPos=Math.max(location.x,this.ObstacleTree.GraphBox.left),yPos=Math.max(location.y,this.ObstacleTree.GraphBox.bottom);return new point_Point(Math.min(xPos,this.ObstacleTree.GraphBox.right),Math.min(yPos,this.ObstacleTree.GraphBox.top))}IsInBoundsV(vertex){return this.IsInBoundsP(vertex.point)}IsInBoundsP(p){return PointComparer.EqualPP(p,this.MakeInBoundsLocation(p))}}VisibilityGraphGenerator.SentinelOffset=1;class SparseVisibilityGraphGenerator extends VisibilityGraphGenerator{constructor(){super(!1),this.horizontalVertexPoints=new PointSet,this.verticalVertexPoints=new PointSet,this.boundingBoxSteinerPoints=new PointSet,this.xCoordAccumulator=new Set,this.yCoordAccumulator=new Set,this.horizontalCoordMap=new Map,this.verticalCoordMap=new Map}Clear(){super.Clear(),this.Cleanup()}Cleanup(){this.horizontalVertexPoints.clear(),this.verticalVertexPoints.clear(),this.boundingBoxSteinerPoints.clear(),this.xCoordAccumulator.clear(),this.yCoordAccumulator.clear(),this.horizontalCoordMap.clear(),this.verticalCoordMap.clear()}GenerateVisibilityGraph(){this.AccumulateVertexCoords(),this.CreateSegmentVectorsAndPopulateCoordinateMaps(),this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(),this.GenerateSparseIntersectionsFromVertexPoints(),this.CreateScanSegmentTrees(),this.Cleanup()}AccumulateVertexCoords(){for(const obstacle of this.ObstacleTree.GetAllObstacles())this.xCoordAccumulator.add(obstacle.VisibilityBoundingBox.left),this.xCoordAccumulator.add(obstacle.VisibilityBoundingBox.right),this.yCoordAccumulator.add(obstacle.VisibilityBoundingBox.top),this.yCoordAccumulator.add(obstacle.VisibilityBoundingBox.bottom)}CreateSegmentVectorsAndPopulateCoordinateMaps(){this.horizontalScanSegmentVector=new ScanSegmentVector(this.yCoordAccumulator,!0),this.verticalScanSegmentVector=new ScanSegmentVector(this.xCoordAccumulator,!1);for(let slot=0;slot<this.horizontalScanSegmentVector.Length;slot++)this.horizontalCoordMap.set(this.horizontalScanSegmentVector.Item(slot).Coord,slot);for(let slot=0;slot<this.verticalScanSegmentVector.Length;slot++)this.verticalCoordMap.set(this.verticalScanSegmentVector.Item(slot).Coord,slot)}RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(){super.GenerateVisibilityGraph(),this.horizontalScanSegmentVector.ScanSegmentsComplete(),this.verticalScanSegmentVector.ScanSegmentsComplete(),this.xCoordAccumulator.clear(),this.yCoordAccumulator.clear()}InitializeEventQueue(scanDir){super.InitializeEventQueue(scanDir),this.SetVectorsAndCoordMaps(scanDir),this.AddAxisCoordinateEvents(scanDir)}AddAxisCoordinateEvents(scanDir){if(scanDir.IsHorizontal)for(const coord of this.yCoordAccumulator)this.eventQueue.Enqueue(new AxisCoordinateEvent(new point_Point(this.ObstacleTree.GraphBox.left-SparseVisibilityGraphGenerator.SentinelOffset,coord)));else for(const coord of this.xCoordAccumulator)this.eventQueue.Enqueue(new AxisCoordinateEvent(new point_Point(coord,this.ObstacleTree.GraphBox.bottom-SparseVisibilityGraphGenerator.SentinelOffset)))}ProcessCustomEvent(evt){this.ProcessAxisCoordinate(evt)||this.ProcessCustomEvent(evt)}ProcessAxisCoordinate(evt){return evt instanceof AxisCoordinateEvent&&(this.CreateScanSegmentsOnAxisCoordinate(evt.Site),!0)}InsertPerpendicularReflectionSegment(start,end){return!1}InsertParallelReflectionSegment(start,end,eventObstacle,lowNborSide,highNborSide,action){return!1}ProcessVertexEvent(lowSideNode,highSideNode,vertexEvent){const vertexPoints=this.ScanDirection.IsHorizontal?this.horizontalVertexPoints:this.verticalVertexPoints;vertexPoints.add(vertexEvent.Site);const lowNborSide=this.LowNeighborSides.LowNeighbor.item,highNborSide=this.HighNeighborSides.HighNeighbor.item,highDir=this.ScanDirection.Dir,lowDir=this.ScanDirection.OppositeDirection,lowSteiner=this.ScanLineIntersectSide(vertexEvent.Site,lowNborSide),highSteiner=this.ScanLineIntersectSide(vertexEvent.Site,highNborSide);if(this.ObstacleTree.GraphBox.contains(lowSteiner)){const bboxIntersectBeforeLowSteiner=StaticGraphUtility.RectangleBorderIntersect(lowNborSide.Obstacle.VisibilityBoundingBox,lowSteiner,highDir);PointComparer.IsPureLower(bboxIntersectBeforeLowSteiner,vertexEvent.Site)&&this.boundingBoxSteinerPoints.add(bboxIntersectBeforeLowSteiner)}if(this.ObstacleTree.GraphBox.contains(highSteiner)){const bboxIntersectBeforeHighSteiner=StaticGraphUtility.RectangleBorderIntersect(highNborSide.Obstacle.VisibilityBoundingBox,highSteiner,lowDir);PointComparer.IsPureLower(vertexEvent.Site,bboxIntersectBeforeHighSteiner)&&this.boundingBoxSteinerPoints.add(bboxIntersectBeforeHighSteiner)}const t={lowCorner:void 0,highCorner:void 0};SparseVisibilityGraphGenerator.GetBoundingCorners(lowSideNode.item.Obstacle.VisibilityBoundingBox,vertexEvent instanceof OpenVertexEvent,this.ScanDirection.IsHorizontal,t),(PointComparer.IsPureLower(lowSteiner,t.lowCorner)||lowNborSide.Obstacle.IsInSameClump(vertexEvent.Obstacle))&&vertexPoints.add(t.lowCorner),(PointComparer.IsPureLower(t.highCorner,highSteiner)||highNborSide.Obstacle.IsInSameClump(vertexEvent.Obstacle))&&vertexPoints.add(t.highCorner)}static GetBoundingCorners(boundingBox,isLowSide,isHorizontal,t){if(isLowSide)return t.lowCorner=boundingBox.leftBottom,void(t.highCorner=isHorizontal?boundingBox.rightBottom:boundingBox.leftTop);t.lowCorner=isHorizontal?boundingBox.leftTop:boundingBox.rightBottom,t.highCorner=boundingBox.rightTop}CreateScanSegmentsOnAxisCoordinate(site){this.CurrentGroupBoundaryCrossingMap.Clear();const sideNode=this.scanLine.Lowest();let nextNode=this.scanLine.NextHighR(sideNode),overlapDepth=0,start=site,isInsideOverlappedObstacle=!1;for(;null!=nextNode;nextNode=this.scanLine.NextHighR(nextNode)){if(this.SkipSide(start,nextNode.item))continue;if(nextNode.item.Obstacle.IsGroup){(0==overlapDepth||isInsideOverlappedObstacle)&&this.HandleGroupCrossing(site,nextNode.item);continue}if(nextNode.item instanceof LowObstacleSide){if(overlapDepth>0){overlapDepth++;continue}start=this.CreateScanSegment(start,nextNode.item,ScanSegment.NormalWeight),this.CurrentGroupBoundaryCrossingMap.Clear(),overlapDepth=1,isInsideOverlappedObstacle=nextNode.item.Obstacle.isOverlapped}else overlapDepth++,overlapDepth>0||(start=nextNode.item.Obstacle.isOverlapped||nextNode.item.Obstacle.OverlapsGroupCorner?this.CreateScanSegment(start,nextNode.item,ScanSegment.OverlappedWeight):this.ScanLineIntersectSide(start,nextNode.item),this.CurrentGroupBoundaryCrossingMap.Clear(),isInsideOverlappedObstacle=!1)}const end=this.ScanDirection.IsHorizontal?new point_Point(this.ObstacleTree.GraphBox.right+SparseVisibilityGraphGenerator.SentinelOffset,start.y):new point_Point(start.x,this.ObstacleTree.GraphBox.top+SparseVisibilityGraphGenerator.SentinelOffset);this.parallelSegmentVector.CreateScanSegment(start,end,ScanSegment.NormalWeight,this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start,end)),this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot()}HandleGroupCrossing(site,groupSide){if(!this.ScanLineCrossesObstacle(site,groupSide.Obstacle))return;const dirToInsideOfGroup=groupSide instanceof LowObstacleSide?this.ScanDirection.Dir:this.ScanDirection.OppositeDirection,intersect=this.ScanLineIntersectSide(site,groupSide),crossing=this.CurrentGroupBoundaryCrossingMap.AddIntersection(intersect,groupSide.Obstacle,dirToInsideOfGroup);this.AddPerpendicularCoordForGroupCrossing(intersect);const interiorPoint=crossing.GetInteriorVertexPoint(intersect);this.AddPerpendicularCoordForGroupCrossing(interiorPoint)}AddPerpendicularCoordForGroupCrossing(intersect){const nonCrossingPerpSlot=this.FindPerpendicularSlot(intersect,0);-1!=nonCrossingPerpSlot&&this.perpendicularSegmentVector.Item(nonCrossingPerpSlot).AddPendingPerpendicularCoord(this.parallelSegmentVector.CurrentSlot.Coord)}SkipSide(start,side){if(side.Obstacle.IsSentinel)return!0;const bbox=side.Obstacle.VisibilityBoundingBox;return this.ScanDirection.IsHorizontal?start.y==bbox.bottom||start.y==bbox.top:start.x==bbox.left||start.x==bbox.right}CreateScanSegment(start,side,weight){const end=this.ScanLineIntersectSide(start,side);return start!=end&&this.parallelSegmentVector.CreateScanSegment(start,end,weight,this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(start,end)),end}GenerateSparseIntersectionsFromVertexPoints(){this.VisibilityGraph=SparseVisibilityGraphGenerator.NewVisibilityGraph(),this.GenerateSparseIntersectionsAlongHorizontalAxis(),this.GenerateSparseIntersectionsAlongVerticalAxis(),this.ConnectAdjoiningScanSegments(),this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph),this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph)}GenerateSparseIntersectionsAlongHorizontalAxis(){this.currentAxisPointComparer=comparePointsYFirst;const vertexPoints=Array.from(this.horizontalVertexPoints.values()).sort(this.currentAxisPointComparer),bboxSteinerPoints=Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);this.ScanDirection=ScanDirection.HorizontalInstance,this.SetVectorsAndCoordMaps(this.ScanDirection),this.GenerateSparseIntersections(vertexPoints,bboxSteinerPoints)}GenerateSparseIntersectionsAlongVerticalAxis(){this.currentAxisPointComparer=(a,b)=>a.compareTo(b);const vertexPoints=Array.from(this.verticalVertexPoints.values()).sort(this.currentAxisPointComparer),bboxSteinerPoints=Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);this.ScanDirection=ScanDirection.VerticalInstance,this.SetVectorsAndCoordMaps(this.ScanDirection),this.GenerateSparseIntersections(vertexPoints,bboxSteinerPoints)}SetVectorsAndCoordMaps(scanDir){scanDir.IsHorizontal?(this.parallelSegmentVector=this.horizontalScanSegmentVector,this.perpendicularSegmentVector=this.verticalScanSegmentVector,this.perpendicularCoordMap=this.verticalCoordMap):(this.parallelSegmentVector=this.verticalScanSegmentVector,this.perpendicularSegmentVector=this.horizontalScanSegmentVector,this.perpendicularCoordMap=this.horizontalCoordMap)}ConnectAdjoiningScanSegments(){this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints(),this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints()}GenerateSparseIntersections(vertexPoints,bboxSteinerPoints){this.perpendicularSegmentVector.ResetForIntersections(),this.parallelSegmentVector.ResetForIntersections();let i=1;const steinerPointsCounter={j:0};for(const item of this.parallelSegmentVector.Items())for(;item.CurrentSegment.ContainsPoint(vertexPoints[i])||this.AddSteinerPointsToInterveningSegments(vertexPoints[i],bboxSteinerPoints,steinerPointsCounter,item)&&item.TraverseToSegmentContainingPoint(vertexPoints[i]);)if(this.AddPointsToCurrentSegmentIntersections(bboxSteinerPoints,steinerPointsCounter,item),this.GenerateIntersectionsFromVertexPointForCurrentSegment(vertexPoints[i],item),item.PointIsCurrentEndAndNextStart(vertexPoints[i]))item.MoveNext();else if(++i>=vertexPoints.length)return}AddSteinerPointsToInterveningSegments(currentVertexPoint,bboxSteinerPoints,t,item){for(;t.j<bboxSteinerPoints.length&&-1==this.currentAxisPointComparer(bboxSteinerPoints[t.j],currentVertexPoint);){if(!item.TraverseToSegmentContainingPoint(bboxSteinerPoints[t.j]))return!1;this.AddPointsToCurrentSegmentIntersections(bboxSteinerPoints,t,item)}return!0}AddPointsToCurrentSegmentIntersections(pointsToAdd,t,parallelItem){for(;t.j<pointsToAdd.length&&parallelItem.CurrentSegment.ContainsPoint(pointsToAdd[t.j]);t.j++){const steinerSlot=this.FindPerpendicularSlot(pointsToAdd[t.j],0);this.AddSlotToSegmentIntersections(parallelItem,steinerSlot)}}GenerateIntersectionsFromVertexPointForCurrentSegment(site,parallelItem){const perpStartSlot=this.FindPerpendicularSlot(parallelItem.CurrentSegment.Start,1),perpEndSlot=this.FindPerpendicularSlot(parallelItem.CurrentSegment.End,-1),siteSlot=this.FindPerpendicularSlot(site,0);perpStartSlot>=perpEndSlot||(this.AddSlotToSegmentIntersections(parallelItem,perpStartSlot),this.AddSlotToSegmentIntersections(parallelItem,perpEndSlot),siteSlot>perpStartSlot&&siteSlot<perpEndSlot&&(this.AddSlotToSegmentIntersections(parallelItem,siteSlot),this.AddBinaryDivisionSlotsToSegmentIntersections(parallelItem,perpStartSlot,siteSlot,perpEndSlot)))}FindPerpendicularSlot(site,directionIfMiss){return SparseVisibilityGraphGenerator.FindIntersectingSlot(this.perpendicularSegmentVector,this.perpendicularCoordMap,site,directionIfMiss)}static FindIntersectingSlot(segmentVector,coordMap,site,directionIfMiss){const coord=segmentVector.GetParallelCoord(site),slot=coordMap.get(coord);return null!=slot?slot:0==directionIfMiss?-1:segmentVector.FindNearest(coord,directionIfMiss)}AddSlotToSegmentIntersections(parallelItem,perpSlot){const perpItem=this.perpendicularSegmentVector.Item(perpSlot);parallelItem.CurrentSegment.AddSparseVertexCoord(perpItem.Coord),perpItem.AddPerpendicularCoord(parallelItem.Coord)}AddBinaryDivisionSlotsToSegmentIntersections(parallelItem,startSlot,siteSlot,endSlot){let low=0,high=this.perpendicularSegmentVector.Length-1;for(;high-low>1;){const mid=low+Math.floor((high-low)/2);siteSlot<=mid?(high=mid,siteSlot<high&&high<=endSlot&&this.AddSlotToSegmentIntersections(parallelItem,high)):(low=mid,siteSlot>low&&low>=startSlot&&this.AddSlotToSegmentIntersections(parallelItem,low))}}CreateScanSegmentTrees(){SparseVisibilityGraphGenerator.CreateScanSegmentTree(this.horizontalScanSegmentVector,this.HorizontalScanSegments),SparseVisibilityGraphGenerator.CreateScanSegmentTree(this.verticalScanSegmentVector,this.VerticalScanSegments)}static CreateScanSegmentTree(segmentVector,segmentTree){for(const item of segmentVector.Items())for(let segment=item.FirstSegment;null!=segment;segment=segment.NextSegment)segment.HasVisibility()&&segmentTree.InsertUnique(segment)}}class TransientGraphUtility{constructor(graphGen){this.AddedVertices=new Array,this.AddedEdges=new Array,this.edgesToRestore=new Array,this.LimitPortVisibilitySpliceToEndpointBoundingBox=!1,this.GraphGenerator=graphGen}get ObstacleTree(){return this.GraphGenerator.ObstacleTree}get VisGraph(){return this.GraphGenerator.VisibilityGraph}get IsSparseVg(){return this.GraphGenerator instanceof SparseVisibilityGraphGenerator}AddVertex(location){const vertex=this.VisGraph.AddVertexP(location);return this.AddedVertices.push(vertex),vertex}FindOrAddVertex(location){const vertex=this.VisGraph.FindVertex(location);return null!=vertex?vertex:this.AddVertex(location)}FindOrAddEdgeVV(sourceVertex,targetVertex){return this.FindOrAddEdge(sourceVertex,targetVertex,ScanSegment.NormalWeight)}FindOrAddEdge(sourceVertex,targetVertex,weight){const dirToTarget=PointComparer.GetPureDirectionVV(sourceVertex,targetVertex),t={bracketSource:void 0,bracketTarget:void 0,splitVertex:void 0};TransientGraphUtility.GetBrackets(sourceVertex,targetVertex,dirToTarget,t);let edge=this.VisGraph.FindEdgePP(t.bracketSource.point,t.bracketTarget.point);return edge=null!=edge?this.SplitEdge(edge,t.splitVertex):this.CreateEdge(t.bracketSource,t.bracketTarget,weight),edge}static GetBrackets(sourceVertex,targetVertex,dirToTarget,t){if(t.splitVertex=targetVertex,!TransientGraphUtility.FindBracketingVertices(sourceVertex,targetVertex.point,dirToTarget,t)){const tt={bracketSource:null,bracketTarget:null};TransientGraphUtility.FindBracketingVertices(targetVertex,sourceVertex.point,CompassVector.OppositeDir(dirToTarget),tt)&&(t.bracketSource=tt.bracketTarget,t.splitVertex=sourceVertex),t.bracketTarget=tt.bracketSource}}static FindBracketingVertices(sourceVertex,targetPoint,dirToTarget,t){for(t.bracketSource=sourceVertex;t.bracketTarget=StaticGraphUtility.FindAdjacentVertex(t.bracketSource,dirToTarget),null!=t.bracketTarget;){if(point_Point.closeDistEps(t.bracketTarget.point,targetPoint))return!0;if(dirToTarget!=PointComparer.GetDirections(t.bracketTarget.point,targetPoint))break;t.bracketSource=t.bracketTarget}return null!=t.bracketTarget}CreateEdge(first,second,weight){let source=first,target=second;PointComparer.IsPureLower(source.point,target.point)||(source=second,target=first);const edge=new TollFreeVisibilityEdge(source,target,weight);return VisibilityGraph.AddEdge(edge),this.AddedEdges.push(edge),edge}RemoveFromGraph(){this.RemoveAddedVertices(),this.RemoveAddedEdges(),this.RestoreRemovedEdges()}RemoveAddedVertices(){for(const vertex of this.AddedVertices)null!=this.VisGraph.FindVertex(vertex.point)&&this.VisGraph.RemoveVertex(vertex);this.AddedVertices=[]}RemoveAddedEdges(){for(const edge of this.AddedEdges)null!=this.VisGraph.FindVertex(edge.SourcePoint)&&VisibilityGraph.RemoveEdge(edge);this.AddedEdges=[]}RestoreRemovedEdges(){for(const edge of this.edgesToRestore)VisibilityGraph.AddEdge(edge);this.edgesToRestore=[]}FindNextEdge(vertex,dir){return StaticGraphUtility.FindAdjacentEdge(vertex,dir)}FindPerpendicularOrContainingEdge(startVertex,dir,pointLocation){for(;;){const nextVertex=StaticGraphUtility.FindAdjacentVertex(startVertex,dir);if(null==nextVertex)break;const dirCheck=PointComparer.GetDirections(nextVertex.point,pointLocation);if(CompassVector.OppositeDir(dir)&dirCheck)return this.VisGraph.FindEdgePP(startVertex.point,nextVertex.point);startVertex=nextVertex}return null}FindNearestPerpendicularOrContainingEdge(startVertex,dir,pointLocation){PointComparer.GetDirections(startVertex.point,pointLocation);let currentVertex=startVertex;for(;null!=Direction.None;){const nextVertex=StaticGraphUtility.FindAdjacentVertex(currentVertex,undefined);if(null==nextVertex)break;if(CompassVector.OppositeDir(undefined)&PointComparer.GetDirections(nextVertex.point,pointLocation))break;currentVertex=nextVertex,PointComparer.GetDirections(currentVertex.point,pointLocation)}let perpEdge;for(;perpEdge=this.FindPerpendicularOrContainingEdge(currentVertex,dir,pointLocation),null==perpEdge&&currentVertex!=startVertex;)currentVertex=StaticGraphUtility.FindAdjacentVertex(currentVertex,CompassVector.OppositeDir(undefined));return perpEdge}ConnectVertexToTargetVertex(sourceVertex,targetVertex,finalEdgeDir,weight){if(point_Point.closeDistEps(sourceVertex.point,targetVertex.point))return;const targetDirs=PointComparer.GetDirections(sourceVertex.point,targetVertex.point);if(PointComparer.IsPureDirectionD(targetDirs))return void this.FindOrAddEdgeVV(sourceVertex,targetVertex);const bendPoint=StaticGraphUtility.FindBendPointBetween(sourceVertex.point,targetVertex.point,finalEdgeDir),bendVertex=this.FindOrAddVertex(bendPoint);this.FindOrAddEdge(sourceVertex,bendVertex,weight),this.FindOrAddEdge(bendVertex,targetVertex,weight)}AddEdgeToTargetEdge(sourceVertex,targetEdge,targetIntersect){let targetVertex=this.VisGraph.FindVertex(targetIntersect);return null==targetVertex&&(targetVertex=this.AddVertex(targetIntersect),this.SplitEdge(targetEdge,targetVertex)),this.FindOrAddEdgeVV(sourceVertex,targetVertex),targetVertex}SplitEdge(edge,splitVertex){return null==edge?null:point_Point.closeDistEps(edge.Source.point,splitVertex.point)||point_Point.closeDistEps(edge.Target.point,splitVertex.point)?edge:(edge instanceof TollFreeVisibilityEdge||this.edgesToRestore.push(edge),VisibilityGraph.RemoveEdge(edge),(this.IsSparseVg||edge.Weight==ScanSegment.OverlappedWeight)&&splitVertex.Degree>0?(this.FindOrAddEdge(splitVertex,edge.Source,edge.Weight),this.FindOrAddEdge(splitVertex,edge.Target,edge.Weight)):(this.CreateEdge(splitVertex,edge.Target,edge.Weight),this.CreateEdge(edge.Source,splitVertex,edge.Weight)))}ExtendEdgeChainVRLPB(startVertex,limitRect,maxVisibilitySegment,pacList,isOverlapped){const dir=PointComparer.GetDirections(maxVisibilitySegment.start,maxVisibilitySegment.end);if(dir==Direction.None)return;const oppositeFarBound=StaticGraphUtility.GetRectangleBound(limitRect,dir),maxDesiredSplicePoint=StaticGraphUtility.IsVerticalD(dir)?GeomConstants.RoundPoint(new point_Point(startVertex.point.x,oppositeFarBound)):GeomConstants.RoundPoint(new point_Point(oppositeFarBound,startVertex.point.y));if(point_Point.closeDistEps(maxDesiredSplicePoint,startVertex.point))return;if(PointComparer.GetDirections(startVertex.point,maxDesiredSplicePoint)!=dir)return;let maxDesiredSegment=maxVisibilitySegment;PointComparer.GetDirections(maxDesiredSplicePoint,maxDesiredSegment.end)==dir&&(maxDesiredSegment=LineSegment.mkPP(maxDesiredSegment.start,maxDesiredSplicePoint)),this.ExtendEdgeChain(startVertex,dir,maxDesiredSegment,maxVisibilitySegment,pacList,isOverlapped)}ExtendEdgeChain(startVertex,extendDir,maxDesiredSegment,maxVisibilitySegment,pacList,isOverlapped){if(PointComparer.GetDirections(startVertex.point,maxDesiredSegment.end)!=extendDir)return;let spliceSourceDir=CompassVector.RotateLeft(extendDir),spliceSource=StaticGraphUtility.FindAdjacentVertex(startVertex,spliceSourceDir);if(null==spliceSource&&(spliceSourceDir=CompassVector.OppositeDir(spliceSourceDir),spliceSource=StaticGraphUtility.FindAdjacentVertex(startVertex,spliceSourceDir),null==spliceSource))return;const spliceTargetDir=CompassVector.OppositeDir(spliceSourceDir),t={spliceTarget:null};this.ExtendSpliceWorker(spliceSource,extendDir,spliceTargetDir,maxDesiredSegment,maxVisibilitySegment,isOverlapped,t)&&this.ExtendSpliceWorker(t.spliceTarget,extendDir,spliceSourceDir,maxDesiredSegment,maxVisibilitySegment,isOverlapped,t),this.SpliceGroupBoundaryCrossings(pacList,startVertex,maxDesiredSegment)}SpliceGroupBoundaryCrossings(crossingList,startVertex,maxSegment){if(null==crossingList||0==crossingList.Count())return;crossingList.Reset();let start=maxSegment.start,end=maxSegment.end,dir=PointComparer.GetDirections(start,end);StaticGraphUtility.IsAscending(dir)||(start=maxSegment.end,end=maxSegment.start,dir=CompassVector.OppositeDir(dir));for(let currentVertex=startVertex=TransientGraphUtility.TraverseToFirstVertexAtOrAbove(startVertex,start,CompassVector.OppositeDir(dir));null!=currentVertex;currentVertex=StaticGraphUtility.FindAdjacentVertex(currentVertex,dir)){const isFinalVertex=PointComparer.ComparePP(currentVertex.point,end)>=0;for(;crossingList.CurrentIsBeforeOrAt(currentVertex.point);){const pac=crossingList.Pop();PointComparer.ComparePP(pac.Location,startVertex.point)>0&&PointComparer.ComparePP(pac.Location,end)<=0&&this.SpliceGroupBoundaryCrossing(currentVertex,pac,CompassVector.OppositeDir(dir)),PointComparer.ComparePP(pac.Location,startVertex.point)>=0&&PointComparer.ComparePP(pac.Location,end)<0&&this.SpliceGroupBoundaryCrossing(currentVertex,pac,dir)}if(isFinalVertex)break}}static TraverseToFirstVertexAtOrAbove(startVertex,start,dir){let returnVertex=startVertex;const oppositeDir=CompassVector.OppositeDir(dir);for(;;){const nextVertex=StaticGraphUtility.FindAdjacentVertex(returnVertex,dir);if(null==nextVertex||PointComparer.GetDirections(nextVertex.point,start)==oppositeDir)break;returnVertex=nextVertex}return returnVertex}SpliceGroupBoundaryCrossing(currentVertex,pac,dirToInside){var _a,_b;const crossings=PointAndCrossingsList.ToCrossingArray(pac.Crossings,dirToInside);if(null!=crossings){const outerVertex=null!==(_a=this.VisGraph.FindVertex(pac.Location))&&void 0!==_a?_a:this.AddVertex(pac.Location);this.AddVertex(pac.Location),currentVertex.point.equal(outerVertex.point)||this.FindOrAddEdgeVV(currentVertex,outerVertex);const interiorPoint=crossings[0].GetInteriorVertexPoint(pac.Location),interiorVertex=null!==(_b=this.VisGraph.FindVertex(interiorPoint))&&void 0!==_b?_b:this.AddVertex(interiorPoint);this.AddVertex(interiorPoint),this.FindOrAddEdgeVV(outerVertex,interiorVertex);const edge=this.VisGraph.FindEdgePP(outerVertex.point,interiorVertex.point),crossingsArray=crossings.map((c=>c.Group.InputShape));edge.IsPassable=()=>crossingsArray.some((s=>s.IsTransparent))}}ExtendSpliceWorker(spliceSourcePar,extendDir,spliceTargetDir,maxDesiredSegment,maxVisibilitySegment,isOverlapped,t){let extendVertex=StaticGraphUtility.FindAdjacentVertex(spliceSourcePar,spliceTargetDir);t.spliceTarget=StaticGraphUtility.FindAdjacentVertex(extendVertex,spliceTargetDir);const st={spliceSource:spliceSourcePar};for(;TransientGraphUtility.GetNextSpliceSource(st,spliceTargetDir,extendDir);){const nextExtendPoint=StaticGraphUtility.FindBendPointBetween(extendVertex.point,st.spliceSource.point,CompassVector.OppositeDir(spliceTargetDir));if(TransientGraphUtility.IsPointPastSegmentEnd(maxVisibilitySegment,nextExtendPoint))break;if(t.spliceTarget=TransientGraphUtility.GetSpliceTarget(st,spliceTargetDir,nextExtendPoint),null==t.spliceTarget){if(this.IsSkippableSpliceSourceWithNullSpliceTarget(st.spliceSource,extendDir))continue;if(this.ObstacleTree.SegmentCrossesAnObstacle(st.spliceSource.point,nextExtendPoint))return!1}let nextExtendVertex=this.VisGraph.FindVertex(nextExtendPoint);if(null!=nextExtendVertex){if(null==t.spliceTarget||null!=this.VisGraph.FindEdgePP(extendVertex.point,nextExtendPoint))return null==t.spliceTarget&&this.FindOrAddEdge(extendVertex,nextExtendVertex,isOverlapped?ScanSegment.OverlappedWeight:ScanSegment.NormalWeight),!1}else nextExtendVertex=this.AddVertex(nextExtendPoint);if(this.FindOrAddEdge(extendVertex,nextExtendVertex,isOverlapped?ScanSegment.OverlappedWeight:ScanSegment.NormalWeight),this.FindOrAddEdge(st.spliceSource,nextExtendVertex,isOverlapped?ScanSegment.OverlappedWeight:ScanSegment.NormalWeight),isOverlapped&&(isOverlapped=this.SeeIfSpliceIsStillOverlapped(extendDir,nextExtendVertex)),extendVertex=nextExtendVertex,!(extendDir&PointComparer.GetDirections(nextExtendPoint,maxDesiredSegment.end))){t.spliceTarget=null;break}}return null!=t.spliceTarget}static GetNextSpliceSource(t,spliceTargetDir,extendDir){let nextSpliceSource=StaticGraphUtility.FindAdjacentVertex(t.spliceSource,extendDir);if(null==nextSpliceSource)for(nextSpliceSource=t.spliceSource;;){if(nextSpliceSource=StaticGraphUtility.FindAdjacentVertex(nextSpliceSource,CompassVector.OppositeDir(spliceTargetDir)),null==nextSpliceSource)return!1;const nextSpliceSourceExtend=StaticGraphUtility.FindAdjacentVertex(nextSpliceSource,extendDir);if(null!=nextSpliceSourceExtend){nextSpliceSource=nextSpliceSourceExtend;break}}return t.spliceSource=nextSpliceSource,!0}static GetSpliceTarget(t,spliceTargetDir,nextExtendPoint){const prevDir=PointComparer.GetDirections(t.spliceSource.point,nextExtendPoint);let nextDir=prevDir,spliceTarget=t.spliceSource;for(;nextDir==prevDir&&(t.spliceSource=spliceTarget,spliceTarget=StaticGraphUtility.FindAdjacentVertex(t.spliceSource,spliceTargetDir),null!=spliceTarget);){if(point_Point.closeDistEps(spliceTarget.point,nextExtendPoint)){spliceTarget=StaticGraphUtility.FindAdjacentVertex(spliceTarget,spliceTargetDir);break}nextDir=PointComparer.GetDirections(spliceTarget.point,nextExtendPoint)}return spliceTarget}SeeIfSpliceIsStillOverlapped(extendDir,nextExtendVertex){let edge=this.FindNextEdge(nextExtendVertex,CompassVector.RotateLeft(extendDir)),maybeFreeSpace=null!=edge&&ScanSegment.NormalWeight==edge.Weight;return maybeFreeSpace||(edge=this.FindNextEdge(nextExtendVertex,CompassVector.RotateRight(extendDir)),maybeFreeSpace=null!=edge&&ScanSegment.NormalWeight==edge.Weight),!maybeFreeSpace||this.ObstacleTree.PointIsInsideAnObstaclePD(nextExtendVertex.point,extendDir)}IsSkippableSpliceSourceWithNullSpliceTarget(spliceSource,extendDir){if(TransientGraphUtility.IsSkippableSpliceSourceEdgeWithNullTarget(StaticGraphUtility.FindAdjacentEdge(spliceSource,extendDir)))return!0;const spliceSourceEdge=StaticGraphUtility.FindAdjacentEdge(spliceSource,CompassVector.OppositeDir(extendDir));return TransientGraphUtility.IsSkippableSpliceSourceEdgeWithNullTarget(spliceSourceEdge)||TransientGraphUtility.IsReflectionEdge(spliceSourceEdge)}static IsSkippableSpliceSourceEdgeWithNullTarget(spliceSourceEdge){return null!=spliceSourceEdge&&null!=spliceSourceEdge.IsPassable&&closeDistEps(spliceSourceEdge.Length,GroupBoundaryCrossing.BoundaryWidth)}static IsReflectionEdge(edge){return null!=edge&&edge.Weight==ScanSegment.ReflectionWeight}static IsPointPastSegmentEnd(maxSegment,point){return PointComparer.GetDirections(maxSegment.start,maxSegment.end)==PointComparer.GetDirections(maxSegment.end,point)}toString(){return dist.Qf.Format("{0} {1}",this.AddedVertices.length,this.edgesToRestore.length)}}class PortManager{constructor(graphGenerator){this.obstaclePortMap=new Map,this.freePointMap=new PointMap,this.freePointLocationsUsedByRouteEdges=new PointSet,this.RouteToCenterOfObstacles=!1,this.obstaclePortsInGraph=new Array,this.freePointsInGraph=new Set,this.activeAncestors=new Array,this.TransUtil=new TransientGraphUtility(graphGenerator),this.graphGenerator=graphGenerator}get LimitPortVisibilitySpliceToEndpointBoundingBox(){return this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox}set LimitPortVisibilitySpliceToEndpointBoundingBox(value){this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox=value}get VisGraph(){return this.graphGenerator.VisibilityGraph}get HScanSegments(){return this.graphGenerator.HorizontalScanSegments}get VScanSegments(){return this.graphGenerator.VerticalScanSegments}get ObstacleTree(){return this.graphGenerator.ObstacleTree}get AncestorSets(){return this.ObstacleTree.AncestorSets}Clear(){this.TransUtil.RemoveFromGraph(),this.obstaclePortMap.clear()}CreateObstaclePorts(obstacle){for(const port of obstacle.Ports)this.CreateObstaclePort(obstacle,port)}CreateObstaclePort(obstacle,port){if(null==port.Curve)return null;const roundedLocation=GeomConstants.RoundPoint(port.Location);if(PointLocation.Outside==Curve.PointRelativeToCurveLocation(roundedLocation,obstacle.InputShape.BoundaryCurve))return null;if(obstacle.InputShape.BoundaryCurve!=port.Curve&&PointLocation.Outside==Curve.PointRelativeToCurveLocation(roundedLocation,port.Curve))return null;const oport=new ObstaclePort(port,obstacle);return this.obstaclePortMap.set(port,oport),oport}FindVertices(port){const vertices=new Array,oport=this.obstaclePortMap.get(port);if(oport)if(this.RouteToCenterOfObstacles)vertices.push(oport.CenterVertex);else for(const entrance of oport.PortEntrances){const vertex=this.VisGraph.FindVertex(entrance.UnpaddedBorderIntersect);null!=vertex&&vertices.push(vertex)}else vertices.push(this.VisGraph.FindVertex(GeomConstants.RoundPoint(port.Location)));return vertices}RemoveObstaclePorts(obstacle){for(const port of obstacle.Ports)this.RemoveObstaclePort(port)}RemoveObstaclePort(port){this.obstaclePortMap.delete(port)}AddControlPointsToGraph(edge,shapeToObstacleMap){this.GetPortSpliceLimitRectangle(edge),this.activeAncestors=[];const s={oport:null},t={oport:null},ssAncs=this.FindAncestorsAndObstaclePort(edge.sourcePort,s),ttAncs=this.FindAncestorsAndObstaclePort(edge.targetPort,t);if(this.AncestorSets.size>0&&null!=s.oport&&null!=t.oport){const ttAncsOnly=substractSets(ttAncs,ssAncs),ssAncsOnly=substractSets(ssAncs,ttAncs);this.ActivateAncestors(ssAncsOnly,ttAncsOnly,shapeToObstacleMap)}this.AddPortToGraph(edge.sourcePort,s.oport),this.AddPortToGraph(edge.targetPort,t.oport)}ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(oobWaypoint,port){if(null==oobWaypoint||!oobWaypoint.IsOutOfBounds)return;const endpointVertices=this.FindVertices(port);let dirFromGraph=oobWaypoint.OutOfBoundsDirectionFromGraph&(Direction.North|Direction.South);this.ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint,dirFromGraph,endpointVertices),dirFromGraph=oobWaypoint.OutOfBoundsDirectionFromGraph&(Direction.East|Direction.West),this.ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint,dirFromGraph,endpointVertices)}ConnectToGraphAtPointsCollinearWithVertices(oobWaypoint,dirFromGraph,endpointVertices){if(Direction.None==dirFromGraph)return;const dirToGraph=CompassVector.OppositeDir(dirFromGraph);for(const vertex of endpointVertices){const graphBorderLocation=this.InBoundsGraphBoxIntersect(vertex.point,dirFromGraph),graphBorderVertex=this.VisGraph.FindVertex(graphBorderLocation);null!=graphBorderVertex&&this.TransUtil.ConnectVertexToTargetVertex(oobWaypoint.Vertex,graphBorderVertex,dirToGraph,ScanSegment.NormalWeight)}}SetAllAncestorsActive(edgeGeom,shapeToObstacleMap){if(0==this.AncestorSets.size)return!1;this.ObstacleTree.AdjustSpatialAncestors(),this.ClearActiveAncestors();const ssAncs=this.FindAncestorsAndObstaclePort(edgeGeom.sourcePort,{oport:null}),ttAncs=this.FindAncestorsAndObstaclePort(edgeGeom.targetPort,{oport:null});return this.AncestorSets.size>0&&null!=ssAncs&&null!=ttAncs&&(this.ActivateAncestors(ssAncs,ttAncs,shapeToObstacleMap),!0)}SetAllGroupsActive(){this.ClearActiveAncestors();for(const group of this.ObstacleTree.GetAllGroups())group.IsTransparentAncestor=!0,this.activeAncestors.push(group)}FindAncestorsAndObstaclePort(port,t){return t.oport=this.FindObstaclePort(port),0==this.AncestorSets.size?null:null!=t.oport?this.AncestorSets.get(t.oport.Obstacle.InputShape):new Set(Array.from(this.ObstacleTree.Root.AllHitItems(Rectangle.mkPP(port.Location,port.Location),(shape=>shape.IsGroup))).map((obs=>obs.InputShape)))}ActivateAncestors(ssAncsToUse,ttAncsToUse,shapeToObstacleMap){for(const shape of uniteSets(ssAncsToUse,ttAncsToUse)){const group=shapeToObstacleMap.get(shape);group.IsTransparentAncestor=!0,this.activeAncestors.push(group)}}ClearActiveAncestors(){for(const group of this.activeAncestors)group.IsTransparentAncestor=!1;this.activeAncestors=[]}RemoveControlPointsFromGraph(){this.ClearActiveAncestors(),this.RemoveObstaclePortsFromGraph(),this.RemoveFreePointsFromGraph(),this.TransUtil.RemoveFromGraph(),this.portSpliceLimitRectangle=Rectangle.mkEmpty()}RemoveObstaclePortsFromGraph(){for(const oport of this.obstaclePortsInGraph)oport.RemoveFromGraph();this.obstaclePortsInGraph=[]}RemoveFreePointsFromGraph(){for(const freePoint of this.freePointsInGraph)freePoint.RemoveFromGraph();this.freePointsInGraph.clear()}RemoveStaleFreePoints(){if(this.freePointMap.size>this.freePointLocationsUsedByRouteEdges.size){const staleFreePairs=Array.from(this.freePointMap).filter((p=>!this.freePointLocationsUsedByRouteEdges.has(p[0])));for(const staleFreePair of staleFreePairs)this.freePointMap.deleteP(staleFreePair[0])}}ClearVisibility(){this.freePointMap.clear();for(const oport of this.obstaclePortMap.values())oport.ClearVisibility()}BeginRouteEdges(){this.RemoveControlPointsFromGraph(),this.freePointLocationsUsedByRouteEdges.clear()}EndRouteEdges(){this.RemoveStaleFreePoints()}FindObstaclePort(port){let oport=this.obstaclePortMap.get(port);if(oport){const t={removedPorts:null,addedPorts:null};if(oport.Obstacle.GetPortChanges(t)){for(const newPort of t.addedPorts)this.CreateObstaclePort(oport.Obstacle,newPort);for(const oldPort of t.removedPorts)this.RemoveObstaclePort(oldPort);oport=this.obstaclePortMap.get(port)}}return oport}AddPortToGraph(port,oport){null==oport?this.AddFreePointToGraph(port.Location):this.AddObstaclePortToGraph(oport)}AddObstaclePortToGraph(oport){if(!oport.LocationHasChanged||(this.RemoveObstaclePort(oport.Port),null!=(oport=this.CreateObstaclePort(oport.Obstacle,oport.Port)))){oport.AddToGraph(this.TransUtil,this.RouteToCenterOfObstacles),this.obstaclePortsInGraph.push(oport),this.CreateObstaclePortEntrancesIfNeeded(oport);for(const entrance of oport.PortEntrances)this.AddObstaclePortEntranceToGraph(entrance)}}CreateObstaclePortEntrancesIfNeeded(oport){oport.PortEntrances.length>0||this.CreateObstaclePortEntrancesFromPoints(oport)}GetPortVisibilityIntersection(edgeGeometry){const sourceOport=this.FindObstaclePort(edgeGeometry.sourcePort),targetOport=this.FindObstaclePort(edgeGeometry.targetPort);if(null==sourceOport||null==targetOport)return null;if(sourceOport.Obstacle.IsInConvexHull||targetOport.Obstacle.IsInConvexHull)return null;if(this.CreateObstaclePortEntrancesIfNeeded(sourceOport),this.CreateObstaclePortEntrancesIfNeeded(targetOport),!sourceOport.VisibilityRectangle.intersects(targetOport.VisibilityRectangle))return null;for(const sourceEntrance of sourceOport.PortEntrances)if(sourceEntrance.WantVisibilityIntersection)for(const targetEntrance of targetOport.PortEntrances){if(!targetEntrance.WantVisibilityIntersection)continue;const points=sourceEntrance.IsVertical==targetEntrance.IsVertical?PortManager.GetPathPointsFromOverlappingCollinearVisibility(sourceEntrance,targetEntrance):PortManager.GetPathPointsFromIntersectingVisibility(sourceEntrance,targetEntrance);if(null!=points)return points}return null}static GetPathPointsFromOverlappingCollinearVisibility(sourceEntrance,targetEntrance){return StaticGraphUtility.IntervalsAreSame(sourceEntrance.MaxVisibilitySegment.start,sourceEntrance.MaxVisibilitySegment.end,targetEntrance.MaxVisibilitySegment.end,targetEntrance.MaxVisibilitySegment.start)?sourceEntrance.HasGroupCrossings||targetEntrance.HasGroupCrossings||point_Point.closeDistEps(sourceEntrance.UnpaddedBorderIntersect,targetEntrance.UnpaddedBorderIntersect)?null:[sourceEntrance.UnpaddedBorderIntersect,targetEntrance.UnpaddedBorderIntersect]:null}static GetPathPointsFromIntersectingVisibility(sourceEntrance,targetEntrance){const intersect=StaticGraphUtility.SegmentsIntersectLL(sourceEntrance.MaxVisibilitySegment,targetEntrance.MaxVisibilitySegment);return intersect?sourceEntrance.HasGroupCrossingBeforePoint(intersect)||targetEntrance.HasGroupCrossingBeforePoint(intersect)?null:[sourceEntrance.UnpaddedBorderIntersect,intersect,targetEntrance.UnpaddedBorderIntersect]:null}CreateObstaclePortEntrancesFromPoints(oport){const graphBox=this.graphGenerator.ObstacleTree.GraphBox,curveBox=Rectangle.mkPP(GeomConstants.RoundPoint(oport.PortCurve.boundingBox.leftBottom),GeomConstants.RoundPoint(oport.PortCurve.boundingBox.rightTop)),location=GeomConstants.RoundPoint(oport.PortLocation);let found=!1;const t={xx0:null,xx1:null};if(!PointComparer.Equal(location.y,curveBox.top)&&!PointComparer.Equal(location.y,curveBox.bottom)){found=!0;const hSeg=new LineSegment(graphBox.left,location.y,graphBox.right,location.y);this.GetBorderIntersections(location,hSeg,oport.PortCurve,t);let wBorderIntersect=new point_Point(Math.min(t.xx0.x,t.xx1.x),location.y);wBorderIntersect.x<curveBox.left&&(wBorderIntersect=new point_Point(curveBox.left,wBorderIntersect.y));let eBorderIntersect=new point_Point(Math.max(t.xx0.x,t.xx1.x),location.y);eBorderIntersect.x>curveBox.right&&(eBorderIntersect=new point_Point(curveBox.right,eBorderIntersect.y)),this.CreatePortEntrancesAtBorderIntersections(curveBox,oport,location,wBorderIntersect,eBorderIntersect)}if(!PointComparer.Equal(location.x,curveBox.left)&&!PointComparer.Equal(location.x,curveBox.right)){found=!0;const vSeg=new LineSegment(location.x,graphBox.bottom,location.x,graphBox.top);this.GetBorderIntersections(location,vSeg,oport.PortCurve,t);let sBorderIntersect=new point_Point(location.x,Math.min(t.xx0.y,t.xx1.y));sBorderIntersect.y<graphBox.bottom&&(sBorderIntersect=new point_Point(sBorderIntersect.x,graphBox.bottom));let nBorderIntersect=new point_Point(location.x,Math.max(t.xx0.y,t.xx1.y));nBorderIntersect.y>graphBox.top&&(nBorderIntersect=new point_Point(nBorderIntersect.x,graphBox.top)),this.CreatePortEntrancesAtBorderIntersections(curveBox,oport,location,sBorderIntersect,nBorderIntersect)}found||this.CreateEntrancesForCornerPort(curveBox,oport,location)}GetBorderIntersections(location,lineSeg,curve,t){const xxs=Curve.getAllIntersections(lineSeg,curve,!0);t.xx0=GeomConstants.RoundPoint(xxs[0].x),t.xx1=GeomConstants.RoundPoint(xxs[1].x)}CreatePortEntrancesAtBorderIntersections(curveBox,oport,location,unpaddedBorderIntersect0,unpaddedBorderIntersect1){const dir=PointComparer.GetDirections(unpaddedBorderIntersect0,unpaddedBorderIntersect1);PointComparer.EqualPP(unpaddedBorderIntersect0,location)||this.CreatePortEntrance(curveBox,oport,unpaddedBorderIntersect1,dir),PointComparer.EqualPP(unpaddedBorderIntersect1,location)||this.CreatePortEntrance(curveBox,oport,unpaddedBorderIntersect0,CompassVector.OppositeDir(dir))}static GetDerivative(oport,borderPoint){const param=oport.PortCurve.closestParameter(borderPoint);let deriv=oport.PortCurve.derivative(param);const parMid=(oport.PortCurve.parStart+oport.PortCurve.parEnd)/2;return InteractiveObstacleCalculator.CurveIsClockwise(oport.PortCurve,oport.PortCurve.value(parMid))||(deriv=deriv.mul(-1)),deriv}CreatePortEntrance(curveBox,oport,unpaddedBorderIntersect,outDir){oport.CreatePortEntrance(unpaddedBorderIntersect,outDir,this.ObstacleTree);const scanDir=ScanDirection.GetInstance(outDir);let axisDistanceBetweenIntersections=StaticGraphUtility.GetRectangleBound(curveBox,outDir)-scanDir.Coord(unpaddedBorderIntersect);if(axisDistanceBetweenIntersections<0&&(axisDistanceBetweenIntersections=-axisDistanceBetweenIntersections),axisDistanceBetweenIntersections>GeomConstants.intersectionEpsilon){const perpDirs=CompassVector.VectorDirection(PortManager.GetDerivative(oport,unpaddedBorderIntersect));let perpDir;CompassVector.OppositeDir(outDir),Direction.None!=(outDir&perpDirs)&&(perpDir=CompassVector.OppositeDir(perpDir)),oport.CreatePortEntrance(unpaddedBorderIntersect,perpDir,this.ObstacleTree)}}CreateEntrancesForCornerPort(curveBox,oport,location){let outDir=Direction.North;PointComparer.EqualPP(location,curveBox.leftBottom)?outDir=Direction.South:PointComparer.EqualPP(location,curveBox.leftTop)?outDir=Direction.West:PointComparer.EqualPP(location,curveBox.rightTop)?outDir=Direction.North:PointComparer.EqualPP(location,curveBox.rightBottom)&&(outDir=Direction.East),oport.CreatePortEntrance(location,outDir,this.ObstacleTree),oport.CreatePortEntrance(location,CompassVector.RotateRight(outDir),this.ObstacleTree)}AddObstaclePortEntranceToGraph(entrance){const borderVertex=this.VisGraph.FindVertex(entrance.VisibilityBorderIntersect);if(borderVertex)return void entrance.ExtendEdgeChain(this.TransUtil,borderVertex,borderVertex,this.portSpliceLimitRectangle,this.RouteToCenterOfObstacles);const t={targetVertex:null},weight=entrance.IsOverlapped?ScanSegment.OverlappedWeight:ScanSegment.NormalWeight;null!=this.FindorCreateNearestPerpEdgePPDNT(entrance.MaxVisibilitySegment.end,entrance.VisibilityBorderIntersect,entrance.OutwardDirection,weight,t)&&entrance.AddToAdjacentVertex(this.TransUtil,t.targetVertex,this.portSpliceLimitRectangle,this.RouteToCenterOfObstacles)}InBoundsGraphBoxIntersect(point,dir){return StaticGraphUtility.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.GraphBox,point,dir)}FindorCreateNearestPerpEdgePPDN(first,second,dir,weight){return this.FindorCreateNearestPerpEdgePPDNT(first,second,dir,weight,{targetVertex:null})}FindorCreateNearestPerpEdgePPDNT(first,second,dir,weight,t){const couple=StaticGraphUtility.SortAscending(first,second),low=couple[0],high=couple[1],perpendicularScanSegments=StaticGraphUtility.IsVerticalD(dir)?this.HScanSegments:this.VScanSegments,nearestPerpSeg=StaticGraphUtility.IsAscending(dir)?perpendicularScanSegments.FindLowestIntersector(low,high):perpendicularScanSegments.FindHighestIntersector(low,high);if(null==nearestPerpSeg)return t.targetVertex=null,null;const edgeIntersect=StaticGraphUtility.SegmentIntersectionSP(nearestPerpSeg,low);return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(StaticGraphUtility.IsAscending(dir)?low:high,nearestPerpSeg,edgeIntersect,weight,t)}FindOrCreateNearestPerpEdgeFromNearestPerpSegment(pointLocation,scanSeg,edgeIntersect,weight,t){var _a;const tt={segsegVertex:this.VisGraph.FindVertex(edgeIntersect),targetVertex:null};if(null==tt.segsegVertex){const edge=this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(pointLocation,edgeIntersect,scanSeg,weight,tt);if(null!=edge)return edge}else if(PointComparer.EqualPP(pointLocation,edgeIntersect))return t.targetVertex=tt.segsegVertex,this.TransUtil.FindNextEdge(t.targetVertex,CompassVector.OppositeDir(scanSeg.ScanDirection.Dir));const dirTowardLocation=PointComparer.GetDirections(edgeIntersect,pointLocation);let perpDir=PointComparer.GetDirections(tt.segsegVertex.point,pointLocation);if(dirTowardLocation==perpDir){const ot={bracketTarget:null,bracketSource:null};return TransientGraphUtility.FindBracketingVertices(tt.segsegVertex,pointLocation,dirTowardLocation,ot),null!==(_a=this.TransUtil.FindNextEdge(ot.bracketSource,CompassVector.RotateLeft(dirTowardLocation)))&&void 0!==_a?_a:this.TransUtil.FindNextEdge(ot.bracketSource,CompassVector.RotateRight(dirTowardLocation))}perpDir&=~dirTowardLocation;const perpendicularEdge=this.TransUtil.FindNearestPerpendicularOrContainingEdge(tt.segsegVertex,perpDir,pointLocation);return null==perpendicularEdge?(t.targetVertex=this.TransUtil.AddVertex(edgeIntersect),this.TransUtil.FindOrAddEdge(t.targetVertex,scanSeg.HighestVisibilityVertex,scanSeg.Weight)):(tt.segsegVertex=StaticGraphUtility.GetEdgeEnd(perpendicularEdge,CompassVector.OppositeDir(perpDir)),edgeIntersect=StaticGraphUtility.SegmentIntersectionPPP(pointLocation,edgeIntersect,tt.segsegVertex.point),PointComparer.EqualPP(tt.segsegVertex.point,edgeIntersect)?(t.targetVertex=tt.segsegVertex,this.TransUtil.FindNextEdge(tt.segsegVertex,perpDir)):(t.targetVertex=this.TransUtil.FindOrAddVertex(edgeIntersect),this.TransUtil.FindOrAddEdge(tt.segsegVertex,t.targetVertex,weight)))}FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(pointLocation,edgeIntersect,scanSeg,weight,t){const intSegBefore=(scanSeg.IsVertical?this.HScanSegments:this.VScanSegments).FindHighestIntersector(scanSeg.Start,edgeIntersect);if(null==intSegBefore)return t.segsegVertex=null,t.targetVertex=this.TransUtil.AddVertex(edgeIntersect),this.TransUtil.FindOrAddEdge(t.targetVertex,scanSeg.LowestVisibilityVertex,scanSeg.Weight);const segsegIntersect=StaticGraphUtility.SegmentsIntersection(scanSeg,intSegBefore);if(t.segsegVertex=this.VisGraph.FindVertex(segsegIntersect),!t.segsegVertex){t.segsegVertex=this.TransUtil.AddVertex(segsegIntersect);const newEdge=this.AddEdgeToClosestSegmentEnd(scanSeg,t.segsegVertex,scanSeg.Weight);if(this.AddEdgeToClosestSegmentEnd(intSegBefore,t.segsegVertex,intSegBefore.Weight),PointComparer.EqualPP(t.segsegVertex.point,edgeIntersect))return t.targetVertex=t.segsegVertex,newEdge}return PointComparer.EqualPP(pointLocation,edgeIntersect)?(t.targetVertex=this.TransUtil.FindOrAddVertex(edgeIntersect),this.TransUtil.FindOrAddEdge(t.segsegVertex,t.targetVertex,weight)):(t.targetVertex=null,null)}AddEdgeToClosestSegmentEnd(scanSeg,segsegVertex,weight){return PointComparer.IsPureLower(scanSeg.HighestVisibilityVertex.point,segsegVertex.point)?this.TransUtil.FindOrAddEdge(scanSeg.HighestVisibilityVertex,segsegVertex,weight):PointComparer.IsPureLower(segsegVertex.point,scanSeg.LowestVisibilityVertex.point)?this.TransUtil.FindOrAddEdge(segsegVertex,scanSeg.LowestVisibilityVertex,weight):this.TransUtil.FindOrAddEdgeVV(scanSeg.LowestVisibilityVertex,segsegVertex)}GetPortSpliceLimitRectangle(edgeGeom){this.LimitPortVisibilitySpliceToEndpointBoundingBox?(this.portSpliceLimitRectangle=this.GetPortRectangle(edgeGeom.sourcePort),this.portSpliceLimitRectangle.addRecSelf(this.GetPortRectangle(edgeGeom.targetPort))):this.portSpliceLimitRectangle=this.graphGenerator.ObstacleTree.GraphBox}GetPortRectangle(port){const oport=this.obstaclePortMap.get(port);return oport?oport.Obstacle.VisibilityBoundingBox.clone():Rectangle.mkOnPoints([GeomConstants.RoundPoint(port.Location)])}AddToLimitRectangle(location){this.graphGenerator.IsInBoundsP(location)&&this.portSpliceLimitRectangle.add(location)}FindOrCreateFreePoint(location){let freePoint=this.freePointMap.get(location);return freePoint?freePoint.GetVertex(this.TransUtil,location):(freePoint=new FreePoint(this.TransUtil,location),this.freePointMap.set(location,freePoint)),this.freePointsInGraph.add(freePoint),this.freePointLocationsUsedByRouteEdges.add(location),freePoint}AddFreePointToGraph(location){location=GeomConstants.RoundPoint(location);const vertex=this.VisGraph.FindVertex(location),freePoint=this.FindOrCreateFreePoint(location);if(null!=vertex)return freePoint;if(!this.graphGenerator.IsInBoundsP(location))return this.CreateOutOfBoundsFreePoint(freePoint),freePoint;let edge=null;freePoint.IsOverlapped=this.ObstacleTree.PointIsInsideAnObstacle(freePoint.Point,this.HScanSegments.ScanDirection),this.VScanSegments.FindSegmentContainingPoint(location,!0);let edgeDir=Direction.South;if(null!=edge)edgeDir=StaticGraphUtility.EdgeDirectionVE(edge),this.ConnectFreePointToLateralEdge(freePoint,CompassVector.RotateLeft(edgeDir)),this.ConnectFreePointToLateralEdge(freePoint,CompassVector.RotateRight(edgeDir));else for(let ii=0;ii<4;ii++)this.ConnectFreePointToLateralEdge(freePoint,edgeDir),edgeDir=CompassVector.RotateLeft(edgeDir);return freePoint}CreateOutOfBoundsFreePoint(freePoint){const oobLocation=freePoint.Point,inboundsLocation=this.graphGenerator.MakeInBoundsLocation(oobLocation),dirFromGraph=PointComparer.GetDirections(inboundsLocation,oobLocation);if(freePoint.OutOfBoundsDirectionFromGraph=dirFromGraph,!PointComparer.IsPureDirectionD(dirFromGraph))return void freePoint.AddOobEdgesFromGraphCorner(this.TransUtil,inboundsLocation);let inboundsVertex=this.VisGraph.FindVertex(inboundsLocation);const dirToGraph=CompassVector.OppositeDir(dirFromGraph);if(null!=inboundsVertex)freePoint.AddToAdjacentVertex(this.TransUtil,inboundsVertex,dirToGraph,this.portSpliceLimitRectangle);else{const edge=this.FindorCreateNearestPerpEdgePPDN(oobLocation,inboundsLocation,dirFromGraph,ScanSegment.NormalWeight);null!=edge&&(inboundsVertex=freePoint.AddEdgeToAdjacentEdge(this.TransUtil,edge,dirToGraph,this.portSpliceLimitRectangle))}const inboundsLeftVertex=StaticGraphUtility.FindAdjacentVertex(inboundsVertex,CompassVector.RotateLeft(dirToGraph));null!=inboundsLeftVertex&&this.TransUtil.ConnectVertexToTargetVertex(freePoint.Vertex,inboundsLeftVertex,dirToGraph,ScanSegment.NormalWeight);const inboundsRightVertex=StaticGraphUtility.FindAdjacentVertex(inboundsVertex,CompassVector.RotateRight(dirToGraph));null!=inboundsRightVertex&&this.TransUtil.ConnectVertexToTargetVertex(freePoint.Vertex,inboundsRightVertex,dirToGraph,ScanSegment.NormalWeight)}ConnectFreePointToLateralEdge(freePoint,lateralDir){const end=freePoint.IsOverlapped?this.InBoundsGraphBoxIntersect(freePoint.Point,lateralDir):freePoint.MaxVisibilityInDirectionForNonOverlappedFreePoint(lateralDir,this.TransUtil),lateralEdge=this.FindorCreateNearestPerpEdgePPDN(end,freePoint.Point,lateralDir,freePoint.InitialWeight);null!=lateralEdge&&freePoint.AddEdgeToAdjacentEdge(this.TransUtil,lateralEdge,lateralDir,this.portSpliceLimitRectangle)}}class RectilinearEdgeRouter extends Algorithm{constructor(obstacles,padding,cornerFitRadius,useSparseVisibilityGraph,useObstacleRectangles){super(null),this.Padding=0,this.CornerFitRadius=0,this.BendPenaltyAsAPercentageOfDistance=0,this.UseObstacleRectangles=!1,this.ShapeToObstacleMap=new Map,this.EdgesToRoute=new Array,this.removeStaircases=!0,this.selfEdges=new Array,this.Padding=padding,this.CornerFitRadius=cornerFitRadius,this.BendPenaltyAsAPercentageOfDistance=SsstRectilinearPath.DefaultBendPenaltyAsAPercentageOfDistance,this.GraphGenerator=new SparseVisibilityGraphGenerator,this.UseObstacleRectangles=useObstacleRectangles,this.PortManager=new PortManager(this.GraphGenerator),this.AddShapes(obstacles)}get RouteToCenterOfObstacles(){return this.PortManager.RouteToCenterOfObstacles}set RouteToCenterOfObstacles(value){this.PortManager.RouteToCenterOfObstacles=value}get LimitPortVisibilitySpliceToEndpointBoundingBox(){return this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox}set LimitPortVisibilitySpliceToEndpointBoundingBox(value){this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox=value}AddEdgeGeometryToRoute(edgeGeometry){point_Point.closeDistEps(GeomConstants.RoundPoint(edgeGeometry.sourcePort.Location),GeomConstants.RoundPoint(edgeGeometry.targetPort.Location))?this.selfEdges.push(edgeGeometry):this.EdgesToRoute.push(edgeGeometry)}get EdgeGeometriesToRoute(){return this.EdgesToRoute}RemoveAllEdgeGeometriesToRoute(){this.EdgesToRoute=[]}get UseSparseVisibilityGraph(){return this.GraphGenerator instanceof SparseVisibilityGraphGenerator}get Obstacles(){return Array.from(this.ShapeToObstacleMap.values()).map((obs=>obs.InputShape))}get PaddedObstacles(){return Array.from(this.ShapeToObstacleMap.values()).map((obs=>obs.PaddedPolyline))}AddObstacles(obstacles){this.AddShapes(obstacles),this.RebuildTreeAndGraph()}AddShapes(obstacles){for(const shape of obstacles)this.AddObstacleWithoutRebuild(shape)}AddObstacle(shape){this.AddObstacleWithoutRebuild(shape),this.RebuildTreeAndGraph()}UpdateObstacles(obstacles){for(const shape of obstacles)this.UpdateObstacleWithoutRebuild(shape);this.RebuildTreeAndGraph()}UpdateObstacle(obstacle){this.UpdateObstacleWithoutRebuild(obstacle),this.RebuildTreeAndGraph()}RemoveObstacles(obstacles){for(const shape of obstacles)this.RemoveObstacleWithoutRebuild(shape);this.RebuildTreeAndGraph()}RemoveObstacle(obstacle){this.RemoveObstacleWithoutRebuild(obstacle),this.RebuildTreeAndGraph()}AddObstacleWithoutRebuild(shape){if(null==shape.BoundaryCurve)throw new Error("Shape must have a BoundaryCurve");this.CreatePaddedObstacle(shape)}UpdateObstacleWithoutRebuild(shape){if(null==shape.BoundaryCurve)throw new Error("Shape must have a BoundaryCurve");this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get(shape)),this.CreatePaddedObstacle(shape)}CreatePaddedObstacle(shape){const obstacle=new Obstacle(shape,this.UseObstacleRectangles,this.Padding);this.ShapeToObstacleMap.set(shape,obstacle),this.PortManager.CreateObstaclePorts(obstacle)}RemoveObstacleWithoutRebuild(shape){const obstacle=this.ShapeToObstacleMap.get(shape);this.ShapeToObstacleMap.delete(shape),this.PortManager.RemoveObstaclePorts(obstacle)}RemoveAllObstacles(){this.InternalClear(!1)}RebuildTreeAndGraph(){const hadTree=null!=this.ObsTree.Root,hadVg=null!=this.GraphGenerator.VisibilityGraph;this.InternalClear(!0),hadTree&&this.GenerateObstacleTree(),hadVg&&this.GenerateVisibilityGraph()}get VisibilityGraph(){return this.GenerateVisibilityGraph(),this.GraphGenerator.VisibilityGraph}Clear(){this.InternalClear(!1)}static constructorEmpty(){return RectilinearEdgeRouter.constructorC(null)}static constructorC(cancelToket){return new RectilinearEdgeRouter([],RectilinearEdgeRouter.DefaultPadding,RectilinearEdgeRouter.DefaultCornerFitRadius,!1,!1)}static constructorI(Obstacle){return new RectilinearEdgeRouter(Obstacle,RectilinearEdgeRouter.DefaultPadding,RectilinearEdgeRouter.DefaultCornerFitRadius,!1,!1)}static constructorINNB(obstacles,padding,cornerFitRadius,useSparseVisibilityGraph){return new RectilinearEdgeRouter(obstacles,padding,cornerFitRadius,useSparseVisibilityGraph,!1)}static constructorGNANB(graph,geomEdges,padding,cornerFitRadius,useSparseVisibilityGraph){return this.constructorGNANBB(graph,geomEdges,padding,cornerFitRadius,useSparseVisibilityGraph,!1)}static constructorGNANBB(graph,geomEdges,padding,cornerFitRadius,useSparseVisibilityGraph,useObstacleRectangles){const ret=new RectilinearEdgeRouter(ShapeCreator.GetShapes(graph),padding,cornerFitRadius,useSparseVisibilityGraph,useObstacleRectangles);if(null==geomEdges)for(const edge of graph.edges())ret.AddEdgeGeometryToRoute(edge);else for(const edge of geomEdges)ret.AddEdgeGeometryToRoute(edge);return ret}run(){this.GenerateVisibilityGraph(),this.GeneratePaths()}GeneratePaths(){const edgePaths=this.EdgesToRoute.map((eg=>new Path(eg)));this.FillEdgePathsWithShortestPaths(edgePaths),this.NudgePaths(edgePaths),this.RouteSelfEdges(),this.FinaliseEdgeGeometries()}RouteSelfEdges(){for(const edge of this.selfEdges){const t={smoothedPolyline:null};edge.curve=GeomEdge.RouteSelfEdge(edge.sourcePort.Curve,Math.max(this.Padding,2*edge.GetMaxArrowheadLength()),t)}}FillEdgePathsWithShortestPaths(edgePaths){this.PortManager.BeginRouteEdges();const shortestPathRouter=new MsmtRectilinearPath(this.BendPenaltyAsAPercentageOfDistance);for(const edgePath of edgePaths)this.AddControlPointsAndGeneratePath(shortestPathRouter,edgePath);this.PortManager.EndRouteEdges()}AddControlPointsAndGeneratePath(shortestPathRouter,edgePath){const intersectPoints=this.PortManager.GetPortVisibilityIntersection(edgePath.GeomEdge);null==intersectPoints?this.SpliceVisibilityAndGeneratePath(shortestPathRouter,edgePath):this.GeneratePathThroughVisibilityIntersection(edgePath,intersectPoints)}GeneratePathThroughVisibilityIntersection(edgePath,intersectPoints){edgePath.PathPoints=intersectPoints}SpliceVisibilityAndGeneratePath(shortestPathRouter,edgePath){this.PortManager.AddControlPointsToGraph(edgePath.GeomEdge,this.ShapeToObstacleMap),this.GeneratePath(shortestPathRouter,edgePath,!1)||this.RetryPathsWithAdditionalGroupsEnabled(shortestPathRouter,edgePath),this.PortManager.RemoveControlPointsFromGraph()}GeneratePath(shortestPathRouter,edgePath,lastChance){const sourceVertices=this.PortManager.FindVertices(edgePath.GeomEdge.sourcePort),targetVertices=this.PortManager.FindVertices(edgePath.GeomEdge.targetPort);return RectilinearEdgeRouter.GetSingleStagePath(edgePath,shortestPathRouter,sourceVertices,targetVertices,lastChance)}static GetSingleStagePath(edgePath,shortestPathRouter,sourceVertices,targetVertices,lastChance){return edgePath.PathPoints=shortestPathRouter.GetPath(sourceVertices,targetVertices),lastChance&&RectilinearEdgeRouter.EnsureNonNullPath(edgePath),null!=edgePath.PathPoints&&edgePath.PathPoints.length>0}static EnsureNonNullPath(edgePath){null==edgePath.PathPoints&&(PointComparer.IsPureDirection(edgePath.GeomEdge.sourcePort.Location,edgePath.GeomEdge.targetPort.Location)?edgePath.PathPoints=[edgePath.GeomEdge.sourcePort.Location,edgePath.GeomEdge.targetPort.Location]:edgePath.PathPoints=[edgePath.GeomEdge.sourcePort.Location,new point_Point(edgePath.GeomEdge.sourcePort.Location.x,edgePath.GeomEdge.targetPort.Location.y),edgePath.GeomEdge.targetPort.Location])}RetryPathsWithAdditionalGroupsEnabled(shortestPathRouter,edgePath){this.PortManager.SetAllAncestorsActive(edgePath.GeomEdge,this.ShapeToObstacleMap)&&this.GeneratePath(shortestPathRouter,edgePath,!1)||(this.PortManager.SetAllGroupsActive(),this.GeneratePath(shortestPathRouter,edgePath,!0))}NudgePaths(edgePaths){const ancestorSets=this.ObsTree.SpatialAncestorsAdjusted?SplineRouter.GetAncestorSetsMap(this.Obstacles):this.AncestorsSets;Nudger.NudgePaths(edgePaths,this.CornerFitRadius,this.PaddedObstacles,ancestorSets,this.RemoveStaircases)}get RemoveStaircases(){return this.removeStaircases}set RemoveStaircases(value){this.removeStaircases=value}FinaliseEdgeGeometries(){for(const edgeGeom of this.EdgesToRoute.concat(this.selfEdges)){if(null==edgeGeom.curve)continue;edgeGeom.curve instanceof Polyline&&(edgeGeom.curve=RectilinearEdgeRouter.FitArcsIntoCorners(this.CornerFitRadius,Array.from(edgeGeom.curve))),RectilinearEdgeRouter.CalculateArrowheads(edgeGeom)}}CreateVisibilityGraph(){this.GraphGenerator.Clear(),this.InitObstacleTree(),this.GraphGenerator.GenerateVisibilityGraph()}static CalculateArrowheads(edgeGeom){Arrowhead.trimSplineAndCalculateArrowheadsII(edgeGeom,edgeGeom.sourcePort.Curve,edgeGeom.targetPort.Curve,edgeGeom.curve,!0)}get ObsTree(){return this.GraphGenerator.ObstacleTree}GenerateObstacleTree(){if(null==this.Obstacles||0==this.Obstacles.length)throw new Error("No obstacles have been added");null==this.ObsTree.Root&&this.InitObstacleTree()}InitObstacleTree(){this.AncestorsSets=SplineRouter.GetAncestorSetsMap(this.Obstacles),this.ObsTree.Init(this.ShapeToObstacleMap.values(),this.AncestorsSets,this.ShapeToObstacleMap)}InternalClear(retainObstacles){this.GraphGenerator.Clear(),this.ClearShortestPaths(),retainObstacles?this.PortManager.ClearVisibility():(this.PortManager.Clear(),this.ShapeToObstacleMap.clear(),this.EdgesToRoute=[])}ClearShortestPaths(){for(const edgeGeom of this.EdgesToRoute)edgeGeom.curve=null}GenerateVisibilityGraph(){if(null==this.Obstacles||0==this.Obstacles.length)throw new Error("No obstacles have been set");null==this.GraphGenerator.VisibilityGraph&&this.CreateVisibilityGraph()}static FitArcsIntoCorners(radius,polyline){const ellipses=RectilinearEdgeRouter.GetFittedArcSegs(radius,polyline),curve=new Curve;let prevEllipse=null;for(const ellipse of ellipses){const ellipseIsAlmostCurve=RectilinearEdgeRouter.EllipseIsAlmostLineSegment(ellipse);null!=prevEllipse?ellipseIsAlmostCurve?Curve.continueWithLineSegmentP(curve,RectilinearEdgeRouter.CornerPoint(ellipse)):(Curve.continueWithLineSegmentP(curve,ellipse.start),curve.addSegment(ellipse)):ellipseIsAlmostCurve?Curve.addLineSegment(curve,polyline[0],RectilinearEdgeRouter.CornerPoint(ellipse)):(Curve.addLineSegment(curve,polyline[0],ellipse.start),curve.addSegment(ellipse)),prevEllipse=ellipse}return curve.segs.length>0?Curve.continueWithLineSegmentP(curve,polyline[polyline.length-1]):Curve.addLineSegment(curve,polyline[0],polyline[polyline.length-1]),curve}static CornerPoint(ellipse){return ellipse.center.add(ellipse.aAxis.add(ellipse.bAxis))}static EllipseIsAlmostLineSegment(ellipse){return ellipse.aAxis.lengthSquared<1e-4||ellipse.aAxis.lengthSquared<1e-4}static*GetFittedArcSegs(radius,polyline){let leg=polyline[1].sub(polyline[0]),dir=leg.normalize(),rad0=Math.min(radius,leg.length/2);for(let i=1;i<polyline.length-1;i++){leg=polyline[i+1].sub(polyline[i]);const legLength=leg.length;if(legLength<GeomConstants.intersectionEpsilon){yield new Ellipse(0,0,new point_Point(0,0),new point_Point(0,0),polyline[i]);continue}const ndir=leg.div(legLength);Math.abs(ndir.dot(dir))>.9&&(yield new Ellipse(0,0,new point_Point(0,0),new point_Point(0,0),polyline[i]));const nrad0=Math.min(radius,leg.length/2),axis0=ndir.mul(-nrad0),axis1=dir.mul(rad0);yield new Ellipse(0,Math.PI/2,axis0,axis1,polyline[i].sub(axis1.add(axis0))),dir=ndir,rad0=nrad0}}}RectilinearEdgeRouter.DefaultPadding=1,RectilinearEdgeRouter.DefaultCornerFitRadius=3;class CdtEdge{constructor(a,b){this.Constrained=!1,this.Capacity=1e6;1==Cdt.AbovePP(a.point,b.point)?(this.upperSite=a,this.lowerSite=b):(this.lowerSite=a,this.upperSite=b),this.upperSite.AddEdgeToSite(this)}get CcwTriangle(){return this.ccwTriangle}set CcwTriangle(value){this.ccwTriangle=value}get CwTriangle(){return this.cwTriangle}set CwTriangle(value){this.cwTriangle=value}GetOtherTriangle_c(p){return this.cwTriangle.Contains(p)?this.ccwTriangle:this.cwTriangle}IsAdjacent(pi){return pi==this.upperSite||pi==this.lowerSite}GetOtherTriangle_T(triangle){return this.ccwTriangle==triangle?this.cwTriangle:this.ccwTriangle}toString(){return dist.Qf.Format("({0},{1})",this.upperSite,this.lowerSite)}OtherSite(site){return this.upperSite==site?this.lowerSite:this.upperSite}}class CdtSite{constructor(isolatedSite){this.Owner=null,this.InEdges=new Array,this.point=isolatedSite}static mkSO(isolatedSite,owner){const s=new CdtSite(isolatedSite);return s.Owner=owner,s}AddEdgeToSite(edge){null==this.Edges&&(this.Edges=new Array),this.Edges.push(edge)}EdgeBetweenUpperSiteAndLowerSite(b){if(null!=this.Edges)for(const edge of this.Edges)if(edge.lowerSite==b)return edge;return null}AddInEdge(e){null==this.InEdges&&(this.InEdges=new Array),this.InEdges.push(e)}*Triangles(){let edge;if(null!=this.Edges&&this.Edges.length>0)edge=this.Edges[0];else{if(!(null!=this.InEdges&&this.InEdges.length>0))return;edge=this.InEdges[0]}let e=edge;do{const t=e.upperSite==this?e.CcwTriangle:e.CwTriangle;if(null==t){e=null;break}yield t,e=t.TriEdges.getItem(t.TriEdges.index(e)+2)}while(e!=edge);if(e!=edge)for(e=edge;;){const t=e.upperSite==this?e.CwTriangle:e.CcwTriangle;if(null==t)break;yield t,e=t.TriEdges.getItem(t.TriEdges.index(e)+1)}}toString(){return this.point.toString()}}class CdtFrontElement{constructor(leftSite,edge){this.RightSite=edge.upperSite==leftSite?edge.lowerSite:edge.upperSite,this.LeftSite=leftSite,this.Edge=edge}get x(){return this.LeftSite.point.x}toString(){return"("+this.LeftSite.toString()+", "+this.Edge.toString()+","+this.RightSite.toString()+")"}}class ThreeArray{has(t){return t==this.item0||t==this.item1||t==this.item2}index(t){return t==this.item0?0:t==this.item1?1:t==this.item2?2:-1}getItem(i){switch(i){case 0:case 3:case-3:return this.item0;case 1:case 4:case-2:return this.item1;case 2:case 5:case-1:return this.item2;default:throw new Error}}setItem(i,value){switch(i){case 0:case 3:case-3:this.item0=value;break;case 1:case 4:case-2:this.item1=value;break;case 2:case 5:case-1:this.item2=value;break;default:throw new Error}}[Symbol.iterator](){return this.GetEnumerator()}*GetEnumerator(){yield this.item0,yield this.item1,yield this.item2}}class CdtTriangle{constructor(){this.TriEdges=new ThreeArray,this.Sites=new ThreeArray}static mkSSSD(a,b,c,createEdgeDelegate){const orientation=point_Point.getTriangleOrientation(a.point,b.point,c.point),r=new CdtTriangle;switch(orientation){case point_TriangleOrientation.Counterclockwise:r.FillCcwTriangle(a,b,c,createEdgeDelegate);break;case point_TriangleOrientation.Clockwise:r.FillCcwTriangle(a,c,b,createEdgeDelegate);break;default:throw new Error}return r}static mkSED(pi,edge,createEdgeDelegate){const tri=new CdtTriangle;switch(point_Point.getTriangleOrientation(edge.upperSite.point,edge.lowerSite.point,pi.point)){case point_TriangleOrientation.Counterclockwise:edge.CcwTriangle=tri,tri.Sites.setItem(0,edge.upperSite),tri.Sites.setItem(1,edge.lowerSite);break;case point_TriangleOrientation.Clockwise:edge.CwTriangle=tri,tri.Sites.setItem(0,edge.lowerSite),tri.Sites.setItem(1,edge.upperSite);break;default:throw new Error}return tri.TriEdges.setItem(0,edge),tri.Sites.setItem(2,pi),tri.CreateEdge(1,createEdgeDelegate),tri.CreateEdge(2,createEdgeDelegate),tri}static mkSSSEE(aLeft,aRight,bRight,a,b,createEdgeDelegate){const tri=CdtTriangle.mkSSSD(aLeft,aRight,bRight,createEdgeDelegate);return tri.TriEdges.setItem(0,a),tri.TriEdges.setItem(1,b),tri.BindEdgeToTriangle(aLeft,a),tri.BindEdgeToTriangle(aRight,b),tri.CreateEdge(2,createEdgeDelegate),tri}BindEdgeToTriangle(site,edge){site==edge.upperSite?edge.CcwTriangle=this:edge.CwTriangle=this}FillCcwTriangle(a,b,c,createEdgeDelegate){this.Sites.setItem(0,a),this.Sites.setItem(1,b),this.Sites.setItem(2,c);for(let i=0;i<3;i++)this.CreateEdge(i,createEdgeDelegate)}CreateEdge(i,createEdgeDelegate){const a=this.Sites.getItem(i),edge=createEdgeDelegate(a,this.Sites.getItem(i+1));this.TriEdges.setItem(i,edge),this.BindEdgeToTriangle(a,edge)}Contains(cdtSite){return this.Sites.has(cdtSite)}OppositeEdge(pi){const index=this.Sites.index(pi);return this.TriEdges.getItem(index+1)}OppositeSite(cdtEdge){const i=this.TriEdges.index(cdtEdge);return this.Sites.getItem(i+2)}BoundingBox(){const rect=Rectangle.mkPP(this.Sites.getItem(0).point,this.Sites.getItem(1).point);return rect.add(this.Sites.getItem(2).point),rect}static mkSSSEED(aLeft,aRight,bRight,a,b,createEdgeDelegate){const t=new CdtTriangle;return t.Sites.setItem(0,aLeft),t.Sites.setItem(1,aRight),t.Sites.setItem(2,bRight),t.TriEdges.setItem(0,a),t.TriEdges.setItem(1,b),t.BindEdgeToTriangle(aLeft,a),t.BindEdgeToTriangle(aRight,b),t.CreateEdge(2,createEdgeDelegate),t}toString(){return this.Sites.getItem(0).toString()+","+this.Sites.getItem(1).toString()+","+this.Sites.getItem(2).toString()}}class EdgeTracer{constructor(edge,triangles,front,leftPolygon,rightPolygon){this.elementsToBeRemovedFromFront=new Array,this.removedTriangles=new Array,this.edge=edge,this.triangles=triangles,this.front=front,this.leftPolygon=leftPolygon,this.rightPolygon=rightPolygon,this.a=edge.upperSite,this.b=edge.lowerSite}Run(){this.Init(),this.Traverse()}Traverse(){for(;!this.BIsReached();)null!=this.piercedToTheLeftFrontElemNode?this.ProcessLeftFrontPiercedElement():null!=this.piercedToTheRightFrontElemNode?this.ProcessRightFrontPiercedElement():this.ProcessPiercedEdge();null!=this.piercedTriangle&&this.removePiercedTriangle(this.piercedTriangle),this.FindMoreRemovedFromFrontElements();for(const elem of this.elementsToBeRemovedFromFront)this.front.remove(elem)}ProcessLeftFrontPiercedElement(){let v=this.piercedToTheLeftFrontElemNode;do{this.elementsToBeRemovedFromFront.push(v.item),this.AddSiteToLeftPolygon(v.item.LeftSite),v=this.front.previous(v)}while(point_Point.pointToTheLeftOfLine(v.item.LeftSite.point,this.a.point,this.b.point));this.elementsToBeRemovedFromFront.push(v.item),this.AddSiteToRightPolygon(v.item.LeftSite),v.item.LeftSite!=this.b?(this.FindPiercedTriangle(v),this.piercedToTheLeftFrontElemNode=null):this.piercedToTheLeftFrontElemNode=v}FindPiercedTriangle(v){var _a;const e=v.item.Edge,t=null!==(_a=e.CcwTriangle)&&void 0!==_a?_a:e.CwTriangle,eIndex=t.TriEdges.index(e);for(let i=1;i<=2;i++){const ei=t.TriEdges.getItem(i+eIndex),signedArea0=RealNumberSpan.sign(point_Point.signedDoubledTriangleArea(ei.lowerSite.point,this.a.point,this.b.point));if(RealNumberSpan.sign(point_Point.signedDoubledTriangleArea(ei.upperSite.point,this.a.point,this.b.point))*signedArea0<=0){this.piercedTriangle=t,this.piercedEdge=ei;break}}}FindMoreRemovedFromFrontElements(){for(const triangle of this.removedTriangles)for(const e of triangle.TriEdges)if(null==e.CcwTriangle&&null==e.CwTriangle){const site=e.upperSite.point.x<e.lowerSite.point.x?e.upperSite:e.lowerSite,frontNode=CdtSweeper.FindNodeInFrontBySite(this.front,site);frontNode.item.Edge==e&&this.elementsToBeRemovedFromFront.push(frontNode.item)}}ProcessPiercedEdge(){this.piercedEdge.CcwTriangle==this.piercedTriangle?(this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite),this.AddSiteToRightPolygon(this.piercedEdge.upperSite)):(this.AddSiteToLeftPolygon(this.piercedEdge.upperSite),this.AddSiteToRightPolygon(this.piercedEdge.lowerSite)),this.removePiercedTriangle(this.piercedTriangle),this.PrepareNextStateAfterPiercedEdge()}PrepareNextStateAfterPiercedEdge(){var _a,_b;const t=null!==(_a=this.piercedEdge.CwTriangle)&&void 0!==_a?_a:this.piercedEdge.CcwTriangle,eIndex=t.TriEdges.index(this.piercedEdge);for(let i=1;i<=2;i++){const e=t.TriEdges.getItem(i+eIndex),signedArea0=RealNumberSpan.sign(point_Point.signedDoubledTriangleArea(e.lowerSite.point,this.a.point,this.b.point));if(RealNumberSpan.sign(point_Point.signedDoubledTriangleArea(e.upperSite.point,this.a.point,this.b.point))*signedArea0<=0){if(null!=e.CwTriangle&&null!=e.CcwTriangle){this.piercedTriangle=t,this.piercedEdge=e;break}this.piercedTriangle=null,this.piercedEdge=null;const leftSite=e.upperSite.point.x<e.lowerSite.point.x?e.upperSite:e.lowerSite,frontElem=CdtSweeper.FindNodeInFrontBySite(this.front,leftSite);leftSite.point.x<this.a.point.x?this.piercedToTheLeftFrontElemNode=frontElem:this.piercedToTheRightFrontElemNode=frontElem,this.removePiercedTriangle(null!==(_b=e.CwTriangle)&&void 0!==_b?_b:e.CcwTriangle);break}}}removePiercedTriangle(t){this.triangles.delete(t);for(const e of t.TriEdges)e.CwTriangle==t?e.CwTriangle=null:e.CcwTriangle=null,this.removedTriangles.push(t)}ProcessRightFrontPiercedElement(){let v=this.piercedToTheRightFrontElemNode;do{this.elementsToBeRemovedFromFront.push(v.item),this.AddSiteToRightPolygon(v.item.RightSite),v=this.front.next(v)}while(point_Point.pointToTheRightOfLine(v.item.RightSite.point,this.a.point,this.b.point));this.elementsToBeRemovedFromFront.push(v.item),this.AddSiteToLeftPolygon(v.item.RightSite),v.item.RightSite!=this.b?(this.FindPiercedTriangle(v),this.piercedToTheRightFrontElemNode=null):this.piercedToTheRightFrontElemNode=v}AddSiteToLeftPolygon(site){this.AddSiteToPolygonWithCheck(site,this.leftPolygon)}AddSiteToPolygonWithCheck(site,list){site!=this.b&&(0!=list.length&&list[list.length-1]==site||list.push(site))}AddSiteToRightPolygon(site){this.AddSiteToPolygonWithCheck(site,this.rightPolygon)}BIsReached(){var _a;const node=null!==(_a=this.piercedToTheLeftFrontElemNode)&&void 0!==_a?_a:this.piercedToTheRightFrontElemNode;return null!=node?node.item.Edge.IsAdjacent(this.b):this.piercedEdge.IsAdjacent(this.b)}Init(){const frontElemNodeRightOfA=CdtSweeper.FindNodeInFrontBySite(this.front,this.a),frontElemNodeLeftOfA=this.front.previous(frontElemNodeRightOfA);if(point_Point.pointToTheLeftOfLine(this.b.point,frontElemNodeLeftOfA.item.LeftSite.point,frontElemNodeLeftOfA.item.RightSite.point))this.piercedToTheLeftFrontElemNode=frontElemNodeLeftOfA;else if(point_Point.pointToTheRightOfLine(this.b.point,frontElemNodeRightOfA.item.RightSite.point,frontElemNodeRightOfA.item.LeftSite.point))this.piercedToTheRightFrontElemNode=frontElemNodeRightOfA;else for(const e of this.a.Edges){const t=e.CcwTriangle;if(null==t)continue;if(point_Point.pointToTheLeftOfLine(this.b.point,e.lowerSite.point,e.upperSite.point))continue;const eIndex=t.TriEdges.index(e),site=t.Sites.getItem(eIndex+2);if(point_Point.pointToTheLeftOfLineOrOnLine(this.b.point,site.point,e.upperSite.point)){this.piercedEdge=t.TriEdges.getItem(eIndex+1),this.piercedTriangle=t;break}}}}class EdgeInserter{constructor(edge,triangles,front,createEdgeDelegate){this.rightPolygon=new Array,this.leftPolygon=new Array,this.addedTriangles=new Array,this.edge=edge,this.triangles=triangles,this.front=front,this.createEdgeDelegate=createEdgeDelegate}Run(){this.TraceEdgeThroughTriangles(),this.TriangulatePolygon0(this.rightPolygon,this.edge.upperSite,this.edge.lowerSite,!0),this.TriangulatePolygon0(this.leftPolygon,this.edge.upperSite,this.edge.lowerSite,!1),this.UpdateFront()}UpdateFront(){const newFrontEdges=new Set;for(const t of this.addedTriangles)for(const e of t.TriEdges)null!=e.CwTriangle&&null!=e.CcwTriangle||newFrontEdges.add(e);for(const e of newFrontEdges)this.AddEdgeToFront(e)}AddEdgeToFront(e){const leftSite=e.upperSite.point.x<e.lowerSite.point.x?e.upperSite:e.lowerSite;this.front.insert(new CdtFrontElement(leftSite,e))}TriangulatePolygon0(polygon,a,b,reverseTrangleWhenCompare){polygon.length>0&&this.TriangulatePolygon1(0,polygon.length-1,polygon,a,b,reverseTrangleWhenCompare)}TriangulatePolygon1(start,end,polygon,a,b,reverseTrangleWhenCompare){let c=polygon[start],cIndex=start;for(let i=start+1;i<=end;i++){const v=polygon[i];EdgeInserter.LocalInCircle(v,a,b,c,reverseTrangleWhenCompare)&&(cIndex=i,c=v)}const t=CdtTriangle.mkSSSD(a,b,c,this.createEdgeDelegate);this.triangles.add(t),this.addedTriangles.push(t),start<cIndex&&this.TriangulatePolygon1(start,cIndex-1,polygon,a,c,reverseTrangleWhenCompare),cIndex<end&&this.TriangulatePolygon1(cIndex+1,end,polygon,c,b,reverseTrangleWhenCompare)}static LocalInCircle(v,a,b,c,reverseTrangleWhenCompare){return reverseTrangleWhenCompare?InCircle(v,a,c,b):InCircle(v,a,b,c)}TraceEdgeThroughTriangles(){new EdgeTracer(this.edge,this.triangles,this.front,this.leftPolygon,this.rightPolygon).Run()}}class PerimeterEdge{constructor(edge){this.Edge=edge}}class CdtSweeper extends Algorithm{constructor(listOfSites,p_1,p_2,createEdgeDelegate){if(super(null),this.front=new RBTree(((a,b)=>a.x-b.x)),this.triangles=new Set,this.listOfSites=listOfSites,0==this.listOfSites.length)return;this.p_1=p_1,this.p_2=p_2,this.createEdgeDelegate=createEdgeDelegate;const firstTriangle=CdtTriangle.mkSSSD(p_1,p_2,this.listOfSites[0],createEdgeDelegate);this.triangles.add(firstTriangle),this.front.insert(new CdtFrontElement(p_1,firstTriangle.TriEdges.getItem(2))),this.front.insert(new CdtFrontElement(this.listOfSites[0],firstTriangle.TriEdges.getItem(1)))}run(){if(0!=this.listOfSites.length){for(let i=1;i<this.listOfSites.length;i++)this.ProcessSite(this.listOfSites[i]);this.FinalizeTriangulation()}}FinalizeTriangulation(){this.RemoveP1AndP2Triangles(),this.triangles.size>0&&this.MakePerimeterConvex()}MakePerimeterConvex(){let firstPerimeterEdge=this.CreateDoubleLinkedListOfPerimeter();for(;;){const concaveEdge=this.FindConcaveEdge(firstPerimeterEdge);if(null==concaveEdge)return;firstPerimeterEdge=this.ShortcutTwoListElements(concaveEdge)}}FindConcaveEdge(firstPerimeterEdge){let b,a=firstPerimeterEdge;do{if(b=a.Next,point_Point.getTriangleOrientation(a.Start.point,a.End.point,b.End.point)==point_TriangleOrientation.Counterclockwise)return a;a=b}while(b!=firstPerimeterEdge);return null}static FindPivot(firstPerimeterEdge){let pivot=firstPerimeterEdge,e=firstPerimeterEdge;do{e=e.Next,(e.Start.point.x<pivot.Start.point.x||e.Start.point.x==pivot.Start.point.x&&e.Start.point.y<pivot.Start.point.y)&&(pivot=e)}while(e!=firstPerimeterEdge);return pivot}FindFirsePerimeterEdge(){for(const t of this.triangles)for(const e of t.TriEdges)if(null==e.GetOtherTriangle_T(t))return e;return null}CreateDoubleLinkedListOfPerimeter(){const firstEdge=this.FindFirsePerimeterEdge();let pe,edge=firstEdge,listStart=null,prevPe=null;const debugDC=new Array;do{pe=CdtSweeper.CreatePerimeterElementFromEdge(edge),debugDC.push(LineSegment.mkPP(pe.Start.point,pe.End.point)),edge=CdtSweeper.FindNextEdgeOnPerimeter(edge),null!=prevPe?(pe.Prev=prevPe,prevPe.Next=pe):listStart=pe,prevPe=pe}while(edge!=firstEdge);return listStart.Prev=pe,pe.Next=listStart,listStart}static FindNextEdgeOnPerimeter(e){var _a;let t=null!==(_a=e.CwTriangle)&&void 0!==_a?_a:e.CcwTriangle;for(e=t.TriEdges.getItem(t.TriEdges.index(e)+2);null!=e.CwTriangle&&null!=e.CcwTriangle;)t=e.GetOtherTriangle_T(t),e=t.TriEdges.getItem(t.TriEdges.index(e)+2);return e}static CreatePerimeterElementFromEdge(edge){const pe=new PerimeterEdge(edge);return null!=edge.CwTriangle?(pe.Start=edge.upperSite,pe.End=edge.lowerSite):(pe.End=edge.upperSite,pe.Start=edge.lowerSite),pe}RemoveP1AndP2Triangles(){const trianglesToRemove=new Set;for(const t of this.triangles)(t.Sites.has(this.p_1)||t.Sites.has(this.p_2))&&trianglesToRemove.add(t);for(const t of trianglesToRemove)CdtSweeper.RemoveTriangleWithEdges(this.triangles,t)}static RemoveTriangleWithEdges(cdtTriangles,t){cdtTriangles.delete(t);for(const e of t.TriEdges)e.CwTriangle==t?e.CwTriangle=null:e.CcwTriangle=null,null==e.CwTriangle&&null==e.CcwTriangle&&removeFromArray(e.upperSite.Edges,e)}static RemoveTriangleButLeaveEdges(cdtTriangles,t){cdtTriangles.delete(t);for(const e of t.TriEdges)e.CwTriangle==t?e.CwTriangle=null:e.CcwTriangle=null}ProcessSite(site){this.PointEvent(site);for(let i=0;i<site.Edges.length;i++){const edge=site.Edges[i];edge.Constrained&&this.EdgeEvent(edge)}}EdgeEvent(edge){if(CdtSweeper.EdgeIsProcessed(edge))return;new EdgeInserter(edge,this.triangles,this.front,this.createEdgeDelegate).Run()}static EdgeIsProcessed(edge){return null!=edge.CwTriangle||null!=edge.CcwTriangle}ShowFrontWithSite(site,redCurves=null){const ls=new Array;if(null!=site.Edges)for(const e of site.Edges)ls.push(debugCurve_DebugCurve.mkDebugCurveTWCI(200,.8,e.Constrained?"Pink":"Brown",LineSegment.mkPP(e.upperSite.point,e.lowerSite.point)));ls.push(debugCurve_DebugCurve.mkDebugCurveTWCI(200,1,"Brown",Ellipse.mkFullEllipseNNP(.5,.5,site.point)));for(const t of this.triangles)for(let i=0;i<3;i++){const e=t.TriEdges.getItem(i);ls.push(debugCurve_DebugCurve.mkDebugCurveTWCI(e.Constrained?155:100,e.Constrained?.8:.4,e.Constrained?"Pink":"Navy",LineSegment.mkPP(e.upperSite.point,e.lowerSite.point)))}if(null!=redCurves)for(const c of redCurves)ls.push(debugCurve_DebugCurve.mkDebugCurveTWCI(100,.5,"Red",c));for(const frontElement of this.front)ls.push(debugCurve_DebugCurve.mkDebugCurveTWCI(100,5.5,"Green",LineSegment.mkPP(frontElement.Edge.upperSite.point,frontElement.Edge.lowerSite.point)))}Show(fn){CdtSweeper.ShowCdt(Array.from(this.triangles.values()),this.front,null,null,[],fn)}static ShowCdt(cdtTriangles,cdtFrontElements,redCurves,blueCurves,dc,fn){let ls=new Array;if(null!=redCurves)for(const c of redCurves)ls.push(debugCurve_DebugCurve.mkDebugCurveTWCI(200,.1,"Red",c));if(null!=blueCurves)for(const c of blueCurves)ls.push(debugCurve_DebugCurve.mkDebugCurveTWCI(200,.1,"Blue",c));if(null!=cdtFrontElements)for(const frontElement of cdtFrontElements)ls.push(debugCurve_DebugCurve.mkDebugCurveTWCI(200,.1,"Green",LineSegment.mkPP(frontElement.Edge.upperSite.point,frontElement.Edge.lowerSite.point)));for(const t of cdtTriangles)for(let i=0;i<3;i++){const e=t.TriEdges.getItem(i);ls.push(CdtSweeper.GetDebugCurveOfCdtEdge(e))}ls=ls.concat(dc)}static GetDebugCurveOfCdtEdge(e){return null==e.CcwTriangle||null==e.CwTriangle?debugCurve_DebugCurve.mkDebugCurveTWCI(255,.5,e.Constrained?"Brown":"Black",LineSegment.mkPP(e.upperSite.point,e.lowerSite.point)):debugCurve_DebugCurve.mkDebugCurveTWCI(200,e.Constrained?.8:.2,e.Constrained?"Pink":"Navy",LineSegment.mkPP(e.upperSite.point,e.lowerSite.point))}PointEvent(pi){const hittedFrontElementNode=this.ProjectToFront(pi),t={rightSite:null},leftSite=hittedFrontElementNode.item.x+GeomConstants.distanceEpsilon<pi.point.x?this.MiddleCase(pi,hittedFrontElementNode,t):this.LeftCase(pi,hittedFrontElementNode,t);let piNode=this.InsertSiteIntoFront(leftSite,pi,t.rightSite);this.TriangulateEmptySpaceToTheRight(piNode),piNode=CdtSweeper.FindNodeInFrontBySite(this.front,leftSite),this.TriangulateEmptySpaceToTheLeft(piNode)}LeftCase(pi,hittedFrontElementNode,t){const hittedFrontElement=hittedFrontElementNode.item;this.InsertAndLegalizeTriangle(pi,hittedFrontElement);const prevToHitted=this.front.previous(hittedFrontElementNode),leftSite=prevToHitted.item.LeftSite;t.rightSite=hittedFrontElementNode.item.RightSite,this.InsertAndLegalizeTriangle(pi,prevToHitted.item),this.front.deleteNodeInternal(prevToHitted);this.front.remove(hittedFrontElement);return leftSite}MiddleCase(pi,hittedFrontElementNode,t){const leftSite=hittedFrontElementNode.item.LeftSite;return t.rightSite=hittedFrontElementNode.item.RightSite,this.InsertAndLegalizeTriangle(pi,hittedFrontElementNode.item),this.front.deleteNodeInternal(hittedFrontElementNode),leftSite}TriangulateEmptySpaceToTheLeft(leftLegNode){const peakSite=leftLegNode.item.RightSite;let previousNode=this.front.previous(leftLegNode);for(;null!=previousNode;){const prevElement=previousNode.item,rp=prevElement.LeftSite,r=prevElement.RightSite;if(!(r.point.sub(peakSite.point).dot(rp.point.sub(r.point))<0)){this.TryTriangulateBasinToTheLeft(leftLegNode);break}leftLegNode=this.ShortcutTwoFrontElements(previousNode,leftLegNode),previousNode=this.front.previous(leftLegNode)}}ShortcutTwoListElements(a){var _a;const b=a.Next;let t=CdtTriangle.mkSSSEE(a.Start,a.End,b.End,a.Edge,b.Edge,this.createEdgeDelegate);this.triangles.add(t);const newEdge=t.TriEdges.getItem(2);this.LegalizeEdge(a.Start,t.OppositeEdge(a.Start)),t=null!==(_a=newEdge.CcwTriangle)&&void 0!==_a?_a:newEdge.CwTriangle,this.LegalizeEdge(b.End,t.OppositeEdge(b.End));const c=new PerimeterEdge(newEdge);return c.Start=a.Start,c.End=b.End,a.Prev.Next=c,c.Prev=a.Prev,c.Next=b.Next,b.Next.Prev=c,c}ShortcutTwoFrontElements(aNode,bNode){var _a;const aElem=aNode.item,bElem=bNode.item;let t=CdtTriangle.mkSSSEED(aElem.LeftSite,aElem.RightSite,bElem.RightSite,aElem.Edge,bElem.Edge,this.createEdgeDelegate);this.triangles.add(t),this.front.deleteNodeInternal(aNode),this.front.remove(bElem);const newEdge=t.TriEdges.getItem(2);return this.LegalizeEdge(aElem.LeftSite,t.OppositeEdge(aElem.LeftSite)),t=null!==(_a=newEdge.CcwTriangle)&&void 0!==_a?_a:newEdge.CwTriangle,this.LegalizeEdge(bElem.RightSite,t.OppositeEdge(bElem.RightSite)),this.front.insert(new CdtFrontElement(aElem.LeftSite,newEdge))}TryTriangulateBasinToTheLeft(leftLegNode){if(!CdtSweeper.DropsSharpEnoughToTheLeft(leftLegNode.item))return;const stack=new lib_src.B;for(stack.push(leftLegNode.item.LeftSite);;){const site=stack.pop();leftLegNode=CdtSweeper.FindNodeInFrontBySite(this.front,site);const prev=this.front.previous(leftLegNode);if(null==prev)return;if(point_Point.getTriangleOrientation(prev.item.LeftSite.point,leftLegNode.item.LeftSite.point,leftLegNode.item.RightSite.point)==point_TriangleOrientation.Counterclockwise)stack.push(prev.item.LeftSite),this.ShortcutTwoFrontElements(prev,leftLegNode);else if(leftLegNode.item.LeftSite.point.y>leftLegNode.item.RightSite.point.y)stack.push(prev.item.LeftSite);else{if(prev.item.LeftSite.point.y<=prev.item.RightSite.point.y)return;stack.push(prev.item.LeftSite)}}}static DropsSharpEnoughToTheLeft(frontElement){const edge=frontElement.Edge;if(frontElement.RightSite!=edge.upperSite)return!1;const d=edge.lowerSite.point.sub(edge.upperSite.point);return d.x>=.5*d.y}InsertSiteIntoFront(leftSite,pi,rightSite){let rightEdge=null,leftEdge=null;for(const edge of pi.Edges)if(null==leftEdge&&edge.lowerSite==leftSite&&(leftEdge=edge),null==rightEdge&&edge.lowerSite==rightSite&&(rightEdge=edge),null!=leftEdge&&null!=rightEdge)break;return this.front.insert(new CdtFrontElement(leftSite,leftEdge)),this.front.insert(new CdtFrontElement(pi,rightEdge))}TriangulateEmptySpaceToTheRight(piNode){const piPoint=piNode.item.LeftSite.point;let piNext=this.front.next(piNode);for(;null!=piNext;){const frontElem=piNext.item,r=frontElem.LeftSite,rp=frontElem.RightSite;if(!(r.point.sub(piPoint).dot(rp.point.sub(r.point))<0)){this.TryTriangulateBasinToTheRight(piNode);break}piNode=this.ShortcutTwoFrontElements(piNode,piNext),piNext=this.front.next(piNode)}}TryTriangulateBasinToTheRight(piNode){if(!CdtSweeper.DropsSharpEnoughToTheRight(piNode.item))return;const stack=new lib_src.B;for(stack.push(piNode.item.LeftSite);;){const site=stack.pop();piNode=CdtSweeper.FindNodeInFrontBySite(this.front,site);const next=this.front.next(piNode);if(null==next)return;if(point_Point.getTriangleOrientation(piNode.item.LeftSite.point,piNode.item.RightSite.point,next.item.RightSite.point)==point_TriangleOrientation.Counterclockwise)this.ShortcutTwoFrontElements(piNode,next),stack.push(site);else if(piNode.item.LeftSite.point.y>piNode.item.RightSite.point.y)stack.push(piNode.item.RightSite);else{if(next.item.LeftSite.point.y>=next.item.RightSite.point.y)return;stack.push(piNode.item.RightSite)}}}static DropsSharpEnoughToTheRight(frontElement){const edge=frontElement.Edge;if(frontElement.LeftSite!=edge.upperSite)return!1;const d=edge.lowerSite.point.sub(edge.upperSite.point);return d.x<=-.5*d.y}static FindNodeInFrontBySite(cdtFrontElements,piSite){return cdtFrontElements.findLast((x=>x.LeftSite.point.x<=piSite.point.x))}InsertAndLegalizeTriangle(pi,frontElement){var _a;if(point_Point.getTriangleOrientation(pi.point,frontElement.LeftSite.point,frontElement.RightSite.point)!=point_TriangleOrientation.Collinear){const tr=CdtTriangle.mkSED(pi,frontElement.Edge,this.createEdgeDelegate);this.triangles.add(tr),this.LegalizeEdge(pi,tr.TriEdges.getItem(0))}else{const e=frontElement.Edge;removeFromArray(e.upperSite.Edges,e);let t=null!==(_a=e.CcwTriangle)&&void 0!==_a?_a:e.CwTriangle;const oppositeSite=t.OppositeSite(e);CdtSweeper.RemoveTriangleButLeaveEdges(this.triangles,t),t=CdtTriangle.mkSSSD(frontElement.LeftSite,oppositeSite,pi,this.createEdgeDelegate);const t1=CdtTriangle.mkSSSD(frontElement.RightSite,oppositeSite,pi,this.createEdgeDelegate);this.triangles.add(t),this.triangles.add(t1),this.LegalizeEdge(pi,t.OppositeEdge(pi)),this.LegalizeEdge(pi,t1.OppositeEdge(pi))}}LegalizeEdge(pi,edge){edge.Constrained||null==edge.CcwTriangle||null==edge.CwTriangle||(edge.CcwTriangle.Contains(pi)?this.LegalizeEdgeForOtherCwTriangle(pi,edge):this.LegalizeEdgeForOtherCcwTriangle(pi,edge))}LegalizeEdgeForOtherCwTriangle(pi,edge){const i=edge.CwTriangle.TriEdges.index(edge);if(IsIllegal(pi,edge.upperSite,edge.CwTriangle.Sites.getItem(i+2),edge.lowerSite)){const e=Flip(pi,edge);this.LegalizeEdge(pi,e.CwTriangle.OppositeEdge(pi)),this.LegalizeEdge(pi,e.CcwTriangle.OppositeEdge(pi))}}LegalizeEdgeForOtherCcwTriangle(pi,edge){const i=edge.CcwTriangle.TriEdges.index(edge);if(IsIllegal(pi,edge.lowerSite,edge.CcwTriangle.Sites.getItem(i+2),edge.upperSite)){const e=Flip(pi,edge);this.LegalizeEdge(pi,e.CwTriangle.OppositeEdge(pi)),this.LegalizeEdge(pi,e.CcwTriangle.OppositeEdge(pi))}}ProjectToFront(site){return this.front.findLast((s=>s.x<=site.point.x))}}function removeFromArray(arr,item){if(0==arr.length)return;const i=arr.findIndex((e=>item==e));i>=0&&(i!=arr.length-1&&(arr[i]=arr[arr.length-1]),arr.pop())}function IsIllegal(pi,a,b,c){return function InCone(pi,a,b,c){return point_Point.getTriangleOrientation(a.point,pi.point,b.point)==point_TriangleOrientation.Clockwise&&point_Point.getTriangleOrientation(b.point,pi.point,c.point)==point_TriangleOrientation.Clockwise}(pi,a,b,c)&&InCircle(pi,a,b,c)}function InCircle(d,a,b,c){const axdx=a.point.x-d.point.x,aydy=a.point.y-d.point.y,bxdx=b.point.x-d.point.x,bydy=b.point.y-d.point.y,cxdx=c.point.x-d.point.x,cydy=c.point.y-d.point.y,t0=axdx*axdx+aydy*aydy,t1=bxdx*bxdx+bydy*bydy,t2=cxdx*cxdx+cydy*cydy;return axdx*(bydy*t2-cydy*t1)-bxdx*(aydy*t2-cydy*t0)+cxdx*(aydy*t1-bydy*t0)>GeomConstants.tolerance}function Flip(pi,edge){let t,ot;edge.CcwTriangle.Contains(pi)?(t=edge.CcwTriangle,ot=edge.CwTriangle):(t=edge.CwTriangle,ot=edge.CcwTriangle);const eIndex=t.TriEdges.index(edge),eOtherIndex=ot.TriEdges.index(edge),pl=ot.Sites.getItem(eOtherIndex+2),edgeBeforPi=t.TriEdges.getItem(eIndex+1),edgeBeforPl=ot.TriEdges.getItem(eOtherIndex+1),newEdge=Cdt.GetOrCreateEdge(pi,pl);return t.Sites.setItem(eIndex+1,pl),t.TriEdges.setItem(eIndex,edgeBeforPl),t.TriEdges.setItem(eIndex+1,newEdge),ot.Sites.setItem(eOtherIndex+1,pi),ot.TriEdges.setItem(eOtherIndex,edgeBeforPi),ot.TriEdges.setItem(eOtherIndex+1,newEdge),edgeBeforPl.lowerSite==pl?edgeBeforPl.CcwTriangle=t:edgeBeforPl.CwTriangle=t,edgeBeforPi.lowerSite==pi?edgeBeforPi.CcwTriangle=ot:edgeBeforPi.CwTriangle=ot,newEdge.upperSite==pi?(newEdge.CcwTriangle=ot,newEdge.CwTriangle=t):(newEdge.CcwTriangle=t,newEdge.CwTriangle=ot),removeFromArray(edge.upperSite.Edges,edge),newEdge}class Cdt extends Algorithm{constructor(isolatedSites,obstacles,isolatedSegments){super(null),this.isolatedSites=[],this.obstacles=[],this.PointsToSites=new PointMap,this.cdtTree=null,this.isolatedSites=isolatedSites,this.obstacles=obstacles,this.isolatedSegments=isolatedSegments}static constructor_(isolatedSitesWithObj){const r=new Cdt(null,null,null);return r.isolatedSitesWithObject=isolatedSitesWithObj,r}FillAllInputSites(){if(null!=this.isolatedSitesWithObject)for(const tuple of this.isolatedSitesWithObject)this.AddSite(tuple[0],tuple[1]);if(null!=this.isolatedSites)for(const isolatedSite of this.isolatedSites)this.AddSite(isolatedSite,null);if(null!=this.obstacles)for(const poly of this.obstacles)this.AddPolylineToAllInputSites(poly);if(null!=this.isolatedSegments)for(const isolatedSegment of this.isolatedSegments)this.AddConstrainedEdge(isolatedSegment.A,isolatedSegment.B,null);this.AddP1AndP2(),this.allInputSites=Array.from(this.PointsToSites.values())}AddSite(point,relatedObject){let site;return(site=this.PointsToSites.get(point))?site.Owner=relatedObject:(site=CdtSite.mkSO(point,relatedObject),this.PointsToSites.set(point,site)),site}AddP1AndP2(){const box=Rectangle.mkEmpty();for(const site of this.PointsToSites.keys())box.add(site);const delx=Math.max(box.width/3,1),dely=Math.max(box.height/3,1);this.P1=new CdtSite(box.leftBottom.add(new point_Point(-delx,-dely))),this.P2=new CdtSite(box.rightBottom.add(new point_Point(delx,-dely)))}AddPolylineToAllInputSites(poly){for(let pp=poly.startPoint;null!=pp.next;pp=pp.next)this.AddConstrainedEdge(pp.point,pp.next.point,poly);poly.closed&&this.AddConstrainedEdge(poly.endPoint.point,poly.startPoint.point,poly)}AddConstrainedEdge(a,b,poly){let upperPoint,lowerPoint;Cdt.AbovePP(a,b)>0?(upperPoint=this.AddSite(a,poly),lowerPoint=this.AddSite(b,poly)):(upperPoint=this.AddSite(b,poly),lowerPoint=this.AddSite(a,poly));Cdt.CreateEdgeOnOrderedCouple(upperPoint,lowerPoint).Constrained=!0}static GetOrCreateEdge(a,b){if(1==Cdt.AboveCC(a,b)){const e=a.EdgeBetweenUpperSiteAndLowerSite(b);return null!=e?e:Cdt.CreateEdgeOnOrderedCouple(a,b)}{const e=b.EdgeBetweenUpperSiteAndLowerSite(a);return null!=e?e:Cdt.CreateEdgeOnOrderedCouple(b,a)}}static CreateEdgeOnOrderedCouple(upperPoint,lowerPoint){return new CdtEdge(upperPoint,lowerPoint)}GetTriangles(){return this.sweeper.triangles}run(){this.Initialization(),this.SweepAndFinalize()}SweepAndFinalize(){this.sweeper=new CdtSweeper(this.allInputSites,this.P1,this.P2,Cdt.GetOrCreateEdge),this.sweeper.run()}Initialization(){this.FillAllInputSites(),this.allInputSites.sort(Cdt.OnComparison)}static OnComparison(a,b){return Cdt.AboveCC(a,b)}static AbovePP(a,b){let del=a.y-b.y;return del>0?1:del<0?-1:(del=a.x-b.x,del>0?-1:del<0?1:0)}static AboveCC(a,b){return Cdt.AbovePP(a.point,b.point)}RestoreEdgeCapacities(){for(const site of this.allInputSites)for(const e of site.Edges)e.Constrained||(e.ResidualCapacity=e.Capacity)}SetInEdges(){for(const site of this.PointsToSites.values())for(const e of site.Edges){e.lowerSite.AddInEdge(e)}}FindSite(point){return this.PointsToSites.get(point)}static PointIsInsideOfTriangle(point,t){for(let i=0;i<3;i++){const a=t.Sites.getItem(i).point,b=t.Sites.getItem(i+1).point;if(point_Point.signedDoubledTriangleArea(point,a,b)<-1*GeomConstants.distanceEpsilon)return!1}return!0}GetCdtTree(){return null==this.cdtTree&&(this.cdtTree=CreateRectNodeOnArrayOfRectNodes(Array.from(this.GetTriangles().values()).map((t=>mkRectangleNode(t,t.BoundingBox()))))),this.cdtTree}EdgeIsCorrect(edge){const us=edge.upperSite;let edgeIsThere=!1;for(const e of us.Edges)if(e==edge){edgeIsThere=!0;break}if(!edgeIsThere)return!1;return this.PointsToSites.get(us.point)==us}}function driver_enforceLayoutSettings(geomGraph,ss){geomGraph.layoutSettings||(geomGraph.layoutSettings=ss);for(const n of geomGraph.shallowNodes())n.isGraph&&driver_enforceLayoutSettings(n,geomGraph.layoutSettings)}function getEdgeRoutingSettingsFromAncestors(geomGraph){for(;;){if(geomGraph.layoutSettings&&geomGraph.layoutSettings.edgeRoutingSettings)return geomGraph.layoutSettings.edgeRoutingSettings;const parent=geomGraph.graph.parent;if(!parent)break;geomGraph=GeomObject.getGeom(parent)}const ers=new EdgeRoutingSettings;return ers.EdgeRoutingMode=EdgeRoutingMode.Spline,ers}function driver_edgeRouter(geomGraph,edgesToRoute,cancelToken){const ers=getEdgeRoutingSettingsFromAncestors(geomGraph);if(ers.EdgeRoutingMode==EdgeRoutingMode.Rectilinear)!function routeRectilinearEdges(geomG,edgesToRoute,cancelToken,nodePadding=1,cornerFitRadius=3){const rr=RectilinearEdgeRouter.constructorGNANB(geomG,edgesToRoute,nodePadding,cornerFitRadius,!0);rr.run()}(geomGraph,edgesToRoute);else if(ers.EdgeRoutingMode==EdgeRoutingMode.Spline||ers.EdgeRoutingMode==EdgeRoutingMode.SplineBundling)!function routeSplines(gg,edgesToRoute,cancelToken){const ers=gg.layoutSettings?gg.layoutSettings.edgeRoutingSettings:getEdgeRoutingSettingsFromAncestors(gg),sr=new SplineRouter(gg,edgesToRoute,ers.Padding,ers.PolylinePadding,ers.coneAngle,ers.BundlingSettings,cancelToken);sr.run()}(geomGraph,edgesToRoute,cancelToken);else if(ers.EdgeRoutingMode==EdgeRoutingMode.StraightLine)!function straightLineEdgePatcher(geomGraph,edgesToRoute,cancelToken){if(edgesToRoute)for(const e of edgesToRoute){if(cancelToken&&cancelToken.canceled)return;StraightLineEdges.RouteEdge(e,geomGraph.padding)}else for(const n of geomGraph.deepNodes()){if(cancelToken&&cancelToken.canceled)return;for(const e of n.outEdges())null==e.curve&&StraightLineEdges.RouteEdge(e,geomGraph.padding);for(const e of n.selfEdges())null==e.curve&&StraightLineEdges.RouteEdge(e,geomGraph.padding)}}(geomGraph,edgesToRoute,cancelToken);else if(null==geomGraph.graph.parent&&ers.EdgeRoutingMode!=EdgeRoutingMode.None){const unroutedEdges=Array.from(geomGraph.deepEdges()).filter((e=>!e.curve));unroutedEdges.length>0&&new SplineRouter(geomGraph,unroutedEdges).run()}}function driver_layoutGeomGraphDetailed(geomG,cancelToken,layoutEngine,edgeRouter,packing,flipToScreenCoords=!0){if(geomG.graph.isEmpty())return;const removedEdges=function removeEdgesLeadingOutOfGraphOrCollapsingToSelfEdges(){const ret=new Set,graphUnderSurgery=geomG.graph;if(null==graphUnderSurgery.parent)return ret;for(const n of graphUnderSurgery.shallowNodes){for(const e of n.outEdges){const lifted=graphUnderSurgery.liftNode(e.target);null!=lifted&&lifted!=n||ret.add(e)}for(const e of n.inEdges){const lifted=graphUnderSurgery.liftNode(e.source);null!=lifted&&lifted!=n||ret.add(e)}}for(const e of ret)e.remove();return ret}();!function layoutShallowSubgraphs(geomG){for(const n of geomG.shallowNodes())if(n.isGraph){const g=n;if(driver_layoutGeomGraphDetailed(g,cancelToken,layoutEngine,edgeRouter,packing),!g.graph.isEmpty()){const bb=g.boundingBox;bb&&!bb.isEmpty()&&(n.boundaryCurve=curveFactory_CurveFactory.mkRectangleWithRoundedCorners(bb.width,bb.height,Math.min(10,bb.width/10),Math.min(10,bb.height/10),bb.center))}}}(geomG);const liftedEdges=function createLiftedEdges(graph){const liftedEdges=new Array;for(const u of graph.deepNodes){const liftedU=graph.liftNode(u);if(null!=liftedU)for(const uv of u.outEdges.values()){const v=uv.target,liftedV=graph.liftNode(v);if(null==liftedV||liftedU==u&&liftedV==v||liftedU==liftedV)continue;uv.remove();const newLiftedEdge=new Edge(liftedU,liftedV),newLiftedGeomEdge=new GeomEdge(newLiftedEdge);liftedEdges.push([newLiftedGeomEdge,uv])}}return liftedEdges}(geomG.graph),connectedGraphs=function getConnectedComponents(parentGeomGraph){const parentGraph=parentGeomGraph.graph,comps=function*shallowConnectedComponents(graph){const enqueueed=new Set,queue=new src.o;for(const n of graph.shallowNodes){if(enqueueed.has(n))continue;const nodes=new Array;for(enqueue(n,queue,enqueueed);queue.length>0;){const s=queue.dequeue();nodes.push(s);for(const neighbor of neighbors(s))enqueue(neighbor,queue,enqueueed)}yield nodes}function*neighbors(n){for(const e of n.outEdges)yield e.target;for(const e of n.inEdges)yield e.source}function enqueue(n,queue,enqueueed){enqueueed.has(n)||(queue.enqueue(n),enqueueed.add(n))}}(parentGraph),ret=[];let i=0;for(const comp of comps){const g=new Graph(parentGraph.id+i++);g.parent=parentGraph;const geomG=new GeomGraph(g);geomG.layoutSettings=parentGeomGraph.layoutSettings;for(const n of comp)n.parent=g,g.addNode(n);ret.push(geomG)}return ret}(geomG);!function layoutComps(){if(0==connectedGraphs.length)return;for(const cg of connectedGraphs)layoutEngine(cg,cancelToken);packing(geomG,connectedGraphs)}(),liftedEdges.forEach((e=>{e[0].edge.remove(),e[1].add()})),connectedGraphs.forEach((g=>{for(const n of g.graph.shallowNodes)n.parent=geomG.graph}));const edgesToRoute=function getUnroutedEdges(g){const edges=[];for(const n of g.deepNodes()){for(const e of n.outEdges())null==e.curve&&edges.push(e);for(const e of n.selfEdges())null==e.curve&&edges.push(e)}return edges}(geomG);removedEdges.forEach((e=>e.add())),edgeRouter(geomG,edgesToRoute,cancelToken),null==geomG.graph.parent&&flipToScreenCoords&&geomG.FlipYAndMoveLeftTopToOrigin()}class PreGraph{static constructorStatic(egs,nodeBoundaries){const pg=new PreGraph;pg.edges=egs,pg.nodeBoundaries=nodeBoundaries,pg.boundingBox=Rectangle.mkEmpty();for(const curve of pg.nodeBoundaries)pg.boundingBox=pg.boundingBox.addRec(curve.boundingBox);return pg}AddGraph(a){this.edges=this.edges.concat(a.edges),this.nodeBoundaries=uniteSets(this.nodeBoundaries,a.nodeBoundaries),this.boundingBox.addRec(a.boundingBox)}AddNodeBoundary(curve){this.nodeBoundaries.add(curve),this.boundingBox.addRec(curve.boundingBox)}}!function(BundlingStatus){BundlingStatus[BundlingStatus.Success=0]="Success",BundlingStatus[BundlingStatus.Overlaps=1]="Overlaps",BundlingStatus[BundlingStatus.EdgeSeparationIsTooLarge=2]="EdgeSeparationIsTooLarge"}(BundlingStatus||(BundlingStatus={}));const esm_internal_binarysearch_1=function(){var module={exports:{}};return function(module,exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.binarySearch=function binarySearch(array,key,comparer){if(0===array.length)return-1;let low=0,high=array.length-1;for(;low<=high;){const middle=low+(high-low>>1),midKey=array[middle];switch(Math.sign(comparer.compare(midKey,key))){case-1:low=middle+1;break;case 0:return middle;case 1:high=middle-1}}return~low}}(0,module.exports),module.exports}();class SortedSet{constructor(...args){let iterable,comparer;if(this._values=[],args.length>0){const arg0=args[0];void 0===arg0||null!=arg0&&Symbol.iterator in Object(arg0)?(iterable=arg0,args.length>1&&(comparer=args[1])):comparer=arg0}if(null!=comparer||(comparer=Comparer.defaultComparer),this._comparer="function"==typeof comparer?Comparer.create(comparer):comparer,iterable)for(const value of iterable)this.add(value)}get comparer(){return this._comparer}get size(){return this._values.length}has(value){return(0,esm_internal_binarysearch_1.binarySearch)(this._values,value,this._comparer)>=0}add(value){const index=(0,esm_internal_binarysearch_1.binarySearch)(this._values,value,this._comparer);return index>=0?this._values[index]=value:this._values.splice(~index,0,value),this}delete(value){const index=(0,esm_internal_binarysearch_1.binarySearch)(this._values,value,this._comparer);return index>=0&&(this._values.splice(index,1),!0)}clear(){this._values.length=0}keys(){return this._values.values()}values(){return this._values.values()}*entries(){for(let i=0;i<this._values.length;i++)yield[this._values[i],this._values[i]]}[Symbol.iterator](){return this.values()}forEach(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");for(const value of this)callback.call(thisArg,value,value,this)}get[Collection.size](){return this.size}[Collection.has](value){return this.has(value)}[Collection.add](value){this.add(value)}[Collection.delete](value){return this.delete(value)}[Collection.clear](){this.clear()}}var dist_esm_a;esm_a=SortedSet,Object.defineProperty(esm_a.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"SortedSet"});const internal_collections_hash_1=function(){var module={exports:{}};return function(module,exports){Object.defineProperty(exports,"__esModule",{value:!0});const primes=[3,7,11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,17519,21023,25229,30293,36353,43627,52361,62851,75431,90523,108631,130363,156437,187751,225307,270371,324449,389357,467237,560689,672827,807403,968897,1162687,1395263,1674319,2009191,2411033,2893249,3471899,4166287,4999559,5999471,7199369];function isPrime(candidate){if(1&candidate){const limit=0|Math.sqrt(candidate);for(let divisor=3;divisor<=limit;divisor+=2)if(!(candidate%divisor))return!1;return!0}return 2===candidate}function getPrime(min){if(min<0)throw new RangeError;for(let i=0;i<primes.length;i++){const prime=primes[i];if(prime>=min)return prime}for(let i=1|min;i<2147483647;i+=2)if(isPrime(i)&&(i-1)%101)return i;return min}function initializeHashData(hashData,capacity){const newCapacity=getPrime(capacity);return hashData.freeList=-1,hashData.buckets=new Int32Array(newCapacity),hashData.entries=new Array(newCapacity),newCapacity}function resizeHashData(hashData,newSize){const size=hashData.size,buckets=new Int32Array(newSize),entries=hashData.entries?hashData.entries.slice():[];entries.length=newSize;for(let i=0;i<size;i++){const entry=entries[i];if(entry&&entry.hashCode>=0){const bucket=entry.hashCode%newSize;entry.next=buckets[bucket]-1,buckets[bucket]=i+1}}hashData.buckets=buckets,hashData.entries=entries}function findEntryIndex(hashData,key){let i=-1;if(hashData.buckets&&hashData.entries){let hashCode=2147483647&hashData.equaler.hash(key);i=hashData.buckets[hashCode%hashData.buckets.length]-1;const length=hashData.entries.length;for(;i>>>0<length;){const entry=hashData.entries[i];if(entry.hashCode===hashCode&&hashData.equaler.equals(entry.key,key))break;i=entry.next}}return i}exports.createHashData=function createHashData(equaler,capacity){const head={prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0},hashData={buckets:void 0,entries:void 0,freeSize:0,freeList:0,size:0,equaler:equaler,head:head,tail:head};return initializeHashData(hashData,capacity),hashData},exports.findEntryIndex=findEntryIndex,exports.findEntryValue=function findEntryValue(hashData,key){const index=findEntryIndex(hashData,key);return index>=0?hashData.entries[index].value:void 0},exports.insertEntry=function insertEntry(hashData,key,value){if(hashData.buckets||initializeHashData(hashData,0),!hashData.buckets||!hashData.entries)throw new Error;const hashCode=2147483647&hashData.equaler.hash(key);let bucket=hashCode%hashData.buckets.length,i=hashData.buckets[bucket]-1;for(;i>>>0<hashData.entries.length;){const entry=hashData.entries[i];if(entry.hashCode===hashCode&&hashData.equaler.equals(entry.key,key))return void(entry.value=value);i=entry.next}let index,updateFreeList=!1;if(hashData.freeSize>0)index=hashData.freeList,updateFreeList=!0,hashData.freeSize--;else{const size=hashData.size;if(size===hashData.entries.length){if(resizeHashData(hashData,function expandPrime(oldSize){const newSize=2*oldSize;return newSize>2146435069&&2146435069>oldSize?2146435069:getPrime(newSize)}(hashData.size)),!hashData.buckets||!hashData.entries)throw new Error;bucket=hashCode%hashData.buckets.length}index=size,hashData.size=size+1}const entry=hashData.entries[index]||(hashData.entries[index]={prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0});updateFreeList&&(hashData.freeList=entry.next),entry.hashCode=hashCode,entry.next=hashData.buckets[bucket]-1,entry.key=key,entry.value=value,entry.skipNextEntry=!1;const tail=hashData.tail;tail.nextEntry=entry,entry.prevEntry=tail,hashData.tail=entry,hashData.buckets[bucket]=index+1},exports.deleteEntry=function deleteEntry(hashData,key){if(hashData.buckets&&hashData.entries){const hashCode=2147483647&hashData.equaler.hash(key),bucket=hashCode%hashData.buckets.length;let entry,last=-1;for(let i=hashData.buckets[bucket]-1;i>=0;i=entry.next){if(entry=hashData.entries[i],entry.hashCode===hashCode&&hashData.equaler.equals(entry.key,key)){last<0?hashData.buckets[bucket]=entry.next+1:hashData.entries[last].next=entry.next;const prevEntry=entry.prevEntry;return prevEntry.nextEntry=entry.nextEntry,prevEntry.nextEntry&&(prevEntry.nextEntry.prevEntry=prevEntry),hashData.tail===entry&&(hashData.tail=prevEntry),entry.hashCode=-1,entry.next=hashData.freeList,entry.key=void 0,entry.value=void 0,entry.prevEntry=void 0,entry.nextEntry=prevEntry,entry.skipNextEntry=!0,hashData.freeList=i,hashData.freeSize++,!0}last=i}}return!1},exports.clearEntries=function clearEntries(hashData){if(hashData.size>0){hashData.buckets&&hashData.buckets.fill(0),hashData.entries&&hashData.entries.fill(void 0);let currentEntry=hashData.head.nextEntry;for(;currentEntry;){const nextEntry=currentEntry.nextEntry;currentEntry.prevEntry=void 0,currentEntry.nextEntry=hashData.head,currentEntry.skipNextEntry=!0,currentEntry=nextEntry}hashData.head.nextEntry=void 0,hashData.tail=hashData.head,hashData.size=0,hashData.freeList=-1,hashData.freeSize=0}},exports.ensureCapacity=function ensureCapacity(hashData,capacity){if(capacity<0)throw new RangeError;const existingCapacity=hashData.entries?hashData.entries.length:0;if(existingCapacity>=capacity)return existingCapacity;if(!hashData.buckets)return initializeHashData(hashData,capacity);const newCapacity=getPrime(capacity);return resizeHashData(hashData,getPrime(capacity)),newCapacity},exports.trimExcessEntries=function trimExcessEntries(hashData,capacity=hashData.size-hashData.freeSize){if(capacity<hashData.size)throw new RangeError;if(!hashData.buckets||!hashData.entries)return;const newCapacity=getPrime(capacity),existingEntries=hashData.entries;if(newCapacity>=(existingEntries?existingEntries.length:0))return;const oldSize=hashData.size;if(initializeHashData(hashData,newCapacity),!hashData.buckets||!hashData.entries)throw new Error;let newSize=0;for(let i=0;i<oldSize;i++){const hashCode=existingEntries[i].hashCode;if(hashCode>=0){const bucket=hashCode%newCapacity;hashData.entries[newSize]=existingEntries[i],hashData.entries[newSize].next=hashData.buckets[bucket]-1,hashData.buckets[bucket]=newSize+1,newSize++}}hashData.size=newSize,hashData.freeSize=0},exports.selectEntryKey=function selectEntryKey(entry){return entry.key},exports.selectEntryValue=function selectEntryValue(entry){return entry.value},exports.selectEntryEntry=function selectEntryEntry(entry){return[entry.key,entry.value]},exports.iterateEntries=function*iterateEntries(head,selector){let currentEntry=head;for(;currentEntry;){const skipNextEntry=currentEntry.skipNextEntry;currentEntry=currentEntry.nextEntry,skipNextEntry||currentEntry&&(yield selector(currentEntry))}},exports.forEachEntry=function forEachEntry(source,head,callback,thisArg){let currentEntry=head;for(;currentEntry;){const skipNextEntry=currentEntry.skipNextEntry;currentEntry=currentEntry.nextEntry,skipNextEntry||currentEntry&&callback.call(thisArg,currentEntry.value,currentEntry.key,source)}}}(0,module.exports),module.exports}();class HashMap{constructor(...args){let capacity,iterable,equaler;if(args.length>0){const arg0=args[0];if("number"==typeof arg0){if(!(Object.is(arg0,0|arg0)&&arg0>=0))throw new RangeError("Argument out of range: capacity");capacity=arg0,args.length>1&&(equaler=args[1])}else void 0===arg0||null!=arg0&&Symbol.iterator in Object(arg0)?(iterable=arg0,args.length>1&&(equaler=args[1])):equaler=arg0}if(null!=capacity||(capacity=0),null!=equaler||(equaler=Equaler.defaultEqualer),this._hashData=(0,internal_collections_hash_1.createHashData)(equaler,capacity),iterable)for(const[key,value]of iterable)this.set(key,value)}get equaler(){return this._hashData.equaler}get size(){return this._hashData.size-this._hashData.freeSize}has(key){return(0,internal_collections_hash_1.findEntryIndex)(this._hashData,key)>=0}get(key){return(0,internal_collections_hash_1.findEntryValue)(this._hashData,key)}set(key,value){return(0,internal_collections_hash_1.insertEntry)(this._hashData,key,value),this}delete(key){return(0,internal_collections_hash_1.deleteEntry)(this._hashData,key)}clear(){(0,internal_collections_hash_1.clearEntries)(this._hashData)}ensureCapacity(capacity){if("number"!=typeof capacity)throw new TypeError("Number expected: capacity");if(!(Object.is(capacity,0|capacity)&&capacity>=0))throw new RangeError("Argument out of range: capacity");return(0,internal_collections_hash_1.ensureCapacity)(this._hashData,capacity)}trimExcess(capacity){if(void 0!==capacity){if("number"!=typeof capacity)throw new TypeError("Number expected: capacity");if(!(Object.is(capacity,0|capacity)&&capacity>=0))throw new RangeError("Argument out of range: capacity")}(0,internal_collections_hash_1.trimExcessEntries)(this._hashData,capacity)}keys(){return(0,internal_collections_hash_1.iterateEntries)(this._hashData.head,internal_collections_hash_1.selectEntryKey)}values(){return(0,internal_collections_hash_1.iterateEntries)(this._hashData.head,internal_collections_hash_1.selectEntryValue)}entries(){return(0,internal_collections_hash_1.iterateEntries)(this._hashData.head,internal_collections_hash_1.selectEntryEntry)}[Symbol.iterator](){return this.entries()}forEach(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");(0,internal_collections_hash_1.forEachEntry)(this,this._hashData.head,callback,thisArg)}get[ReadonlyKeyedCollection.size](){return this.size}[ReadonlyKeyedCollection.has](key){return this.has(key)}[ReadonlyKeyedCollection.get](key){return this.get(key)}[ReadonlyKeyedCollection.keys](){return this.keys()}[ReadonlyKeyedCollection.values](){return this.values()}[KeyedCollection.set](key,value){this.set(key,value)}[KeyedCollection.delete](key){return this.delete(key)}[KeyedCollection.clear](){this.clear()}}var collections_hashset_dist_esm_a;dist_esm_a=HashMap,Object.defineProperty(dist_esm_a.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"HashMap"});const esm_internal_collections_hash_1=function(){var module={exports:{}};return function(module,exports){Object.defineProperty(exports,"__esModule",{value:!0});const primes=[3,7,11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,17519,21023,25229,30293,36353,43627,52361,62851,75431,90523,108631,130363,156437,187751,225307,270371,324449,389357,467237,560689,672827,807403,968897,1162687,1395263,1674319,2009191,2411033,2893249,3471899,4166287,4999559,5999471,7199369];function isPrime(candidate){if(1&candidate){const limit=0|Math.sqrt(candidate);for(let divisor=3;divisor<=limit;divisor+=2)if(!(candidate%divisor))return!1;return!0}return 2===candidate}function getPrime(min){if(min<0)throw new RangeError;for(let i=0;i<primes.length;i++){const prime=primes[i];if(prime>=min)return prime}for(let i=1|min;i<2147483647;i+=2)if(isPrime(i)&&(i-1)%101)return i;return min}function initializeHashData(hashData,capacity){const newCapacity=getPrime(capacity);return hashData.freeList=-1,hashData.buckets=new Int32Array(newCapacity),hashData.entries=new Array(newCapacity),newCapacity}function resizeHashData(hashData,newSize){const size=hashData.size,buckets=new Int32Array(newSize),entries=hashData.entries?hashData.entries.slice():[];entries.length=newSize;for(let i=0;i<size;i++){const entry=entries[i];if(entry&&entry.hashCode>=0){const bucket=entry.hashCode%newSize;entry.next=buckets[bucket]-1,buckets[bucket]=i+1}}hashData.buckets=buckets,hashData.entries=entries}exports.createHashData=function createHashData(equaler,capacity){const head={prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0},hashData={buckets:void 0,entries:void 0,freeSize:0,freeList:0,size:0,equaler:equaler,head:head,tail:head};return initializeHashData(hashData,capacity),hashData},exports.findEntryIndex=function findEntryIndex(hashData,key){let i=-1;if(hashData.buckets&&hashData.entries){let hashCode=2147483647&hashData.equaler.hash(key);i=hashData.buckets[hashCode%hashData.buckets.length]-1;const length=hashData.entries.length;for(;i>>>0<length;){const entry=hashData.entries[i];if(entry.hashCode===hashCode&&hashData.equaler.equals(entry.key,key))break;i=entry.next}}return i},exports.insertEntry=function insertEntry(hashData,key,value){if(hashData.buckets||initializeHashData(hashData,0),!hashData.buckets||!hashData.entries)throw new Error;const hashCode=2147483647&hashData.equaler.hash(key);let bucket=hashCode%hashData.buckets.length,i=hashData.buckets[bucket]-1;for(;i>>>0<hashData.entries.length;){const entry=hashData.entries[i];if(entry.hashCode===hashCode&&hashData.equaler.equals(entry.key,key))return void(entry.value=value);i=entry.next}let index,updateFreeList=!1;if(hashData.freeSize>0)index=hashData.freeList,updateFreeList=!0,hashData.freeSize--;else{const size=hashData.size;if(size===hashData.entries.length){if(resizeHashData(hashData,function expandPrime(oldSize){const newSize=2*oldSize;return newSize>2146435069&&2146435069>oldSize?2146435069:getPrime(newSize)}(hashData.size)),!hashData.buckets||!hashData.entries)throw new Error;bucket=hashCode%hashData.buckets.length}index=size,hashData.size=size+1}const entry=hashData.entries[index]||(hashData.entries[index]={prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0});updateFreeList&&(hashData.freeList=entry.next),entry.hashCode=hashCode,entry.next=hashData.buckets[bucket]-1,entry.key=key,entry.value=value,entry.skipNextEntry=!1;const tail=hashData.tail;tail.nextEntry=entry,entry.prevEntry=tail,hashData.tail=entry,hashData.buckets[bucket]=index+1},exports.deleteEntry=function deleteEntry(hashData,key){if(hashData.buckets&&hashData.entries){const hashCode=2147483647&hashData.equaler.hash(key),bucket=hashCode%hashData.buckets.length;let entry,last=-1;for(let i=hashData.buckets[bucket]-1;i>=0;i=entry.next){if(entry=hashData.entries[i],entry.hashCode===hashCode&&hashData.equaler.equals(entry.key,key)){last<0?hashData.buckets[bucket]=entry.next+1:hashData.entries[last].next=entry.next;const prevEntry=entry.prevEntry;return prevEntry.nextEntry=entry.nextEntry,prevEntry.nextEntry&&(prevEntry.nextEntry.prevEntry=prevEntry),hashData.tail===entry&&(hashData.tail=prevEntry),entry.hashCode=-1,entry.next=hashData.freeList,entry.key=void 0,entry.value=void 0,entry.prevEntry=void 0,entry.nextEntry=prevEntry,entry.skipNextEntry=!0,hashData.freeList=i,hashData.freeSize++,!0}last=i}}return!1},exports.clearEntries=function clearEntries(hashData){if(hashData.size>0){hashData.buckets&&hashData.buckets.fill(0),hashData.entries&&hashData.entries.fill(void 0);let currentEntry=hashData.head.nextEntry;for(;currentEntry;){const nextEntry=currentEntry.nextEntry;currentEntry.prevEntry=void 0,currentEntry.nextEntry=hashData.head,currentEntry.skipNextEntry=!0,currentEntry=nextEntry}hashData.head.nextEntry=void 0,hashData.tail=hashData.head,hashData.size=0,hashData.freeList=-1,hashData.freeSize=0}},exports.ensureCapacity=function ensureCapacity(hashData,capacity){if(capacity<0)throw new RangeError;const existingCapacity=hashData.entries?hashData.entries.length:0;if(existingCapacity>=capacity)return existingCapacity;if(!hashData.buckets)return initializeHashData(hashData,capacity);const newCapacity=getPrime(capacity);return resizeHashData(hashData,getPrime(capacity)),newCapacity},exports.trimExcessEntries=function trimExcessEntries(hashData,capacity=hashData.size-hashData.freeSize){if(capacity<hashData.size)throw new RangeError;if(!hashData.buckets||!hashData.entries)return;const newCapacity=getPrime(capacity),existingEntries=hashData.entries;if(newCapacity>=(existingEntries?existingEntries.length:0))return;const oldSize=hashData.size;if(initializeHashData(hashData,newCapacity),!hashData.buckets||!hashData.entries)throw new Error;let newSize=0;for(let i=0;i<oldSize;i++){const hashCode=existingEntries[i].hashCode;if(hashCode>=0){const bucket=hashCode%newCapacity;hashData.entries[newSize]=existingEntries[i],hashData.entries[newSize].next=hashData.buckets[bucket]-1,hashData.buckets[bucket]=newSize+1,newSize++}}hashData.size=newSize,hashData.freeSize=0},exports.selectEntryKey=function selectEntryKey(entry){return entry.key},exports.selectEntryValue=function selectEntryValue(entry){return entry.value},exports.selectEntryEntry=function selectEntryEntry(entry){return[entry.key,entry.value]},exports.iterateEntries=function*iterateEntries(head,selector){let currentEntry=head;for(;currentEntry;){const skipNextEntry=currentEntry.skipNextEntry;currentEntry=currentEntry.nextEntry,skipNextEntry||currentEntry&&(yield selector(currentEntry))}},exports.forEachEntry=function forEachEntry(source,head,callback,thisArg){let currentEntry=head;for(;currentEntry;){const skipNextEntry=currentEntry.skipNextEntry;currentEntry=currentEntry.nextEntry,skipNextEntry||currentEntry&&callback.call(thisArg,currentEntry.value,currentEntry.key,source)}}}(0,module.exports),module.exports}();class HashSet{constructor(...args){let capacity,iterable,equaler;if(args.length>0){const arg0=args[0];if("number"==typeof arg0){if(!(Object.is(arg0,0|arg0)&&arg0>=0))throw new RangeError("Argument out of range: capacity");capacity=arg0,args.length>1&&(equaler=args[1])}else void 0===arg0||null!=arg0&&Symbol.iterator in Object(arg0)?(iterable=arg0,args.length>1&&(equaler=args[1])):equaler=arg0}if(null!=capacity||(capacity=0),null!=equaler||(equaler=Equaler.defaultEqualer),this._hashData=(0,esm_internal_collections_hash_1.createHashData)(equaler,capacity),iterable)for(const value of iterable)this.add(value)}get equaler(){return this._hashData.equaler}get size(){return this._hashData.size-this._hashData.freeSize}has(value){return(0,esm_internal_collections_hash_1.findEntryIndex)(this._hashData,value)>=0}add(value){return(0,esm_internal_collections_hash_1.insertEntry)(this._hashData,value,value),this}tryAdd(value){const oldSize=this.size;return(0,esm_internal_collections_hash_1.insertEntry)(this._hashData,value,value),this.size>oldSize}delete(value){return(0,esm_internal_collections_hash_1.deleteEntry)(this._hashData,value)}clear(){(0,esm_internal_collections_hash_1.clearEntries)(this._hashData)}ensureCapacity(capacity){if("number"!=typeof capacity)throw new TypeError("Number expected: capacity");if(!(Object.is(capacity,0|capacity)&&capacity>=0))throw new RangeError("Argument out of range: capacity");return(0,esm_internal_collections_hash_1.ensureCapacity)(this._hashData,capacity)}trimExcess(capacity){if(void 0!==capacity){if("number"!=typeof capacity)throw new TypeError("Number expected: capacity");if(!(Object.is(capacity,0|capacity)&&capacity>=0))throw new RangeError("Argument out of range: capacity")}(0,esm_internal_collections_hash_1.trimExcessEntries)(this._hashData,capacity)}keys(){return(0,esm_internal_collections_hash_1.iterateEntries)(this._hashData.head,esm_internal_collections_hash_1.selectEntryKey)}values(){return(0,esm_internal_collections_hash_1.iterateEntries)(this._hashData.head,esm_internal_collections_hash_1.selectEntryValue)}entries(){return(0,esm_internal_collections_hash_1.iterateEntries)(this._hashData.head,esm_internal_collections_hash_1.selectEntryEntry)}[Symbol.iterator](){return this.values()}forEach(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");(0,esm_internal_collections_hash_1.forEachEntry)(this,this._hashData.head,callback,thisArg)}get[Collection.size](){return this.size}[Collection.has](value){return this.has(value)}[Collection.add](value){this.add(value)}[Collection.delete](value){return this.delete(value)}[Collection.clear](){this.clear()}}var collections_multimap_dist_esm_a,collections_linkedlist_dist_esm_a,_b;collections_hashset_dist_esm_a=HashSet,Object.defineProperty(collections_hashset_dist_esm_a.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"HashSet"});class MultiMap{constructor(...args){var _b,_c;let capacity,iterable,options;this._size=0,!function isCapacityKeyEqualerValueEqualerOverload(args){const[arg0,arg1]=args;return"number"==typeof arg0&&(void 0===arg1||"object"==typeof arg1&&null!==arg1||"function"==typeof arg1)}(args)?(capacity=0,!function isIterableKeyEqualerValueEqualerOverload(args){const[arg0,arg1]=args;return(void 0===arg0||null!=arg0&&Symbol.iterator in Object(arg0))&&(void 0===arg1||"object"==typeof arg1&&null!==arg1||"function"==typeof arg1)}(args)?options={}:[iterable,options={}]=args):[capacity,options={}]=args;const keyEqualer=null!==(_b=null==options?void 0:options.keyEqualer)&&void 0!==_b?_b:Equaler.defaultEqualer,valueEqualer=null!==(_c=null==options?void 0:options.valueEqualer)&&void 0!==_c?_c:Equaler.defaultEqualer;if(this._map=new HashMap(capacity,keyEqualer),this._keyEqualer=keyEqualer,this._valueEqualer=valueEqualer,iterable)for(const[key,value]of iterable)this.add(key,value)}get keyEqualer(){return this._keyEqualer}get valueEqualer(){return this._valueEqualer}get size(){return this._size}has(key){return this._map.has(key)}hasValue(key,value){const values=this._map.get(key);return!!values&&values.has(value)}get(key){return this._map.get(key)}add(key,value){let values=this._map.get(key);values||(values=new HashSet(this._valueEqualer),this._map.set(key,values));const size=values.size;return values.add(value),this._size+=values.size-size,this}delete(key){const values=this._map.get(key);return values?(this._size-=values.size,this._map.delete(key),values.size):0}deleteValue(key,value){const values=this._map.get(key);if(values){const size=values.size;if(values.delete(value))return this._size+=values.size-size,values.size<=0&&this._map.delete(key),!0}return!1}clear(){this._map.clear(),this._size=0}ensureCapacity(capacity){return this._map.ensureCapacity(capacity)}trimExcess(capacity){this._map.trimExcess(capacity)}keys(){return this._map.keys()}*values(){for(const values of this._map.values())yield*values}*entries(){for(const[key,values]of this._map)for(const value of values)yield[key,value]}[Symbol.iterator](){return this.entries()}forEach(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");for(const[key,values]of this._map)for(const value of values)callback.call(thisArg,value,key,this)}get[ReadonlyKeyedMultiCollection.size](){return this.size}[ReadonlyKeyedMultiCollection.has](key){return this.has(key)}[ReadonlyKeyedMultiCollection.hasValue](key,value){return this.hasValue(key,value)}[ReadonlyKeyedMultiCollection.get](key){return this.get(key)}[ReadonlyKeyedMultiCollection.keys](){return this.keys()}[ReadonlyKeyedMultiCollection.values](){return this.values()}[KeyedMultiCollection.add](key,value){this.add(key,value)}[KeyedMultiCollection.delete](key){return this.delete(key)}[KeyedMultiCollection.deleteValue](key,value){return this.deleteValue(key,value)}[KeyedMultiCollection.clear](){this.clear()}}let setList,getPrevious,setPrevious,getNext,setNext;collections_multimap_dist_esm_a=MultiMap,Object.defineProperty(collections_multimap_dist_esm_a.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"MultiMap"});class LinkedListNode{constructor(value){this._list=void 0,this._previous=void 0,this._next=void 0,this.value=value}get list(){return this._list}get previous(){if(this._previous&&this._list&&this!==this._list.first)return this._previous}get next(){if(this._next&&this._list&&this._next!==this._list.first)return this._next}detachSelf(){return!!this._list&&this._list.deleteNode(this)}}collections_linkedlist_dist_esm_a=LinkedListNode,setList=(node,list)=>{node._list=list},getPrevious=node=>node._previous,setPrevious=(node,previous)=>{node._previous=previous},getNext=node=>node._next,setNext=(node,next)=>{node._next=next},Object.defineProperty(collections_linkedlist_dist_esm_a.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"LinkedListNode"});class LinkedList{constructor(...args){let iterable,equaler;if(this._size=0,this._head=void 0,args.length>0){const arg0=args[0];void 0===arg0||null!=arg0&&Symbol.iterator in Object(arg0)?(iterable=arg0,args.length>1&&(equaler=args[1])):equaler=arg0}if(null!=equaler||(equaler=Equaler.defaultEqualer),this._equaler="function"==typeof equaler?Equaler.create(equaler):equaler,iterable)for(const value of iterable)this.push(value)}get equaler(){return this._equaler}get first(){return this._head}get last(){if(this._head)return getPrevious(this._head)}get size(){return this._size}[Symbol.iterator](){return this.values()}*values(){for(const node of this.nodes())yield node.value}*nodes(){let node,next=this.first;for(;void 0!==next;)node=next,next=node.next,yield node}*drain(){for(const node of this.nodes())this.deleteNode(node),yield node.value}nodeOf(value,fromNode){if(null!=fromNode&&!(fromNode instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: fromNode");if(null!=fromNode&&fromNode.list!==this)throw new TypeError("Wrong list.");for(let node=null!=fromNode?fromNode:this.first;node;node=node.next)if(this._equaler.equals(node.value,value))return node}lastNodeOf(value,fromNode){if(null!=fromNode&&!(fromNode instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: fromNode");if(null!=fromNode&&fromNode.list!==this)throw new TypeError("Wrong list.");for(let node=null!=fromNode?fromNode:this.last;node;node=node.previous)if(this._equaler.equals(node.value,value))return node}find(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");let node,next=this.first;for(;void 0!==next;){node=next,next=node.next;const value=node.value;if(callback.call(thisArg,value,node,this))return value}}findLast(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");let node,prev=this.last;for(;void 0!==prev;){node=prev,prev=node.previous;const value=node.value;if(callback.call(thisArg,value,node,this))return value}}findNode(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");let node,next=this.first;for(;void 0!==next;)if(node=next,next=node.next,callback.call(thisArg,node.value,node,this))return node}findLastNode(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");let node,prev=this.last;for(;void 0!==prev;)if(node=prev,prev=node.previous,callback.call(thisArg,node.value,node,this))return node}has(value){return void 0!==this.nodeOf(value)}insertBefore(node,value){if(null!=node&&!(node instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: node");if(null!=node&&node.list!==this)throw new TypeError("Wrong list.");return this._insertNode(null!=node?node:void 0,new LinkedListNode(value),0)}insertNodeBefore(node,newNode){if(null!=node&&!(node instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: node");if(null!=node&&node.list!==this)throw new TypeError("Wrong list.");if(!(newNode instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: newNode");if(newNode.list)throw new Error("Node is already attached to a list.");this._insertNode(node||void 0,newNode,0)}insertAfter(node,value){if(null!=node&&!(node instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: node");if(null!=node&&node.list!==this)throw new TypeError("Wrong list.");return this._insertNode(node||void 0,new LinkedListNode(value),1)}insertNodeAfter(node,newNode){if(null!=node&&!(node instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: node");if(null!=node&&node.list!==this)throw new TypeError("Wrong list.");if(!(newNode instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: newNode");if(newNode.list)throw new Error("Node is already attached to a list.");this._insertNode(node||void 0,newNode,1)}push(value){return this._insertNode(void 0,new LinkedListNode(value),1)}pushNode(newNode){if(!(newNode instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: newNode");if(newNode.list)throw new Error("Node is already attached to a list.");this._insertNode(void 0,newNode,1)}pop(){const node=this.popNode();return node?node.value:void 0}popNode(){const node=this.last;if(this.deleteNode(node))return node}shift(){const node=this.shiftNode();return node?node.value:void 0}shiftNode(){const node=this.first;if(this.deleteNode(node))return node}unshift(value){return this._insertNode(void 0,new LinkedListNode(value),0)}unshiftNode(newNode){if(!(newNode instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: newNode");if(newNode.list)throw new Error("Node is already attached to a list.");this._insertNode(void 0,newNode,0)}delete(value){const node=this.nodeOf(value);if(node&&this.deleteNode(node))return node}deleteNode(node){if(null!=node&&!(node instanceof LinkedListNode))throw new TypeError("LinkedListNode expected: node");if(null!=node&&node.list!==this)throw new TypeError("Wrong list.");return!(null==node||!node.list)&&this._deleteNode(node)}deleteAll(predicate,thisArg){if("function"!=typeof predicate)throw new TypeError("Function expected: predicate");let count=0,node=this.first;for(;node;){const next=node.next;predicate.call(thisArg,node.value,node,this)&&node.list===this&&(this._deleteNode(node),++count),node=next}return count}clear(){for(;this.size>0;)this.deleteNode(this.last)}forEach(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");let node,next=this.first;for(;void 0!==next;)node=next,next=node.next,callback.call(thisArg,node.value,node,this)}map(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");const mappedList=new LinkedList;let node,next=this.first;for(;void 0!==next;){node=next,next=node.next;const mappedValue=callback.call(thisArg,node.value,node,this);mappedList.push(mappedValue)}return mappedList}filter(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");const mappedList=new LinkedList(this.equaler);let node,next=this.first;for(;void 0!==next;){node=next,next=node.next;const value=node.value;callback.call(thisArg,value,node,this)&&mappedList.push(value)}return mappedList}reduce(callback,initialValue){if("function"!=typeof callback)throw new TypeError("Function expected: callback");let node,hasInitialValue=arguments.length>1,result=initialValue,next=this.first;for(;void 0!==next;){node=next,next=node.next;const value=node.value;hasInitialValue?result=callback(result,value,node,this):(result=value,hasInitialValue=!0)}return result}reduceRight(callback,initialValue){if("function"!=typeof callback)throw new TypeError("Function expected: callback");let node,hasInitialValue=arguments.length>1,result=initialValue,prev=this.last;for(;void 0!==prev;){node=prev;const value=node.value;hasInitialValue?result=callback(result,value,node,this):(result=value,hasInitialValue=!0),prev=node.previous}return result}some(callback,thisArg){if(void 0!==callback&&"function"!=typeof callback)throw new TypeError("Function expected: callback");let node,next=this.first;for(;void 0!==next;)if(node=next,next=node.next,!callback||callback.call(thisArg,node.value,node,this))return!0;return!1}every(callback,thisArg){if("function"!=typeof callback)throw new TypeError("Function expected: callback");let node,hasMatch=!1,next=this.first;for(;void 0!==next;){if(node=next,next=node.next,!callback.call(thisArg,node.value,node,this))return!1;hasMatch=!0}return hasMatch}_deleteNode(node){return getNext(node)===node?this._head=void 0:(setPrevious(getNext(node),getPrevious(node)),setNext(getPrevious(node),getNext(node)),this._head===node&&(this._head=getNext(node))),setList(node,void 0),setPrevious(node,void 0),setNext(node,void 0),this._size--,!0}_insertNode(adjacentNode,newNode,position){if(setList(newNode,this),void 0===this._head)setNext(newNode,newNode),setPrevious(newNode,newNode),this._head=newNode;else switch(position){case 0:void 0===adjacentNode?(adjacentNode=this._head,this._head=newNode):adjacentNode===this._head&&(this._head=newNode),setNext(newNode,adjacentNode),setPrevious(newNode,getPrevious(adjacentNode)),setNext(getPrevious(adjacentNode),newNode),setPrevious(adjacentNode,newNode);break;case 1:void 0===adjacentNode&&(adjacentNode=getPrevious(this._head)),setPrevious(newNode,adjacentNode),setNext(newNode,getNext(adjacentNode)),setPrevious(getNext(adjacentNode),newNode),setNext(adjacentNode,newNode)}return this._size++,newNode}get[ReadonlyCollection.size](){return this.size}[ReadonlyCollection.has](value){return this.has(value)}[Collection.add](value){this.push(value)}[Collection.delete](value){return!!this.delete(value)}[Collection.clear](){this.clear()}}_b=LinkedList,Object.defineProperty(_b.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"LinkedList"});class CdtThreader{constructor(startTriangle,start,end){this.currentTriangle=startTriangle,this.start=start,this.end=end}get CurrentPiercedEdge(){return this.currentPiercedEdge}get CurrentTriangle(){return this.currentTriangle}*Triangles(){for(;this.MoveNext();)yield this.CurrentTriangle}FindFirstPiercedEdge(){const sign0=this.GetHyperplaneSign(this.currentTriangle.Sites.item0),sign1=this.GetHyperplaneSign(this.currentTriangle.Sites.item1);if(sign0!=sign1&&point_Point.getTriangleOrientation(this.end,this.currentTriangle.Sites.item0.point,this.currentTriangle.Sites.item1.point)==point_TriangleOrientation.Clockwise)return this.positiveSign=sign0,this.negativeSign=sign1,this.currentTriangle.TriEdges.item0;const sign2=this.GetHyperplaneSign(this.currentTriangle.Sites.item2);return sign1!=sign2&&point_Point.getTriangleOrientation(this.end,this.currentTriangle.Sites.item1.point,this.currentTriangle.Sites.item2.point)==point_TriangleOrientation.Clockwise?(this.positiveSign=sign1,this.negativeSign=sign2,this.currentTriangle.TriEdges.item1):(this.positiveSign=sign2,this.negativeSign=sign0,this.currentTriangle.TriEdges.item2)}static PointLocationForTriangle(p,triangle){let seenBoundary=!1;for(let i=0;i<3;i++){const area=point_Point.signedDoubledTriangleArea(p,triangle.Sites.getItem(i).point,triangle.Sites.getItem(i+1).point);if(area<-1*GeomConstants.distanceEpsilon)return PointLocation.Outside;area<GeomConstants.distanceEpsilon&&(seenBoundary=!0)}return seenBoundary?PointLocation.Boundary:PointLocation.Inside}FindNextPierced(){if(this.currentTriangle=this.currentPiercedEdge.GetOtherTriangle_T(this.currentTriangle),null==this.currentTriangle)return void(this.currentPiercedEdge=null);const i=this.currentTriangle.TriEdges.index(this.currentPiercedEdge);let j;const oppositeSite=this.currentTriangle.Sites.getItem(i+2),oppositeSiteSign=this.GetHyperplaneSign(oppositeSite);0==this.negativeSign?-1==oppositeSiteSign||0==oppositeSiteSign?(this.negativeSign=oppositeSiteSign,j=i+1):j=i+2:0==this.positiveSign?1==oppositeSiteSign||0==oppositeSiteSign?(this.positiveSign=oppositeSiteSign,j=i+2):j=i+1:oppositeSiteSign!=this.positiveSign?(this.negativeSign=oppositeSiteSign,j=i+1):(this.positiveSign=oppositeSiteSign,j=i+2),this.currentPiercedEdge=point_Point.signedDoubledTriangleArea(this.end,this.currentTriangle.Sites.getItem(j).point,this.currentTriangle.Sites.getItem(j+1).point)<-GeomConstants.distanceEpsilon?this.currentTriangle.TriEdges.getItem(j):null}GetHyperplaneSign(cdtSite){const area=point_Point.signedDoubledTriangleArea(this.start,cdtSite.point,this.end);return area>GeomConstants.distanceEpsilon?1:area<-1*GeomConstants.distanceEpsilon?-1:0}MoveNext(){return null==this.currentPiercedEdge?this.currentPiercedEdge=this.FindFirstPiercedEdge():this.FindNextPierced(),null!=this.currentPiercedEdge}}class CdtIntersections{constructor(metroGraphData,bundlingSettings){this.ComputeForcesForBundles=!1,this.metroGraphData=metroGraphData,this.bundlingSettings=bundlingSettings}EdgeIsLegal_(start,end,currentTriangle,obstaclesToIgnore){if(Cdt.PointIsInsideOfTriangle(end,currentTriangle))return!0;const threader=new CdtThreader(currentTriangle,start,end);for(;threader.MoveNext();){const piercedEdge=threader.CurrentPiercedEdge;if(piercedEdge.Constrained){const poly=piercedEdge.lowerSite.Owner;if(!obstaclesToIgnore.has(poly))return!1}}return!0}BundleAvoidsObstacles(v,u,vPosition,uPosition,upperBound,t){t.closestDist=new Array;const obstaclesToIgnore=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(v,u),closeObstacles=this.FindCloseObstaclesForBundle(u.CdtTriangle,uPosition,vPosition,obstaclesToIgnore,upperBound);if(null==closeObstacles)return!1;for(const item of closeObstacles){const dist=item[1];t.closestDist.push(dist)}return!0}FindCloseObstaclesForBundle(startTriangle,start,end,obstaclesToIgnore,upperBound){const obstacles=new Map,list=[];if(!this.ThreadLineSegmentThroughTriangles(startTriangle,start,end,obstaclesToIgnore,list))return null;if(!this.ComputeForcesForBundles&&!this.bundlingSettings.HighestQuality)return obstacles;const checkedSites=new HashSet;for(const t of list)for(const s of t.Sites){if(checkedSites.has(s))continue;checkedSites.add(s);const poly=s.Owner;if(obstaclesToIgnore.has(poly))continue;const pp=CdtIntersections.FindPolylinePoint(poly,s.point),t1=LineSegment.minDistBetweenLineSegments(pp.point,pp.nextOnPolyline.point,start,end),d12=t1.dist,par11=t1.parab,par12=t1.parcd,t2=LineSegment.minDistBetweenLineSegments(pp.point,pp.prevOnPolyline.point,start,end),d22=t2.dist,par21=t2.parab,par22=t2.parcd;let r1,r2,dist;if(d12<d22){if(dist=d12,dist>upperBound)continue;r1=pp.point.add(pp.nextOnPolyline.point.sub(pp.point).mul(par11)),r2=start.add(end.sub(start).mul(par12))}else{if(dist=d22,dist>upperBound)continue;r1=pp.point.add(pp.prevOnPolyline.point.sub(pp.point).mul(par21)),r2=start.add(end.sub(start).mul(par22))}obstacles.get(poly)||obstacles.set(poly,[r1,r2])}return obstacles}ThreadLineSegmentThroughTriangles(currentTriangle,start,end,obstaclesToIgnore,triangles){if(Cdt.PointIsInsideOfTriangle(end,currentTriangle))return triangles.push(currentTriangle),!0;const threader=new CdtThreader(currentTriangle,start,end);for(triangles.push(currentTriangle);threader.MoveNext();){triangles.push(threader.CurrentTriangle);const piercedEdge=threader.CurrentPiercedEdge;if(piercedEdge.Constrained){const poly=piercedEdge.lowerSite.Owner;if(!obstaclesToIgnore.has(poly))return!1}}return null!=threader.CurrentTriangle&&triangles.push(threader.CurrentTriangle),!0}static PointLocationInsideTriangle(p,triangle){let seenBoundary=!1;for(let i=0;i<3;i++){const area=point_Point.signedDoubledTriangleArea(p,triangle.Sites.getItem(i).point,triangle.Sites.getItem(i+1).point);if(area<-1*GeomConstants.distanceEpsilon)return PointLocation.Outside;area<GeomConstants.distanceEpsilon&&(seenBoundary=!0)}return seenBoundary?PointLocation.Boundary:PointLocation.Inside}static FindPolylinePoint(poly,point){for(const ppp of poly.polylinePoints())if(ppp.point.equal(point))return ppp;throw new Error("polyline point "+point+" not found")}EdgeIsLegal(v,u,vPosition,uPosition){const obstaclesToIgnore=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(v,u);return this.ThreadLineSegmentThroughTriangles(v.CdtTriangle,vPosition,uPosition,obstaclesToIgnore,[])}static closedeb(u,v){return u.Position.sub(new point_Point(360.561,428.416)).length<.1&&v.Position.sub(new point_Point(414.281,440.732)).length<.1}EdgeIsLegalSSPPS(v,u,obstaclesToIgnore){const start=v.Position,currentTriangle=v.CdtTriangle,end=u.Position;if(Cdt.PointIsInsideOfTriangle(end,currentTriangle))return!0;const threader=new CdtThreader(currentTriangle,start,end);for(;threader.MoveNext();){const piercedEdge=threader.CurrentPiercedEdge;if(piercedEdge.Constrained){const poly=piercedEdge.lowerSite.Owner;if(!obstaclesToIgnore.has(poly))return!1}}return!0}}class Intersections{constructor(metroGraphData,bundlingSettings,obstacleTree,obstaclesToIgnore){this.metroGraphData=metroGraphData,this.obstaclesToIgnoreLambda=obstaclesToIgnore,this.bundlingSettings=bundlingSettings,this.obstacleTree=obstacleTree}ObstaclesToIgnoreForBundle(u,v){return null!=u&&null!=v?uniteSets(this.obstaclesToIgnoreLambda(u),this.obstaclesToIgnoreLambda(v)):null==u&&null==v?new Set:null!=u?this.obstaclesToIgnoreLambda(u):this.obstaclesToIgnoreLambda(v)}HubAvoidsObstaclesSPNBA(node,center,upperBound,t){const md={minimalDistance:upperBound};return Intersections.IntersectCircleWithTree(this.obstacleTree,center,upperBound,this.obstaclesToIgnoreLambda(node),t.touchedObstacles,md)}HubAvoidsObstaclesPNS__(center,upperBound,obstaclesToIgnore){const t={touchedObstacles:Array()};return this.HubAvoidsObstaclesPNSTT(center,upperBound,obstaclesToIgnore,t,{minimalDistance:0})}GetMinimalDistanceToObstacles(node,nodePosition,upperBound){const touchedObstacles=new Array,t={minimalDistance:upperBound};return Intersections.IntersectCircleWithTree(this.obstacleTree,nodePosition,upperBound,this.obstaclesToIgnoreLambda(node),touchedObstacles,t)?t.minimalDistance:0}HubAvoidsObstaclesPNSTT(center,upperBound,obstaclesToIgnore,t,m){return t.touchedObstacles=new Array,m.minimalDistance=upperBound,Intersections.IntersectCircleWithTree(this.obstacleTree,center,upperBound,obstaclesToIgnore,t.touchedObstacles,m)}static IntersectCircleWithTree(node,center,radius,obstaclesToIgnore,touchedObstacles,t){if(!node.irect.contains_point_radius(center,radius))return!0;if(null==node.UserData){let res=Intersections.IntersectCircleWithTree(node.Left,center,radius,obstaclesToIgnore,touchedObstacles,t);if(!res)return!1;if(res=Intersections.IntersectCircleWithTree(node.Right,center,radius,obstaclesToIgnore,touchedObstacles,t),!res)return!1}else{const obstacle=node.UserData;if(obstaclesToIgnore.has(obstacle))return!0;if(Curve.PointRelativeToCurveLocation(center,obstacle)!=PointLocation.Outside)return Intersections.containingPoly=obstacle,!1;const touchPoint=obstacle.value(obstacle.closestParameter(center)),dist=touchPoint.sub(center).length;dist<=radius&&touchedObstacles.push([obstacle,touchPoint]),t.minimalDistance=Math.min(dist,t.minimalDistance)}return!0}static Create4gon(apex,baseCenter,width1,width2){let norm=baseCenter.sub(apex).normalize();return norm=new point_Point(norm.y,-1*norm.x),Polyline.mkFromPoints([apex.add(norm.mul(width1/2)),apex.sub(norm.mul(width1/2)),baseCenter.sub(norm.mul(width2/2)),baseCenter.add(norm.mul(width2/2))])}}class Metroline{constructor(polyline,width,sourceAndTargetLoosePolys,index){this.Width=width,this.Polyline=polyline,this.sourceAndTargetLoosePolylines=sourceAndTargetLoosePolys,this.Index=index}UpdateLengths(){let l=0;for(let p=this.Polyline.startPoint;null!=p.next;p=p.next)l+=p.next.point.sub(p.point).length;this.Length=l,this.IdealLength=this.Polyline.end.sub(this.Polyline.start).length}}class MetroNodeInfo{constructor(metroline,station,polyPoint){this.metroline=metroline,this.station=station,this.polyPoint=polyPoint}get Metroline(){return this.metroline}get PolyPoint(){return this.polyPoint}}class Station{constructor(serialNumber,isRealNode,position){this.Radius=0,this.BundleBases=new Map,this.MetroNodeInfos=new Array,this._cachedIdealRadius=0,this.SerialNumber=serialNumber,this.IsReal=isRealNode,this.Position=position}debStop(){return 28==this.SerialNumber&&this.Position.sub(new point_Point(841.2662778763244,303.3817005853006)).length<.001}get Position(){return this._Position}set Position(value){this._Position=value}getELP(){return this.EnterableLoosePolylines}setELP(s){this.EnterableLoosePolylines=s}addEL(p){this.EnterableLoosePolylines.add(p)}static less(a,b){return a.SerialNumber<b.SerialNumber}static greater(a,b){return a.SerialNumber>b.SerialNumber}get cachedIdealRadius(){return this._cachedIdealRadius}set cachedIdealRadius(value){this._cachedIdealRadius=value}AddEnterableLoosePolyline(poly){null==this.EnterableLoosePolylines&&(this.EnterableLoosePolylines=new Set),this.EnterableLoosePolylines.add(poly)}AddEnterableTightPolyline(poly){null==this.EnterableTightPolylines&&(this.EnterableTightPolylines=new Set),this.EnterableTightPolylines.add(poly)}}class StationEdgeInfo{constructor(){this.Width=0,this.Metrolines=new Array,this.cachedBundleCost=0}get Count(){return this.Metrolines.length}}class HubRadiiCalculator{constructor(metroGraphData,bundlingSettings){this.metroGraphData=metroGraphData,this.bundlingSettings=bundlingSettings}CreateNodeRadii(){for(const v of this.metroGraphData.VirtualStations())v.Radius=0,v.cachedIdealRadius=HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,v);this.GrowHubs(!1),this.GrowHubs(!0);for(const v of this.metroGraphData.VirtualStations())v.Radius=Math.max(v.Radius,this.bundlingSettings.MinHubRadius)}GrowHubs(useHalfEdgesAsIdealR){const queue=new GenericBinaryHeapPriorityQueue(compareNumbers);for(const v of this.metroGraphData.VirtualStations())queue.Enqueue(v,-this.CalculatePotential(v,useHalfEdgesAsIdealR));let progress=!1;for(;!queue.IsEmpty();){const t={priority:0},v=queue.DequeueAndGetPriority(t);if(t.priority>=0)break;this.TryGrowHub(v,useHalfEdgesAsIdealR)&&(queue.Enqueue(v,-this.CalculatePotential(v,useHalfEdgesAsIdealR)),progress=!0)}return progress}TryGrowHub(v,useHalfEdgesAsIdealR){const allowedRadius=this.CalculateAllowedHubRadius(v);if(v.Radius>=allowedRadius)return!1;const idealR=useHalfEdgesAsIdealR?HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings,v):v.cachedIdealRadius;if(v.Radius>=idealR)return!1;let delta=.05*(idealR-v.Radius);delta<1&&(delta=1);const newR=Math.min(v.Radius+delta,allowedRadius);return!(newR<=v.Radius)&&(v.Radius=newR,!0)}CalculatePotential(v,useHalfEdgesAsIdealR){const idealR=useHalfEdgesAsIdealR?HubRadiiCalculator.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings,v):v.cachedIdealRadius;return idealR<=v.Radius?0:(idealR-v.Radius)/idealR}CalculateAllowedHubRadius(node){let r=this.bundlingSettings.MaxHubRadius;for(const adj of node.Neighbors){const dist=adj.Position.sub(node.Position).length;r=Math.min(r,dist/1.05-adj.Radius)}const minimalDistance=this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(node,node.Position,r);return minimalDistance<r&&(r=minimalDistance-.001),Math.max(r,.1)}static CalculateIdealHubRadius(metroGraphData,bundlingSettings,node){let r=1;for(const adj of node.Neighbors){const nr=metroGraphData.GetWidthSSN(adj,node,bundlingSettings.EdgeSeparation)/2+bundlingSettings.EdgeSeparation;r=Math.max(r,nr)}return r=Math.min(r,2*bundlingSettings.MaxHubRadius),r}static CalculateIdealHubRadiusWithNeighborsMBS(metroGraphData,bundlingSettings,node){return HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBNP(metroGraphData,bundlingSettings,node,node.Position)}static CalculateIdealHubRadiusWithNeighborsMBNP(metroGraphData,bundlingSettings,node,newPosition){let r=HubRadiiCalculator.CalculateIdealHubRadius(metroGraphData,bundlingSettings,node);if(node.Neighbors.length>1){const adjNodes=node.Neighbors;for(let i=0;i<adjNodes.length;i++){const adj=adjNodes[i],nextAdj=adjNodes[(i+1)%adjNodes.length];r=Math.max(r,HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles(r,node,newPosition,adj,nextAdj,metroGraphData,bundlingSettings))}}return r=Math.min(r,2*bundlingSettings.MaxHubRadius),r}static CalculateIdealHubRadiusWithAdjacentEdges(bundlingSettings,node){let r=bundlingSettings.MaxHubRadius;for(const adj of node.Neighbors)r=Math.min(r,node.Position.sub(adj.Position).length/2);return r}static GetMinRadiusForTwoAdjacentBundles(r,node,nodePosition,adj0,adj1,metroGraphData,bundlingSettings){const w0=metroGraphData.GetWidthSSN(node,adj0,bundlingSettings.EdgeSeparation),w1=metroGraphData.GetWidthSSN(node,adj1,bundlingSettings.EdgeSeparation);return HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(r,nodePosition,adj0.Position,adj1.Position,w0,w1,bundlingSettings)}static GetMinRadiusForTwoAdjacentBundlesNPPPNNB(r,a,b,c,widthAB,widthAC,bundlingSettings){if(widthAB<GeomConstants.distanceEpsilon||widthAC<GeomConstants.distanceEpsilon)return r;let angle=point_Point.anglePCP(b,a,c);if(angle=Math.min(angle,2*Math.PI-angle),angle<GeomConstants.distanceEpsilon)return 2*bundlingSettings.MaxHubRadius;if(angle>=Math.PI/2)return 1.05*r;const sina=Math.sin(angle),cosa=Math.cos(angle),aa=widthAB/(4*sina),bb=widthAC/(4*sina);let d=2*Math.sqrt(aa*aa+(bb*bb+aa*(bb*cosa)*2));return d=Math.min(d,2*bundlingSettings.MaxHubRadius),d=Math.max(d,r),d}}class IntersectionCache{constructor(metroGraphData,bundlingSettings,costCalculator,cdt){this.metroGraphData=metroGraphData,this.bundlingSettings=bundlingSettings,this.costCalculator=costCalculator,this.cdt=cdt}InitializeCostCache(){for(const v of this.metroGraphData.VirtualStations())v.cachedIdealRadius=HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,v),v.cachedRadiusCost=this.costCalculator.RadiusCost(v,v.Position),v.cachedBundleCost=0;for(const edge of this.metroGraphData.VirtualEdges()){const v=edge[0],u=edge[1],edgeInfo=this.metroGraphData.GetIjInfo(v,u);edgeInfo.cachedBundleCost=this.costCalculator.BundleCost(v,u,v.Position),v.cachedBundleCost+=edgeInfo.cachedBundleCost,u.cachedBundleCost+=edgeInfo.cachedBundleCost}}UpdateCostCache(node){const cdtTree=this.cdt.GetCdtTree();node.CdtTriangle=cdtTree.FirstHitNodeWithPredicate(node.Position,IntersectionCache.testPointInside).UserData,node.cachedIdealRadius=HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,node),node.cachedRadiusCost=this.costCalculator.RadiusCost(node,node.Position),node.cachedBundleCost=0;for(const adj of node.Neighbors){adj.IsReal||(adj.cachedIdealRadius=HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,adj),adj.cachedRadiusCost=this.costCalculator.RadiusCost(adj,adj.Position));const edgeInfo=this.metroGraphData.GetIjInfo(node,adj);adj.cachedBundleCost-=edgeInfo.cachedBundleCost,edgeInfo.cachedBundleCost=this.costCalculator.BundleCost(node,adj,node.Position),node.cachedBundleCost+=edgeInfo.cachedBundleCost,adj.cachedBundleCost+=edgeInfo.cachedBundleCost}}static testPointInside(pnt,t){return Cdt.PointIsInsideOfTriangle(pnt,t)?HitTestBehavior.Stop:HitTestBehavior.Continue}}class TupleMap{constructor(){this.mainMap=new Map}get isEmpty(){return 0==this.mainMap.size||this.everyMapIsEmpty()}everyMapIsEmpty(){for(const b of this.mainMap.values())if(b.size)return!1;return!0}get(a,b){const m=this.mainMap.get(a);if(m)return m.get(b)}has(a,b){const m=this.mainMap.get(a);return!!m&&m.has(b)}set(a,b,c){let m=this.mainMap.get(a);m||(m=new Map,this.mainMap.set(a,m)),m.set(b,c)}*[Symbol.iterator](){for(const[a,m]of this.mainMap)for(const[b,c]of m)yield[a,b,c]}*keys(){for(const[a,m]of this.mainMap)for(const[b]of m)yield[a,b]}}class MetroGraphData{constructor(regularEdges,looseTree,tightTree,bundlingSettings,cdt,edgeLooseEnterable,edgeTightEnterable,loosePolylineOfPort){this.cachedEnterableLooseForEnd=new PointMap,this.regularEdges=regularEdges,this.Cdt=null!=cdt?cdt:BundleRouter.CreateConstrainedDelaunayTriangulation(looseTree),this.EdgeLooseEnterable=edgeLooseEnterable,this.EdgeTightEnterable=edgeTightEnterable,this.LoosePolylineOfPort=loosePolylineOfPort,this.looseIntersections=new Intersections(this,bundlingSettings,looseTree,(station=>station.getELP())),this.tightIntersections=new Intersections(this,bundlingSettings,tightTree,(station=>station.EnterableTightPolylines)),this.cdtIntersections=new CdtIntersections(this,bundlingSettings),this.Initialize(!1)}get Ink(){return this.ink}get Edges(){return this.regularEdges}VirtualStations(){return Array.from(this.Stations).filter((s=>!s.IsReal))}get Metrolines(){return this.metrolines}get LooseTree(){return this.looseIntersections.obstacleTree}get TightTree(){return this.tightIntersections.obstacleTree}*VirtualEdges(){for(const k of this.edgeInfoDictionary.keys())yield k}RealEdgeCount(u,v){const couple=u.SerialNumber<v.SerialNumber?[u,v]:[v,u],cw=this.edgeInfoDictionary.get(couple[0],couple[1]);return cw?cw.Count:0}MetroNodeInfosOfNode(node){return node.MetroNodeInfos}GetIjInfo(u,v){const couple=u.SerialNumber<v.SerialNumber?[u,v]:[v,u];return this.edgeInfoDictionary.get(couple[0],couple[1])}MoveNode(node,newPosition){const oldPosition=node.Position;this.PointToStations.deleteP(oldPosition),this.PointToStations.set(newPosition,node),node.Position=newPosition;for(const metroNodeInfo of this.MetroNodeInfosOfNode(node))metroNodeInfo.PolyPoint.point=newPosition;for(const e of this.MetroNodeInfosOfNode(node)){const metroLine=e.Metroline,prev=e.PolyPoint.prev.point,succ=e.PolyPoint.next.point;metroLine.Length+=succ.sub(newPosition).length+prev.sub(newPosition).length-succ.sub(oldPosition).length-prev.sub(oldPosition).length}for(const adj of node.Neighbors)this.ink+=newPosition.sub(adj.Position).length-oldPosition.sub(adj.Position).length;this.SortNeighbors(node);for(const adj of node.Neighbors)this.SortNeighbors(adj)}GetWidthSSN(u,v,edgeSeparation){const couple=u.SerialNumber<v.SerialNumber?[u,v]:[v,u],cw=this.edgeInfoDictionary.get(couple[0],couple[1]);return cw?cw.Width+(cw.Count-1)*edgeSeparation:0}GetWidthAN(metrolines,edgeSeparation){let width=0;for(const metroline of metrolines)width+=metroline.Width;const count=metrolines.length;return width+=count>0?(count-1)*edgeSeparation:0,width}Initialize(initTightTree){this.SimplifyRegularEdges(),this.InitializeStationData(),this.InitializeEdgeData(),this.InitializeVirtualGraph(),this.InitializeEdgeNodeInfo(initTightTree),this.InitializeCdtInfo()}SimplifyRegularEdges(){for(const edge of this.regularEdges)this.SimplifyRegularEdge(edge)}SimplifyRegularEdge(edge){const polyline=edge.curve,stack=new lib_src.B,seen=new PointSet;for(let p=polyline.endPoint;null!=p;p=p.prev){const v=p.point;if(seen.has(p.point)){let pp=p.next;for(;;){const u=stack.top;if(u.equal(v))break;seen.delete(u),stack.pop(),pp=pp.next}pp.prev=p.prev,pp.prev.next=pp}else stack.push(v),seen.add(v)}}InitializeStationData(){this.Stations=[],this.PointToStations=new PointMap;for(const edge of this.regularEdges){const poly=edge.curve;this.ProcessPolylinePoints(poly)}}ProcessPolylinePoints(poly){let p=poly.startPoint;for(this.RegisterStation(p,!0),p=p.next;p!=poly.endPoint;p=p.next)this.RegisterStation(p,!1);this.RegisterStation(p,!0)}RegisterStation(pp,isRealNode){if(!this.PointToStations.has(pp.point)){const station=new Station(this.Stations.length,isRealNode,pp.point);this.PointToStations.set(pp.point,station),this.Stations.push(station)}}InitializeEdgeData(){this.metrolines=new Array;for(let i=0;i<this.regularEdges.length;i++){const geomEdge=this.regularEdges[i];this.InitEdgeData(geomEdge,i)}}InitEdgeData(geomEdge,index){const metroEdge=new Metroline(geomEdge.curve,geomEdge.lineWidth,this.EdgeSourceAndTargetFunc(geomEdge),index);this.metrolines.push(metroEdge),this.PointToStations.get(metroEdge.Polyline.start).BoundaryCurve=geomEdge.sourcePort.Curve,this.PointToStations.get(metroEdge.Polyline.end).BoundaryCurve=geomEdge.targetPort.Curve}EdgeSourceAndTargetFunc(geomEdge){return()=>[this.LoosePolylineOfPort(geomEdge.sourcePort),this.LoosePolylineOfPort(geomEdge.targetPort)]}InitializeVirtualGraph(){const neighbors=new Map;for(const metroline of this.metrolines){let v,u=this.PointToStations.get(metroline.Polyline.start);for(let p=metroline.Polyline.startPoint;null!=p.next;p=p.next,u=v)v=this.PointToStations.get(p.next.point),addToMap(neighbors,u,v),addToMap(neighbors,v,u)}for(const s of this.Stations)s.Neighbors=Array.from(neighbors.get(s))}GetUnorderedIjInfo(i,j){return i.SerialNumber<j.SerialNumber?this.GetCreateOrderedIjInfo(i,j):this.GetCreateOrderedIjInfo(j,i)}static closedeb(u,v){return u.Position.sub(new point_Point(360.561,428.416)).length<.1&&v.Position.sub(new point_Point(414.281,440.732)).length<.1}GetCreateOrderedIjInfo(i,j){let cw=this.edgeInfoDictionary.get(i,j);return cw||(cw=new StationEdgeInfo,this.edgeInfoDictionary.set(i,j,cw),cw)}InitializeEdgeNodeInfo(initTightTree){this.edgeInfoDictionary=new TupleMap,this.InitAllMetroNodeInfos(initTightTree),this.SortAllNeighbors(),this.InitEdgeIjInfos(),this.ink=0;for(const edge of this.VirtualEdges())this.ink+=edge[0].Position.sub(edge[1].Position).length}InitAllMetroNodeInfos(initTightTree){for(let i=0;i<this.metrolines.length;i++){const metroline=this.metrolines[i];this.InitMetroNodeInfos(metroline),this.InitNodeEnterableLoosePolylines(metroline,this.regularEdges[i]),initTightTree&&this.InitNodeEnterableTightPolylines(metroline,this.regularEdges[i]),metroline.UpdateLengths()}}InitMetroNodeInfos(metroline){for(let pp=metroline.Polyline.startPoint;null!=pp;pp=pp.next){const station=this.PointToStations.get(pp.point);station.MetroNodeInfos.push(new MetroNodeInfo(metroline,station,pp))}}InitNodeEnterableLoosePolylines(metroline,regularEdge){const metrolineEnterable=null!=this.EdgeLooseEnterable?this.EdgeLooseEnterable.get(regularEdge):new Set;for(let p=metroline.Polyline.startPoint.next;null!=p&&null!=p.next;p=p.next){const v=this.PointToStations.get(p.point);null!=v.getELP()?v.setELP(setIntersection(v.getELP(),metrolineEnterable)):v.setELP(new Set(metrolineEnterable))}this.AddLooseEnterableForMetrolineStartEndPoints(metroline)}AddLooseEnterableForMetrolineStartEndPoints(metroline){this.AddLooseEnterableForEnd(metroline.Polyline.start),this.AddLooseEnterableForEnd(metroline.Polyline.end)}AddTightEnterableForMetrolineStartEndPoints(metroline){this.AddTightEnterableForEnd(metroline.Polyline.start),this.AddTightEnterableForEnd(metroline.Polyline.end)}AddLooseEnterableForEnd(point){const station=this.PointToStations.get(point);if(this.cachedEnterableLooseForEnd.has(point))station.setELP(this.cachedEnterableLooseForEnd.get(point));else{for(const poly of this.LooseTree.AllHitItems_(point))Curve.PointRelativeToCurveLocation(point,poly)==PointLocation.Inside&&station.AddEnterableLoosePolyline(poly);this.cachedEnterableLooseForEnd.set(point,station.getELP())}}AddTightEnterableForEnd(point){const station=this.PointToStations.get(point);for(const poly of this.TightTree.AllHitItems_(point))Curve.PointRelativeToCurveLocation(point,poly)==PointLocation.Inside&&station.AddEnterableTightPolyline(poly)}InitNodeEnterableTightPolylines(metroline,regularEdge){const metrolineEnterable=null!=this.EdgeTightEnterable?this.EdgeTightEnterable.get(regularEdge):new Set;for(let p=metroline.Polyline.startPoint.next;null!=p&&null!=p.next;p=p.next){const v=this.PointToStations.get(p.point),nodeEnterable=v.EnterableTightPolylines;v.EnterableTightPolylines=null!=nodeEnterable?setIntersection(nodeEnterable,metrolineEnterable):new Set(metrolineEnterable)}this.AddTightEnterableForMetrolineStartEndPoints(metroline)}SortAllNeighbors(){for(const station of this.Stations)this.SortNeighbors(station)}SortNeighbors(station){if(station.Neighbors.length<=2)return;const pivot=station.Neighbors[0].Position,center=station.Position;station.Neighbors.sort(((u,v)=>getOrientationOf3Vectors(pivot.sub(center),u.Position.sub(center),v.Position.sub(center))))}InitEdgeIjInfos(){for(const metroLine of this.metrolines){const poly=metroLine.Polyline;let v,u=this.PointToStations.get(poly.start);for(let p=metroLine.Polyline.startPoint;null!=p.next;p=p.next,u=v){v=this.PointToStations.get(p.next.point);const info=this.GetUnorderedIjInfo(u,v);info.Width+=metroLine.Width,info.Metrolines.push(metroLine)}}}InitializeCdtInfo(){const cdtTree=this.Cdt.GetCdtTree();for(const station of this.Stations)station.CdtTriangle=cdtTree.FirstHitNodeWithPredicate(station.Position,IntersectionCache.testPointInside).UserData}PointIsAcceptableForEdge(metroline,point){if(null==this.LoosePolylineOfPort)return!0;const polys=metroline.sourceAndTargetLoosePolylines();return Curve.PointRelativeToCurveLocation(point,polys[0])==PointLocation.Outside&&Curve.PointRelativeToCurveLocation(point,polys[1])==PointLocation.Outside}}function getOrientationOf3Vectors(v0,v1,v2){v0=v0.mul(1e3),v1=v1.mul(1e3),v2=v2.mul(1e3);const xp2=point_Point.crossProduct(v0,v2),dotp2=v0.dot(v2),xp1=point_Point.crossProduct(v0,v1),dotp1=v0.dot(v1);return closeDistEps(xp1,0)&&GreaterOrEqual(dotp1,0)?closeDistEps(xp2,0)&&GreaterOrEqual(dotp2,0)?0:1:closeDistEps(xp2,0)&&GreaterOrEqual(dotp2,0)?-1:closeDistEps(xp1,0)||closeDistEps(xp2,0)||xp1*xp2>0?compareNumbersDistEps(point_Point.crossProduct(v2,v1),0):-compareNumbersDistEps(Math.sign(xp1),0)}function GreaterOrEqual(numberA,numberB){return compareNumbersDistEps(numberA,numberB)>=0}class CostCalculator{constructor(metroGraphData,bundlingSettings){this.metroGraphData=metroGraphData,this.bundlingSettings=bundlingSettings}static InkError(oldInk,newInk,bundlingSettings){return(oldInk-newInk)*bundlingSettings.InkImportance}static PathLengthsError(oldLength,newLength,idealLength,bundlingSettings){return(oldLength-newLength)*(bundlingSettings.PathLengthImportance/idealLength)}static RError(idealR,nowR,bundlingSettings){if(idealR<=nowR)return 0;return bundlingSettings.HubRepulsionImportance*((1-nowR/idealR)*(idealR-nowR))}static BundleError(idealWidth,nowWidth,bundlingSettings){if(idealWidth<=nowWidth)return 0;return bundlingSettings.BundleRepulsionImportance*((1-nowWidth/idealWidth)*(idealWidth-nowWidth))}static Cost(metroGraphData,bundlingSettings){let cost=bundlingSettings.InkImportance*metroGraphData.Ink;for(const metroline of metroGraphData.Metrolines)cost+=bundlingSettings.PathLengthImportance*metroline.Length/metroline.IdealLength;return cost+=this.CostOfForces(metroGraphData),cost}static CostOfForces(metroGraphData){let cost=0;for(const v of metroGraphData.VirtualStations())cost+=v.cachedRadiusCost;for(const edge of metroGraphData.VirtualEdges()){const v=edge[0],u=edge[1];cost+=metroGraphData.GetIjInfo(v,u).cachedBundleCost}return cost}InkGain(node,newPosition){const oldInk=this.metroGraphData.Ink;let newInk=this.metroGraphData.Ink;for(const adj of node.Neighbors){const adjPosition=adj.Position;newInk-=adjPosition.sub(node.Position).length,newInk+=adjPosition.sub(newPosition).length}return CostCalculator.InkError(oldInk,newInk,this.bundlingSettings)}PathLengthsGain(node,newPosition){let gain=0;for(const e of this.metroGraphData.MetroNodeInfosOfNode(node)){const oldLength=e.Metroline.Length,prev=e.PolyPoint.prev.point,next=e.PolyPoint.next.point,newLength=e.Metroline.Length+next.sub(newPosition).length+prev.sub(newPosition).length-next.sub(node.Position).length-prev.sub(node.Position).length;gain+=CostCalculator.PathLengthsError(oldLength,newLength,e.Metroline.IdealLength,this.bundlingSettings)}return gain}RadiusGain(node,newPosition){let gain=0;return gain+=node.cachedRadiusCost,gain-=this.RadiusCost(node,newPosition),gain}RadiusCost(node,newPosition){let idealR;idealR=point_Point.closeDistEps(node.Position,newPosition)?node.cachedIdealRadius:HubRadiiCalculator.CalculateIdealHubRadiusWithNeighborsMBNP(this.metroGraphData,this.bundlingSettings,node,newPosition);const t={touchedObstacles:[]};if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(node,newPosition,idealR,t))return CostCalculator.Inf;let cost=0;for(const d of t.touchedObstacles){const dist=d[1].sub(newPosition).length;cost+=CostCalculator.RError(idealR,dist,this.bundlingSettings)}return cost}BundleGain(node,newPosition){let gain=node.cachedBundleCost;for(const adj of node.Neighbors){const lgain=this.BundleCost(node,adj,newPosition);if(GreaterOrEqual(lgain,CostCalculator.Inf))return-CostCalculator.Inf;gain-=lgain}return gain}BundleCost(node,adj,newPosition){const idealWidth=this.metroGraphData.GetWidthSSN(node,adj,this.bundlingSettings.EdgeSeparation),t={closestDist:[]};if(!this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(node,adj,newPosition,adj.Position,idealWidth,t))return CostCalculator.Inf;let cost=0;for(const pair of t.closestDist){const dist=pair[0].sub(pair[1]).length;cost+=CostCalculator.BundleError(idealWidth/2,dist,this.bundlingSettings)}return cost}}CostCalculator.Inf=1e9;class FlipSwitcher{constructor(metroGraphData){this.polylineToEdgeGeom=new Map,this.pathsThroughPoints=new PointMap,this.interestingPoints=new PointSet,this.metroGraphData=metroGraphData}get Polylines(){return Array.from(this.polylineToEdgeGeom.keys())}Run(){this.Init(),this.SwitchFlips()}Init(){for(const e of this.metroGraphData.Edges)this.polylineToEdgeGeom.set(e.curve,e);for(const poly of this.Polylines)this.RegisterPolylinePointInPathsThrough(poly.polylinePoints())}RegisterPolylinePointInPathsThrough(points){for(const pp of points)this.RegisterPolylinePointInPathsThroughP(pp)}RegisterPolylinePointInPathsThroughP(pp){!function addToPointMap(pointMap,point,pp){let s=pointMap.get(point);s||(s=new Set,pointMap.set(point,s));s.add(pp)}(this.pathsThroughPoints,pp.point,pp)}UnregisterPolylinePointsInPathsThrough(points){for(const pp of points)this.UnregisterPolylinePointInPathsThrough(pp)}UnregisterPolylinePointInPathsThrough(pp){!function removeFromPointMap(pathsThroughPoints,point,pp){const s=pathsThroughPoints.get(point);if(!s)return;s.delete(pp),0==s.size&&pathsThroughPoints.deleteP(point)}(this.pathsThroughPoints,pp.point,pp)}SwitchFlips(){const queued=new Set(this.Polylines),queue=new src.o;for(const e of this.Polylines)queue.enqueue(e);for(;queue.length>0;){const initialPolyline=queue.dequeue();queued.delete(initialPolyline);const changedPolyline=this.ProcessPolyline(initialPolyline);null!=changedPolyline&&(queued.has(initialPolyline)||(queued.add(initialPolyline),queue.enqueue(initialPolyline)),queued.has(changedPolyline)||(queued.add(changedPolyline),queue.enqueue(changedPolyline)))}}ProcessPolyline(polyline){const departed=new Map;for(let pp=polyline.startPoint.next;null!=pp;pp=pp.next){this.FillDepartedPolylinePoints(pp,departed);for(const polyPoint of this.pathsThroughPoints.get(pp.point)){const departingPP=departed.get(polyPoint.polyline);if(departingPP){if(this.ProcessFlip(pp,departingPP))return polyPoint.polyline;departed.delete(polyPoint.polyline)}}}return null}FillDepartedPolylinePoints(pp,departed){const prevPoint=pp.prev.point;for(const polyPoint of this.pathsThroughPoints.get(prevPoint))this.IsNeighborOnTheSamePolyline(polyPoint,pp)||departed.has(polyPoint.polyline)||departed.set(polyPoint.polyline,polyPoint)}ProcessFlip(flipStartPP,flipEndPP){const polyA=flipStartPP.polyline,polyB=flipEndPP.polyline,flipStart=flipStartPP.point,flipEnd=flipEndPP.point,ea=this.polylineToEdgeGeom.get(polyA),eb=this.polylineToEdgeGeom.get(polyB);if(ea.lineWidth!=eb.lineWidth||null==this.metroGraphData.EdgeLooseEnterable||!setsAreEqual(this.metroGraphData.EdgeLooseEnterable.get(ea),this.metroGraphData.EdgeLooseEnterable.get(eb)))return!1;let pts=this.FindPointsOnPolyline(polyA,flipStart,flipEnd);const aFirst=pts[0],aLast=pts[1],forwardOrderA=pts[2];pts=this.FindPointsOnPolyline(polyB,flipStart,flipEnd);const bFirst=pts[0],bLast=pts[1],forwardOrderB=pts[2],rel1=this.FindRelationOnFirstPoint(aFirst,bFirst,forwardOrderA,forwardOrderB),rel2=this.FindRelationOnLastPoint(aLast,bLast,forwardOrderA,forwardOrderB);return(2==rel1||2==rel2)&&(1!=rel1&&1!=rel2&&(this.UnregisterPolylinePointsInPathsThrough(polyA.polylinePoints()),this.UnregisterPolylinePointsInPathsThrough(polyB.polylinePoints()),this.Swap(aFirst,bFirst,aLast,bLast,forwardOrderA,forwardOrderB),this.RegisterPolylinePointInPathsThrough(polyA.polylinePoints()),this.RegisterPolylinePointInPathsThrough(polyB.polylinePoints()),this.RegisterInterestingPoint(aFirst.point),this.RegisterInterestingPoint(aLast.point),this.numberOfReducedCrossings++,!0))}FindPointsOnPolyline(polyline,first,last){let ppFirst,ppLast;for(let pp=polyline.startPoint;null!=pp;pp=pp.next)if(null==ppFirst)if(pp.point.equal(first)){if(null!=ppLast)return[pp,ppLast,!1];ppFirst=pp}else null==ppLast&&pp.point.equal(last)&&(ppLast=pp);else if(pp.point.equal(last))return[ppFirst,pp,!0]}PolylinePointsAreInForwardOrder(u,v){for(let p=u;null!=p;p=p.next)if(p==v)return!0;return!1}Next(p,forwardOrder){return forwardOrder?p.next:p.prev}Prev(p,forwardOrder){return forwardOrder?p.prev:p.next}FindRelationOnFirstPoint(aFirst,bFirst,forwardOrderA,forwardOrderB){const a0=aFirst,b0=bFirst;for(;;){const prevA=this.Prev(aFirst,forwardOrderA),prevB=this.Prev(bFirst,forwardOrderB);if(null==prevA||null==prevB)return 0;if(!prevA.point.equal(prevB.point))break;aFirst=prevA,bFirst=prevB}return this.PolylinesIntersect(a0,b0,aFirst,bFirst,forwardOrderA,forwardOrderB)}FindRelationOnLastPoint(aLast,bLast,forwardOrderA,forwardOrderB){const a0=aLast,b0=bLast;for(;;){const nextA=this.Next(aLast,forwardOrderA),nextB=this.Next(bLast,forwardOrderB);if(null==nextA||null==nextB)return 0;if(!nextA.point.equal(nextB.point))break;aLast=nextA,bLast=nextB}for(;this.Next(aLast,forwardOrderA).point.equal(this.Prev(bLast,forwardOrderB).point);)aLast=this.Next(aLast,forwardOrderA),bLast=this.Prev(bLast,forwardOrderB);return this.PolylinesIntersect(aLast,bLast,a0,b0,forwardOrderA,forwardOrderB)}PolylinesIntersect(a0,b0,a1,b1,forwardOrderA,forwardOrderB){const a0p=this.Prev(a0,forwardOrderA),a0n=this.Next(a0,forwardOrderA),a1n=this.Next(a1,forwardOrderA),a1p=this.Prev(a1,forwardOrderA),b0n=this.Next(b0,forwardOrderB),b1p=this.Prev(b1,forwardOrderB);if(a0.point.equal(a1.point)){const bs=a0.point;return getOrientationOf3Vectors(a1p.point.sub(bs),b1p.point.sub(bs),a0n.point.sub(bs))==getOrientationOf3Vectors(a1p.point.sub(bs),b0n.point.sub(bs),a0n.point.sub(bs))?1:2}return getOrientationOf3Vectors(a0p.point.sub(a0.point),a0n.point.sub(a0.point),b0n.point.sub(a0.point))==getOrientationOf3Vectors(a1n.point.sub(a1.point),b1p.point.sub(a1.point),a1p.point.sub(a1.point))?1:2}Swap(aFirst,bFirst,aLast,bLast,forwardOrderA,forwardOrderB){const intermediateAPoints=this.GetRangeOnPolyline(this.Next(aFirst,forwardOrderA),aLast,forwardOrderA),intermediateBPoints=this.GetRangeOnPolyline(this.Next(bFirst,forwardOrderB),bLast,forwardOrderB);this.ChangePolylineSegment(aFirst,aLast,forwardOrderA,intermediateBPoints),this.ChangePolylineSegment(bFirst,bLast,forwardOrderB,intermediateAPoints),PathFixer.RemoveSelfCyclesFromPolyline(aFirst.polyline),PathFixer.RemoveSelfCyclesFromPolyline(bFirst.polyline)}ChangePolylineSegment(aFirst,aLast,forwardOrderA,intermediateBPoints){let curA=aFirst;for(const b of intermediateBPoints){const newp=PolylinePoint.mkFromPoint(b.point);newp.polyline=curA.polyline,forwardOrderA?(newp.prev=curA,curA.next=newp):(newp.next=curA,curA.prev=newp),curA=newp}forwardOrderA?(curA.next=aLast,aLast.prev=curA):(curA.prev=aLast,aLast.next=curA)}GetRangeOnPolyline(start,end,forwardOrder){const res=new Array;for(let pp=start;pp!=end;pp=this.Next(pp,forwardOrder))res.push(pp);return res}IsNeighborOnTheSamePolyline(a,b){return null!=a.prev&&a.prev.point.equal(b.point)||null!=a.next&&a.next.point.equal(b.point)}RegisterInterestingPoint(p){this.interestingPoints.has(p)||this.interestingPoints.add(p)}GetChangedHubs(){return this.interestingPoints}NumberOfReducedCrossings(){return this.numberOfReducedCrossings}PolylineIsOK(poly){const pointsToPP=new PointSet;for(let pp=poly.startPoint;null!=pp;pp=pp.next){if(pp==poly.startPoint){if(null!=pp.prev)return!1}else if(pp.prev.next!=pp)return!1;if(pp==poly.endPoint){if(null!=pp.next)return!1}else if(pp.next.prev!=pp)return!1;if(pointsToPP.has(pp.point))return!1;pointsToPP.add(pp.point)}return null==poly.startPoint.prev&&null==poly.endPoint.next}}class PathFixer{constructor(metroGraphData,polylineAcceptsPoint){this.foundCrossings=new PointSet,this.crossingsThatShouldBecomeHubs=new PointSet,this.metroGraphData=metroGraphData,this.polylineAcceptsPoint=polylineAcceptsPoint}*Vertices(){for(const poly of this.Polylines)for(const p of poly.polylinePoints())yield p}get Polylines(){return this.metroGraphData.Edges.map((e=>e.curve))}Edges(){const map=new PointPairMap;for(const pp of this.Vertices())pp.next&&map.set(new PointPair(pp.point,pp.next.point),0);return Array.from(map.keys())}run(){if(0==this.metroGraphData.Edges.length)return!1;const splittingPoints=new PointPairMap,treeOfVertices=new RTree(null);for(const vertex of this.Vertices()){const r=Rectangle.mkOnPoints([vertex.point]);r.pad(GeomConstants.intersectionEpsilon),treeOfVertices.Add(r,vertex.point)}const treeOfEdges=CreateRectangleNodeOnData(this.Edges(),(e=>Rectangle.mkPP(e.First,e.Second)));CrossRectangleNodesSameType(treeOfEdges,treeOfEdges,((a,b)=>this.IntersectTwoEdges.bind(a,b,splittingPoints,treeOfVertices))),this.SortInsertedPoints(splittingPoints);const pointsInserted=this.InsertPointsIntoPolylines(splittingPoints),progress=this.FixPaths(),pointsRemoved=this.RemoveUnimportantCrossings();return progress||pointsInserted||pointsRemoved}FixPaths(){let progress=!1;return this.RemoveSelfCycles()&&(progress=!0),this.ReduceEdgeCrossings()&&(progress=!0),progress}SortInsertedPoints(splittingPoints){for(const pair of splittingPoints)this.SortInsideSegment(pair[0],pair[1])}SortInsideSegment(edge,list){list.sort(((a,b)=>compareNumbers(distPP(a,edge.First),distPP(b,edge.First))))}InsertPointsIntoPolylines(splittingPoints){let inserted=!1;for(const metroline of this.metroGraphData.Metrolines)return this.InsertPointsIntoPolyline(metroline,splittingPoints)&&(inserted=!0),inserted}InsertPointsIntoPolyline(metroline,splittingPoints){let inserted=!1;for(let pp=metroline.Polyline.startPoint;null!=pp.next;pp=pp.next)this.InsertPointsOnPolypoint(pp,splittingPoints,metroline)&&(inserted=!0);return inserted}InsertPointsOnPolypoint(pp,splittingPoints,metroline){const pointPair=new PointPair(pp.point,pp.next.point),reversed=pp.point!=pointPair.First,list=splittingPoints.get(pointPair);if(!list)return!1;const endPolyPoint=pp.next,poly=pp.polyline;if(reversed)for(let i=list.length-1;i>=0;i--){if(null!=this.polylineAcceptsPoint&&!this.polylineAcceptsPoint(metroline,list[i]))continue;const p=PolylinePoint.mkFromPoint(list[i]);p.prev=pp,p.polyline=poly,pp.next=p,pp=p}else for(let i=0;i<list.length;i++){if(null!=this.polylineAcceptsPoint&&!this.polylineAcceptsPoint(metroline,list[i]))continue;const p=PolylinePoint.mkFromPoint(list[i]);p.prev=pp,p.polyline=poly,pp.next=p,pp=p}return pp.next=endPolyPoint,endPolyPoint.prev=pp,!0}RemoveSelfCycles(){let progress=!1;for(const poly of this.Polylines)PathFixer.RemoveSelfCyclesFromPolyline(poly)&&(progress=!0);return progress}static RemoveSelfCyclesFromPolyline(poly){let progress=!1;const pointsToPp=new PointMap;for(let pp=poly.startPoint;null!=pp;pp=pp.next){const point=pp.point,previous=pointsToPp.get(point);if(previous){for(let px=previous.next;px!=pp.next;px=px.next)pointsToPp.deleteP(px.point);previous.next=pp.next,pp.next.prev=previous,progress=!0}else pointsToPp.set(pp.point,pp)}return progress}ReduceEdgeCrossings(){const cycleCollapser=new FlipSwitcher(this.metroGraphData);cycleCollapser.Run();for(const t of cycleCollapser.GetChangedHubs())this.crossingsThatShouldBecomeHubs.add(t);return cycleCollapser.NumberOfReducedCrossings()>0}RemoveUnimportantCrossings(){let removed=!1;this.pointsToDelete=function substractPointSets(a,b){const ret=new PointSet;for(const u of a)b.has(u)||ret.add(u);return ret}(this.foundCrossings,this.crossingsThatShouldBecomeHubs);for(const polyline of this.Polylines)this.RemoveUnimportantCrossingsFromPolyline(polyline)&&(removed=!0);return removed}RemoveUnimportantCrossingsFromPolyline(polyline){let removed=!1;for(let p=polyline.startPoint.next;null!=p&&null!=p.next;p=p.next)if(this.pointsToDelete.has(p.point)&&point_Point.getTriangleOrientation(p.prev.point,p.point,p.next.point)==point_TriangleOrientation.Collinear){const pp=p.prev,pn=p.next;pp.next=pn,pn.prev=pp,p=pp,removed=!0}return removed}IntersectTwoEdges(a,b,splittingPoints,tree){const x=LineSegment.IntersectPPPP(a.First,a.Second,b.First,b.Second);if(x){const vertex=this.FindExistingVertexOrCreateNew(tree,x);(this.AddVertexToSplittingList(a,splittingPoints,vertex)||this.AddVertexToSplittingList(b,splittingPoints,vertex))&&this.foundCrossings.add(vertex)}}FindExistingVertexOrCreateNew(tree,x){const p=tree.RootNode.FirstHitNode(x);if(null!=p)return p.UserData;const rect=Rectangle.mkOnPoints([x]).pad(GeomConstants.intersectionEpsilon);return tree.Add(rect,x),x}AddVertexToSplittingList(a,splittingPoints,intersectionPoint){if(!Curve.closeIntersectionPoints(intersectionPoint,a.First)&&!Curve.closeIntersectionPoints(intersectionPoint,a.Second)){let list=splittingPoints.get(a);if(list||(list=new Array,splittingPoints.set(a,list)),!list.find((p=>p.equal(intersectionPoint))))return list.push(intersectionPoint),!0}return!1}}class BundleBase{constructor(count,boundaryCurve,position,belongsToRealNode){this.BelongsToRealNode=belongsToRealNode,this.Curve=boundaryCurve,this.Position=position,this.points=new Array(count),this.tangents=new Array(count),this.OrientedHubSegments=new Array(count),this.ParameterSpan=this.Curve.parEnd-this.Curve.parStart}get Count(){return this.points.length}get CurveCenter(){return this.Curve.boundingBox.center}get OppositeBase(){return null!=this.OutgoingBundleInfo?this.OutgoingBundleInfo.TargetBase:this.IncomingBundleInfo.SourceBase}get length(){return this.points.length}get Points(){return this.points}get Tangents(){return this.tangents}get InitialMidParameter(){return this.initialMidParameter}set InitialMidParameter(value){this.initialMidParameter=value,this.InitialMidPoint=this.Curve.value(value)}get ParRight(){return this.parRight}set ParRight(value){this.parRight=value,this.RightPoint=this.Curve.value(this.parRight)}get ParLeft(){return this.parLeft}set ParLeft(value){this.parLeft=value,this.LeftPoint=this.Curve.value(this.parLeft)}get ParMid(){return(this.parRight+this.parLeft)/2}get MidPoint(){return point_Point.middle(this.RightPoint,this.LeftPoint)}get Span(){return this.SpanBetweenTwoPoints(this.parRight,this.parLeft)}SpanBetweenTwoPoints(right,left){return right<=left?left-right:left-right+this.ParameterSpan}RotateLeftPoint(rotationOfSourceLeftPoint,parameterChange){return 0==rotationOfSourceLeftPoint?this.LeftPoint:this.RotatePoint(rotationOfSourceLeftPoint,this.parLeft,parameterChange)}RotateRigthPoint(rotationOfSourceRightPoint,parameterChange){return 0==rotationOfSourceRightPoint?this.RightPoint:this.RotatePoint(rotationOfSourceRightPoint,this.parRight,parameterChange)}RotatePoint(rotation,t,parameterChange){return t+=rotation*(this.ParameterSpan*parameterChange),t=this.AdjustParam(t),this.Curve.value(t)}AdjustParam(t){return t>this.Curve.parEnd?t=this.Curve.parStart+(t-this.Curve.parEnd):t<this.Curve.parStart&&(t=this.Curve.parEnd-(this.Curve.parStart-t)),t}RotateBy(rotationOfRightPoint,rotationOfLeftPoint,parameterChange){const change=this.ParameterSpan*parameterChange;0!=rotationOfRightPoint&&(this.ParRight=this.AdjustParam(this.ParRight+rotationOfRightPoint*change)),0!=rotationOfLeftPoint&&(this.ParLeft=this.AdjustParam(this.ParLeft+rotationOfLeftPoint*change))}Intersect(other){return this.IntersectNNNB(this.parRight,this.parLeft,other.parRight,other.parLeft)}IntersectNNNB(lParRight,lParLeft,rParRight,rParLeft){return lParRight>lParLeft?this.IntersectNNNB(lParRight,this.Curve.parEnd,rParRight,rParLeft)||this.IntersectNNNB(this.Curve.parStart,lParLeft,rParRight,rParLeft):rParRight>rParLeft?this.IntersectNNNB(lParRight,lParLeft,rParRight,this.Curve.parEnd)||this.IntersectNNNB(lParRight,lParLeft,this.Curve.parStart,rParLeft):!compareNumbersDistEps(lParLeft,rParRight)&&!compareNumbersDistEps(rParLeft,lParRight)}RelativeOrderOfBasesIsPreserved(rotationOfRightPoint,rotationOfLeftPoint,parameterChange){const change=this.ParameterSpan*parameterChange,rnew=this.parRight+rotationOfRightPoint*change,lnew=this.parRight<this.parLeft?this.parLeft+rotationOfLeftPoint*change:this.parLeft+this.ParameterSpan+rotationOfLeftPoint*change;if(rnew>lnew)return!1;if(this.SpanBetweenTwoPoints(rnew,lnew)>this.ParameterSpan/2)return!1;if(null==this.Prev)return!0;if(this.SpanBetweenTwoPoints(this.Prev.ParMid,this.ParMid)>change&&this.SpanBetweenTwoPoints(this.ParMid,this.Next.ParMid)>change)return!0;const rSoP=this.RotateLeftPoint(rotationOfLeftPoint,parameterChange),lSoP=this.RotateRigthPoint(rotationOfRightPoint,parameterChange),newMidPoint=point_Point.middle(rSoP,lSoP),curMidPoint=this.MidPoint;return point_Point.getTriangleOrientation(this.CurveCenter,this.Prev.MidPoint,curMidPoint)==point_Point.getTriangleOrientation(this.CurveCenter,this.Prev.MidPoint,newMidPoint)&&point_Point.getTriangleOrientation(this.CurveCenter,this.Next.MidPoint,curMidPoint)==point_Point.getTriangleOrientation(this.CurveCenter,this.Next.MidPoint,newMidPoint)}}class BundleInfo{constructor(sourceBase,targetBase,obstaclesToIgnore,edgeSeparation,halfWidthArray){this.SourceBase=sourceBase,this.TargetBase=targetBase,this.obstaclesToIgnore=obstaclesToIgnore,this.EdgeSeparation=edgeSeparation,this.HalfWidthArray=halfWidthArray,this.TotalRequiredWidth=this.EdgeSeparation*(this.HalfWidthArray.length-1)+2*this.HalfWidthArray.reduce(((a,b)=>a+b),0),this.longEnoughSideLength=sourceBase.Curve.boundingBox.addRec(targetBase.Curve.boundingBox).diagonal;const mn=Math.max(sourceBase.Curve.boundingBox.diagonal,targetBase.Curve.boundingBox.diagonal);if(this.TotalRequiredWidth>mn){const scale=this.TotalRequiredWidth/mn;for(let i=0;i<this.HalfWidthArray.length;i++)this.HalfWidthArray[i]/=scale;this.TotalRequiredWidth/=scale,this.EdgeSeparation/=scale}}SetParamsFeasiblySymmetrically(tightTree){this.CalculateTightObstaclesForBundle(tightTree,this.obstaclesToIgnore),this.SetEndParamsSymmetrically()}CalculateTightObstaclesForBundle(tightTree,obstaclesToIgnore){const sRadius=this.SourceBase.Curve.boundingBox.diagonal/2,tRadius=this.TargetBase.Curve.boundingBox.diagonal/2,bundle=Intersections.Create4gon(this.SourceBase.Position,this.TargetBase.Position,2*sRadius,2*tRadius);this.tightObstaclesInTheBoundingBox=Array.from(tightTree.AllHitItems(bundle.boundingBox,(p=>!obstaclesToIgnore.has(p)&&Curve.ClosedCurveInteriorsIntersect(bundle,p))))}SetEndParamsSymmetrically(){const targetPos=this.TargetBase.Position,sourcePos=this.SourceBase.Position,dir=targetPos.sub(sourcePos).normalize(),perp=dir.rotate90Ccw(),middle=point_Point.middle(targetPos,sourcePos),mdir=dir.mul(this.longEnoughSideLength),a=middle.add(mdir),b=middle.sub(mdir);if(this.SetRLParamsIfWidthIsFeasible(perp.mul(this.TotalRequiredWidth/2),a,b))return void this.SetInitialMidParams();let uw=this.TotalRequiredWidth,lw=0,mw=uw/2;for(;uw-lw>BundleInfo.FeasibleWidthEpsilon;)this.SetRLParamsIfWidthIsFeasible(perp.mul(mw/2),a,b)?lw=mw:uw=mw,mw=.5*(uw+lw);mw<=BundleInfo.FeasibleWidthEpsilon&&(this.SetRLParamsIfWidthIsFeasible_(perp.mul(BundleInfo.FeasibleWidthEpsilon),new point_Point(0,0),a,b)||this.SetRLParamsIfWidthIsFeasible_(new point_Point(0,0),perp.mul(-BundleInfo.FeasibleWidthEpsilon),a,b))&&(mw=2*BundleInfo.FeasibleWidthEpsilon),this.SourceBase.InitialMidParameter=this.SourceBase.AdjustParam(this.SourceBase.ParRight+this.SourceBase.Span/2),this.TargetBase.InitialMidParameter=this.TargetBase.AdjustParam(this.TargetBase.ParRight+this.TargetBase.Span/2)}mkNameFromLRST(){return"/tmp/leftRight"+this.SourceBase.Position.toString()+"_"+this.TargetBase.Position.toString()+".svg"}SetRLParamsIfWidthIsFeasible(perp,a,b){return this.SetRLParamsIfWidthIsFeasible_(perp,perp.neg(),a,b)}SetRLParamsIfWidthIsFeasible_(perpL,perpR,a,b){const targetLParam={par:0},sourceLParam={par:0},targetRParam={par:0},sourceRParam={par:0};let ls=this.TrimSegWithBoundaryCurves(LineSegment.mkPP(a.add(perpL),b.add(perpL)),sourceLParam,targetRParam);if(null==ls)return!1;return!this.tightObstaclesInTheBoundingBox.find((t=>null!=Curve.intersectionOne(ls,t,!1)))&&(ls=this.TrimSegWithBoundaryCurves(LineSegment.mkPP(a.add(perpR),b.add(perpR)),sourceRParam,targetLParam),null!=ls&&(!this.tightObstaclesInTheBoundingBox.find((t=>null!=Curve.intersectionOne(ls,t,!1)))&&(this.SourceBase.IsParent?(this.SourceBase.ParRight=sourceLParam.par,this.SourceBase.ParLeft=sourceRParam.par):(this.SourceBase.ParRight=sourceRParam.par,this.SourceBase.ParLeft=sourceLParam.par),this.TargetBase.IsParent?(this.TargetBase.ParRight=targetLParam.par,this.TargetBase.ParLeft=targetRParam.par):(this.TargetBase.ParRight=targetRParam.par,this.TargetBase.ParLeft=targetLParam.par),!0)))}SetInitialMidParams(){const t={par:0},s={par:0};null!=this.TrimSegWithBoundaryCurves(LineSegment.mkPP(this.TargetBase.CurveCenter,this.TargetBase.CurveCenter),s,t)?(this.SourceBase.InitialMidParameter=s.par,this.TargetBase.InitialMidParameter=t.par):(this.SourceBase.InitialMidParameter=this.SourceBase.AdjustParam(this.SourceBase.ParRight+this.SourceBase.Span/2),this.TargetBase.InitialMidParameter=this.TargetBase.AdjustParam(this.TargetBase.ParRight+this.TargetBase.Span/2))}mkNameFromST(){return"/tmp/mparam"+this.SourceBase.Position.toString()+"_"+this.TargetBase.Position.toString()+".svg"}TrimSegWithBoundaryCurves(ls,s,t){let sourceX,targetX,inters=Curve.getAllIntersections(ls,this.SourceBase.Curve,!0);return 0==inters.length?(t.par=0,s.par=0,null):(sourceX=1==inters.length?inters[0]:this.SourceBase.IsParent?inters[0].par0<inters[1].par0?inters[1]:inters[0]:inters[0].par0<inters[1].par0?inters[0]:inters[1],inters=Curve.getAllIntersections(ls,this.TargetBase.Curve,!0),0==inters.length?(t.par=0,s.par=0,null):(targetX=1==inters.length?inters[0]:this.TargetBase.IsParent?inters[0].par0>inters[1].par0?inters[1]:inters[0]:inters[0].par0>inters[1].par0?inters[0]:inters[1],s.par=sourceX.par1,t.par=targetX.par1,LineSegment.mkPP(sourceX.x,targetX.x)))}RotateBy(rotationOfSourceRightPoint,rotationOfSourceLeftPoint,rotationOfTargetRightPoint,rotationOfTargetLeftPoint,parameterChange){const needToUpdateSource=0!=rotationOfSourceRightPoint||0!=rotationOfSourceLeftPoint,needToUpdateTarget=0!=rotationOfTargetRightPoint||0!=rotationOfTargetLeftPoint;needToUpdateSource&&this.SourceBase.RotateBy(rotationOfSourceRightPoint,rotationOfSourceLeftPoint,parameterChange),needToUpdateTarget&&this.TargetBase.RotateBy(rotationOfTargetRightPoint,rotationOfTargetLeftPoint,parameterChange),this.UpdateSourceAndTargetBases(needToUpdateSource,needToUpdateTarget)}UpdateSourceAndTargetBases(sourceChanged,targetChanged){sourceChanged&&this.UpdatePointsOnBundleBase(this.SourceBase),targetChanged&&this.UpdatePointsOnBundleBase(this.TargetBase),this.UpdateTangentsOnBases()}UpdateTangentsOnBases(){const count=this.TargetBase.length;for(let i=0;i<count;i++){let d=this.TargetBase.Points[i].sub(this.SourceBase.Points[count-1-i]);const len=d.length;len>=GeomConstants.tolerance&&(d=d.div(len),this.TargetBase.Tangents[i]=d,this.SourceBase.Tangents[count-1-i]=d.neg())}}UpdatePointsOnBundleBase(bb){const count=bb.length,pns=bb.Points,ls=LineSegment.mkPP(bb.LeftPoint,bb.RightPoint),scale=1/this.TotalRequiredWidth;let t=this.HalfWidthArray[0];pns[0]=ls.value(t*scale);for(let i=1;i<count;i++)t+=this.HalfWidthArray[i-1]+this.EdgeSeparation+this.HalfWidthArray[i],pns[i]=ls.value(t*scale)}RotationIsLegal(rotationOfSourceRightPoint,rotationOfSourceLeftPoint,rotationOfTargetRightPoint,rotationOfTargetLeftPoint,parameterChange){if(this.SourceBase.IsParent||this.TargetBase.IsParent){if(0!=rotationOfSourceLeftPoint||0!=rotationOfTargetLeftPoint){const lSoP=this.SourceBase.RotateLeftPoint(rotationOfSourceLeftPoint,parameterChange),lTarP=this.TargetBase.RotateLeftPoint(rotationOfTargetLeftPoint,parameterChange);if(!this.LineIsLegal(lSoP,lTarP))return!1}if(0!=rotationOfSourceRightPoint||0!=rotationOfTargetRightPoint){const rSoP=this.SourceBase.RotateRigthPoint(rotationOfSourceRightPoint,parameterChange),rTarP=this.TargetBase.RotateRigthPoint(rotationOfTargetRightPoint,parameterChange);if(!this.LineIsLegal(rSoP,rTarP))return!1}}else{if(0!=rotationOfSourceLeftPoint||0!=rotationOfTargetRightPoint){const rSoP=this.SourceBase.RotateLeftPoint(rotationOfSourceLeftPoint,parameterChange),lTarP=this.TargetBase.RotateRigthPoint(rotationOfTargetRightPoint,parameterChange);if(!this.LineIsLegal(rSoP,lTarP))return!1}if(0!=rotationOfSourceRightPoint||0!=rotationOfTargetLeftPoint){const lSoP=this.SourceBase.RotateRigthPoint(rotationOfSourceRightPoint,parameterChange),rTarP=this.TargetBase.RotateLeftPoint(rotationOfTargetLeftPoint,parameterChange);if(!this.LineIsLegal(lSoP,rTarP))return!1}}return!!(0==rotationOfSourceRightPoint&&0==rotationOfSourceLeftPoint||this.SourceBase.RelativeOrderOfBasesIsPreserved(rotationOfSourceRightPoint,rotationOfSourceLeftPoint,parameterChange))&&!!(0==rotationOfTargetRightPoint&&0==rotationOfTargetLeftPoint||this.TargetBase.RelativeOrderOfBasesIsPreserved(rotationOfTargetRightPoint,rotationOfTargetLeftPoint,parameterChange))}LineIsLegal(a,b){return null==this.tightObstaclesInTheBoundingBox.find((t=>null!=Curve.intersectionOne(LineSegment.mkPP(a,b),t,!1)))}}BundleInfo.FeasibleWidthEpsilon=.1;class OrientedHubSegment{constructor(seg,reversed,index,bundleBase){this.Segment=seg,this.Reversed=reversed,this.Index=index,this.BundleBase=bundleBase}get Segment(){return this.segment}set Segment(value){this.segment=value}value(t){return this.Reversed?this.Segment.value(this.Segment.parEnd-t):this.Segment.value(t)}}class BundleBasesCalculator{constructor(metroOrdering,metroGraphData,bundlingSettings){this.fixedBundles=new HashSet,this.stepsWithProgress=0,this.metroOrdering=metroOrdering,this.metroGraphData=metroGraphData,this.bundlingSettings=bundlingSettings}Run(){this.AllocateBundleBases(),this.SetBasesRightLeftParamsToTheMiddles(),this.bundlingSettings.KeepOverlaps?(this.UpdateSourceAndTargetBases(),this.CreateOrientedSegs()):(this.SetRightLeftParamsFeasiblySymmetrically(),this.AdjustStartEndParamsToAvoidBaseOverlaps(),this.UpdateSourceAndTargetBases(),this.CreateOrientedSegs(),this.bundlingSettings.RotateBundles&&this.RotateBundlesToDiminishCost(),this.AdjustStartEndParamsToAvoidBaseOverlaps(),this.UpdateSourceAndTargetBases())}AllocateBundleBases(){this.externalBases=new Map,this.internalBases=new Map,this.Bundles=new Array;for(const station of this.metroGraphData.Stations)null==station.BoundaryCurve&&(station.BoundaryCurve=Ellipse.mkCircle(station.Radius,station.Position));for(const station of this.metroGraphData.Stations)for(const neighbor of station.Neighbors)if(station.SerialNumber<neighbor.SerialNumber){const bb=new BundleBase(this.metroGraphData.RealEdgeCount(station,neighbor),station.BoundaryCurve,station.Position,station.IsReal);station.BundleBases.set(neighbor,bb);const bb2=new BundleBase(this.metroGraphData.RealEdgeCount(station,neighbor),neighbor.BoundaryCurve,neighbor.Position,neighbor.IsReal);neighbor.BundleBases.set(station,bb2),Curve.PointRelativeToCurveLocation(neighbor.Position,station.BoundaryCurve)!=PointLocation.Outside?(bb.IsParent=!0,addToMapOfArrays(this.internalBases,station.BoundaryCurve,bb),addToMapOfArrays(this.externalBases,neighbor.BoundaryCurve,bb2)):Curve.PointRelativeToCurveLocation(station.Position,neighbor.BoundaryCurve)!=PointLocation.Outside?(bb2.IsParent=!0,addToMapOfArrays(this.externalBases,station.BoundaryCurve,bb),addToMapOfArrays(this.internalBases,neighbor.BoundaryCurve,bb2)):(addToMapOfArrays(this.externalBases,station.BoundaryCurve,bb),addToMapOfArrays(this.externalBases,neighbor.BoundaryCurve,bb2));const obstaclesToIgnore=this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(station,neighbor),bundle=new BundleInfo(bb,bb2,obstaclesToIgnore,this.bundlingSettings.EdgeSeparation,Array.from(this.metroOrdering.GetOrder(station,neighbor)).map((l=>l.Width/2)));bb.OutgoingBundleInfo=bb2.IncomingBundleInfo=bundle,this.Bundles.push(bundle)}this.SetBundleBaseNeighbors()}SetBundleBaseNeighbors(){for(const c of this.externalBases.keys()){const list=this.externalBases.get(c);this.SortBundlesCounterClockwise(list),this.SetLeftRightBases(list)}for(const c of this.internalBases.keys()){const list=this.internalBases.get(c);this.SortBundlesCounterClockwise(list),this.SetLeftRightBases(list)}}SortBundlesCounterClockwise(list){if(list.length>2){const pivot=list[0].OppositeBase.Position,center=list[0].CurveCenter;list.sort(((u,v)=>getOrientationOf3Vectors(pivot.sub(center),u.OppositeBase.Position.sub(center),v.OppositeBase.Position.sub(center))))}}SetLeftRightBases(bases){const count=bases.length;if(!(count<=1))for(let i=0;i<count;i++)bases[i].Prev=bases[(i-1+count)%count],bases[i].Next=bases[(i+1)%count]}CreateOrientedSegs(){for(const metroline of this.metroGraphData.Metrolines)this.CreateOrientedSegsOnLine(metroline)}CreateOrientedSegsOnLine(line){for(let polyPoint=line.Polyline.startPoint.next;null!=polyPoint.next;polyPoint=polyPoint.next)this.CreateOrientedSegsOnLineVertex(line,polyPoint)}CreateOrientedSegsOnLineVertex(line,polyPoint){const u=this.metroGraphData.PointToStations.get(polyPoint.prev.point),v=this.metroGraphData.PointToStations.get(polyPoint.point),w=this.metroGraphData.PointToStations.get(polyPoint.next.point),h0=v.BundleBases.get(u),h1=v.BundleBases.get(w),j0=this.metroOrdering.GetLineIndexInOrder(u,v,line),j1=this.metroOrdering.GetLineIndexInOrder(w,v,line),or0=h0.OrientedHubSegments[j0]=new OrientedHubSegment(null,!1,j0,h0),or1=h1.OrientedHubSegments[j1]=new OrientedHubSegment(null,!0,j1,h1);or1.Other=or0,or0.Other=or1}UpdateSourceAndTargetBases(){for(const bundleInfo of this.Bundles)bundleInfo.UpdateSourceAndTargetBases(!0,!0)}SetBasesRightLeftParamsToTheMiddles(){for(const bundle of this.Bundles){const sbase=bundle.SourceBase,tbase=bundle.TargetBase;sbase.ParLeft=sbase.ParRight=this.GetBaseMiddleParamInDirection(sbase,sbase.Position,tbase.Position),tbase.ParLeft=tbase.ParRight=this.GetBaseMiddleParamInDirection(tbase,tbase.Position,sbase.Position)}}GetBaseMiddleParamInDirection(targetBase,sPos,neighbPos){const curve=targetBase.Curve;if(curve instanceof Ellipse){const circle=curve;if(circle.isArc())return point_Point.angle(circle.aAxis,neighbPos.sub(sPos))}const intersections=Curve.getAllIntersections(curve,LineSegment.mkPP(sPos,neighbPos),!0);for(const intersectionInfo of intersections){const xP=intersectionInfo.x;if(xP.sub(sPos).dot(xP.sub(neighbPos))<=0)return intersectionInfo.par0}throw new Error}SetRightLeftParamsFeasiblySymmetrically(){for(const bundle of this.Bundles)bundle.SetParamsFeasiblySymmetrically(this.metroGraphData.TightTree)}AdjustStartEndParamsToAvoidBaseOverlaps(){for(const c of this.externalBases.keys())this.AdjustCurrentBundleWidthsOnCurve(this.externalBases.get(c));for(const c of this.internalBases.keys())this.AdjustCurrentBundleWidthsOnCurve(this.internalBases.get(c))}AdjustCurrentBundleWidthsOnCurve(bases){const count=bases.length;if(!(count<=1))for(let i=0;i<count;i++){const rBase=bases[i],lBase=rBase.Next;this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(rBase,lBase)}}ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(rBase,lBase){if(!rBase.Intersect(lBase))return;let l1=rBase.ParRight,r1=rBase.ParLeft,l2=lBase.ParRight,r2=lBase.ParLeft;const span=lBase.ParameterSpan;l1>r1&&(l1-=span),l2>r2&&(l2-=span),l2>r1&&(l2-=span,r2-=span),l1>r2&&(l1-=span,r1-=span);const t=this.RegularCut(l1,r1,l2,r2,rBase.Span,lBase.Span),to=point_Point.getTriangleOrientation(lBase.CurveCenter,lBase.OppositeBase.InitialMidPoint,rBase.OppositeBase.InitialMidPoint);to==point_TriangleOrientation.Clockwise?(r1=t,l2=t):to==point_TriangleOrientation.Counterclockwise?(r2=t,l1=t):r2-l1>=r1-l2?(r1=t,l2=t):(r2=t,l1=t),lBase.ParRight=lBase.AdjustParam(l2),lBase.ParLeft=lBase.AdjustParam(r2),rBase.ParRight=rBase.AdjustParam(l1),rBase.ParLeft=rBase.AdjustParam(r1)}RegularCut(l1,r1,l2,r2,span1,span2){let cutParam=(span1*r2+span2*l1)/(span1+span2);const mn=Math.min(r1,r2),mx=Math.max(l1,l2);return cutParam<mx&&(cutParam=mx),cutParam>mn&&(cutParam=mn),cutParam}RotateBundlesToDiminishCost(){let parameterChange=BundleBasesCalculator.MaxParameterChange;const t={cost:this.Cost()};let iteration=0;for(;iteration++<BundleBasesCalculator.MaxIterations;){const oldCost=t.cost;if(this.RotateBundlesToDiminishCostOneIteration(parameterChange,t),parameterChange=this.UpdateParameterChange(parameterChange,oldCost,t.cost),parameterChange<BundleBasesCalculator.MinParameterChange)break}}UpdateParameterChange(step,oldEnergy,newEnergy){return newEnergy+1<oldEnergy?(this.stepsWithProgress++,this.stepsWithProgress>=5&&(this.stepsWithProgress=0,this.fixedBundles.clear())):(this.stepsWithProgress=0,step*=.8,this.fixedBundles.clear()),step}RotateBundlesToDiminishCostOneIteration(parameterChange,t){let progress=!1;for(const bundleInfo of this.Bundles)this.fixedBundles.has(bundleInfo)||(this.OptimizeBundle(bundleInfo,parameterChange,t)?progress=!0:this.fixedBundles.add(bundleInfo));return progress}OptimizeBundle(bundleInfo,parameterChange,t){const bundleCost=this.CostBi(bundleInfo);if(bundleCost<BundleBasesCalculator.CostThreshold)return!1;let bestDelta=0,bestJ=-1,bestI=-1;for(let i=0;i<BundleBasesCalculator.Deltas.length-1;i++){let delta=this.DeltaWithChangedAngles(BundleBasesCalculator.Deltas[i][0],BundleBasesCalculator.Deltas[i][1],0,0,bundleInfo,bundleCost,parameterChange);delta>BundleBasesCalculator.CostDeltaThreshold&&delta>bestDelta&&(bestI=i,bestJ=BundleBasesCalculator.Deltas.length-1,bestDelta=delta),delta=this.DeltaWithChangedAngles(0,0,BundleBasesCalculator.Deltas[i][0],BundleBasesCalculator.Deltas[i][1],bundleInfo,bundleCost,parameterChange),delta>BundleBasesCalculator.CostDeltaThreshold&&delta>bestDelta&&(bestI=BundleBasesCalculator.Deltas.length-1,bestJ=i,bestDelta=delta)}return!(bestDelta<BundleBasesCalculator.CostDeltaThreshold)&&(t.cost-=bestDelta,bundleInfo.RotateBy(BundleBasesCalculator.Deltas[bestI][0],BundleBasesCalculator.Deltas[bestI][1],BundleBasesCalculator.Deltas[bestJ][0],BundleBasesCalculator.Deltas[bestJ][1],parameterChange),!0)}DeltaWithChangedAngles(rotationOfSourceRigthPoint,rotationOfSourceLeftPoint,rotationOfTargetRigthPoint,rotationOfTargetLeftPoint,bundleInfo,bundleCost,parameterChange){if(!bundleInfo.RotationIsLegal(rotationOfSourceRigthPoint,rotationOfSourceLeftPoint,rotationOfTargetRigthPoint,rotationOfTargetLeftPoint,parameterChange))return 0;bundleInfo.RotateBy(rotationOfSourceRigthPoint,rotationOfSourceLeftPoint,rotationOfTargetRigthPoint,rotationOfTargetLeftPoint,parameterChange);const newCost=this.CostBN(bundleInfo,bundleCost);return bundleInfo.RotateBy(-1*rotationOfSourceRigthPoint,-1*rotationOfSourceLeftPoint,-1*rotationOfTargetRigthPoint,-1*rotationOfTargetLeftPoint,parameterChange),bundleCost-newCost}CostBi(bundleInfo){return BundleBasesCalculator.SeparationCoeff*this.SeparationCost(bundleInfo)+(BundleBasesCalculator.SqueezeCoeff*this.SqueezeCost(bundleInfo)+(BundleBasesCalculator.AssymetryCoeff*this.AssymetryCost(bundleInfo)+BundleBasesCalculator.CenterCoeff*this.CenterCostBi(bundleInfo)))}CostBN(bundleInfo,limit){let cost=0;return cost+=BundleBasesCalculator.CenterCoeff*this.CenterCostBi(bundleInfo),cost>limit?cost:(cost+=BundleBasesCalculator.SeparationCoeff*this.SeparationCost(bundleInfo),cost>limit?cost:(cost+=BundleBasesCalculator.SqueezeCoeff*this.SqueezeCost(bundleInfo),cost>limit||(cost+=BundleBasesCalculator.AssymetryCoeff*this.AssymetryCost(bundleInfo)),cost))}SqueezeCost(bundleInfo){const perp=bundleInfo.TargetBase.MidPoint.sub(bundleInfo.SourceBase.MidPoint).normalize().rotate90Ccw(),projecton0=Math.abs(bundleInfo.SourceBase.RightPoint.sub(bundleInfo.SourceBase.LeftPoint).dot(perp)),projecton1=Math.abs(bundleInfo.TargetBase.RightPoint.sub(bundleInfo.TargetBase.LeftPoint).dot(perp)),del0=Math.abs(bundleInfo.TotalRequiredWidth-projecton0)/bundleInfo.TotalRequiredWidth,del1=Math.abs(bundleInfo.TotalRequiredWidth-projecton1)/bundleInfo.TotalRequiredWidth,del=Math.abs(projecton0-projecton1)/bundleInfo.TotalRequiredWidth;return Math.exp(10*del0)-1+(Math.exp(10*del1)-1)+del}CenterCostBi(bundleInfo){return bundleInfo.SourceBase.BelongsToRealNode||bundleInfo.TargetBase.BelongsToRealNode?this.CenterCostBb(bundleInfo.SourceBase)+this.CenterCostBb(bundleInfo.TargetBase):0}CenterCostBb(bundleBase){if(!bundleBase.BelongsToRealNode)return 0;const currentMid=bundleBase.ParMid,mn=Math.min(bundleBase.InitialMidParameter,currentMid),mx=Math.max(bundleBase.InitialMidParameter,currentMid),dist=Math.min(mx-mn,mn+(bundleBase.ParameterSpan-mx));return bundleBase.CurveCenter.equal(bundleBase.Position)||bundleBase.IsParent?dist*dist*25:dist*dist*500}AssymetryCost(bundleInfo){return this.GetAssymetryCostForBase(bundleInfo.SourceBase)+this.GetAssymetryCostForBase(bundleInfo.TargetBase)}GetAssymetryCostForBase(bundleBase){if(bundleBase.BelongsToRealNode)return 0;const assymetryWeight=bundleBase.OppositeBase.BelongsToRealNode?200:500;let cost=0;for(const o of bundleBase.OrientedHubSegments){const i0=o.Index,i1=o.Other.Index,a=bundleBase.Points[i0],ta=bundleBase.Tangents[i0],oppositeBase=o.Other.BundleBase,b=oppositeBase.Points[i1],tb=oppositeBase.Tangents[i1],s=bundleBase.Count+oppositeBase.Count;cost+=this.GetAssymetryCostOnData(a,ta,b,tb,assymetryWeight)/s}return cost}GetAssymetryCostOnData(a,tangentA,b,tangentB,assymetryWeight){const xAxis=a.sub(b),len=xAxis.length;if(len<GeomConstants.distanceEpsilon)return 0;const delx=tangentA.add(tangentB).dot(xAxis),ay=point_Point.crossProduct(xAxis,tangentA),by=point_Point.crossProduct(xAxis,tangentB),dely=ay-by;return 10*(delx*delx+dely*dely)+assymetryWeight*(ay*ay+by*by)}SeparationCost(bundleInfo){return this.SeparationCostForBundleBase(bundleInfo.SourceBase)+this.SeparationCostForBundleBase(bundleInfo.TargetBase)}SeparationCostForBundleBase(bBase){return null==bBase.Prev?0:this.SeparationCostForAdjacentBundleBases(bBase,bBase.Prev)+this.SeparationCostForAdjacentBundleBases(bBase,bBase.Next)}SeparationCostForAdjacentBundleBases(base0,base1){const boundaryCurve=base0.Curve,len=this.IntervalsOverlapLength(base0.ParRight,base0.ParLeft,base1.ParRight,base1.ParLeft,boundaryCurve),mn=Math.min(base0.Span,base1.Span);return Math.exp(len/(10*mn))-1}IntervalsOverlapLength(a,b,c,d,curve){const s=curve.parStart,e=curve.parEnd;return a<b?c<d?this.IntersectRegularIntervals(a,b,c,d):this.IntersectRegularIntervals(a,b,c,e)+this.IntersectRegularIntervals(a,b,s,d):c<d?this.IntersectRegularIntervals(a,e,c,d)+this.IntersectRegularIntervals(s,b,c,d):this.IntersectRegularIntervals(a,e,c,e)+this.IntersectRegularIntervals(s,b,s,d)}IntersectRegularIntervals(a,b,c,d){const low=Math.max(a,c),up=Math.min(b,d);return low<up?up-low:0}Cost(){let cost=0;for(const bundleInfo of this.Bundles){cost+=(BundleBasesCalculator.SeparationCoeff*this.SeparationCost(bundleInfo)+BundleBasesCalculator.AssymetryCoeff*this.AssymetryCost(bundleInfo))/2+BundleBasesCalculator.SqueezeCoeff*this.SqueezeCost(bundleInfo)+BundleBasesCalculator.CenterCoeff*this.CenterCostBi(bundleInfo)}return cost}}BundleBasesCalculator.Deltas=[[1,-1],[1,-1]],BundleBasesCalculator.SeparationCoeff=1,BundleBasesCalculator.SqueezeCoeff=1,BundleBasesCalculator.CenterCoeff=10,BundleBasesCalculator.AssymetryCoeff=1,BundleBasesCalculator.MaxIterations=200,BundleBasesCalculator.MaxParameterChange=8/360,BundleBasesCalculator.MinParameterChange=.1/360,BundleBasesCalculator.CostThreshold=1e-5,BundleBasesCalculator.CostDeltaThreshold=.01;class PointPairOrder{constructor(){this.Metrolines=new Array}Add(metroline){this.Metrolines.push(metroline)}}class GeneralMetroMapOrdering{constructor(Metrolines){this.Metrolines=Metrolines,this.BuildOrder()}*GetOrder(u,v){const pointPair=new PointPair(u.Position,v.Position),orderedMetrolineListForUv=this.bundles.get(pointPair).Metrolines;if(u.Position==pointPair.First)for(let i=0;i<orderedMetrolineListForUv.length;i++)yield orderedMetrolineListForUv[i];else for(let i=orderedMetrolineListForUv.length-1;i>=0;i--)yield orderedMetrolineListForUv[i]}GetLineIndexInOrder(u,v,ml){const pp=new PointPair(u.Position,v.Position),reversed=u.Position!=pp.First,d=this.bundles.get(pp).LineIndexInOrder;return reversed?d.size-1-d.get(ml):d.get(ml)}BuildOrder(){this.bundles=new PointPairMap;for(const ml of this.Metrolines)for(let p=ml.Polyline.startPoint;null!=p.next;p=p.next){const e=new PointPair(p.point,p.next.point);let li=this.bundles.get(e);li||this.bundles.set(e,li=new PointPairOrder),li.Add(ml)}for(const edge of this.bundles)this.BuildOrderPP(edge[0],edge[1])}BuildOrderPP(pair,order){if(!order.orderFixed){order.Metrolines.sort(((line0,line1)=>this.CompareLines(line0,line1,pair.First,pair.Second))),order.orderFixed=!0,order.LineIndexInOrder=new Map;for(let i=0;i<order.Metrolines.length;i++)order.LineIndexInOrder.set(order.Metrolines[i],i)}}CompareLines(ml0,ml1,u,v){const t={polyPoint:null,next:null,prev:null};this.FindStationOnLine(u,v,ml0,t);const polylinePoint0=t.polyPoint,next0=t.next,prev0=t.prev;this.FindStationOnLine(u,v,ml1,t);const polylinePoint1=t.polyPoint,next1=t.next,prev1=t.prev;let p11,p00,p0=polylinePoint0,p1=polylinePoint1;for(;null!=(p00=prev0(p0))&&null!=(p11=prev1(p1))&&p00.point.equal(p11.point);){const edge=new PointPair(p00.point,p0.point);if(this.bundles.get(edge).orderFixed)return this.CompareOnFixedOrder(edge,ml0,ml1,!p00.point.equal(edge.First));p0=p00,p1=p11}if(null!=p00&&null!=p11){const forkBase=p0.point;return-GeneralMetroMapOrdering.IsLeft(next0(p0).point.sub(forkBase),p00.point.sub(forkBase),p11.point.sub(forkBase))}for(p0=polylinePoint0,p1=polylinePoint1;null!=(p00=next0(p0))&&null!=(p11=next1(p1))&&p00.point.equal(p11.point);){const edge=new PointPair(p00.point,p0.point);if(this.bundles.get(edge).orderFixed)return this.CompareOnFixedOrder(edge,ml0,ml1,!p0.point.equal(edge.First));p0=p00,p1=p11}if(null!=p00&&null!=p11){const forkBase=p0.point;return GeneralMetroMapOrdering.IsLeft(prev0(p0).point.sub(forkBase),p00.point.sub(forkBase),p11.point.sub(forkBase))}return compareNumbers(ml0.Index,ml1.Index)}CompareOnFixedOrder(edge,ml0,ml1,reverse){const mlToIndex=this.bundles.get(edge).LineIndexInOrder;return(reverse?-1:1)*compareNumbers(mlToIndex.get(ml0),mlToIndex.get(ml1))}FindStationOnLine(u,v,ml,t){for(let p=ml.Polyline.startPoint;null!=p.next;p=p.next){if(p.point.equal(u)&&p.next.point.equal(v))return t.next=k=>k.next,t.prev=k=>k.prev,void(t.polyPoint=p);if(p.point.equal(v)&&p.next.point.equal(u))return t.next=k=>k.prev,t.prev=k=>k.next,void(t.polyPoint=p.next)}throw new Error}static IsLeft(v0,v1,v2){return getOrientationOf3Vectors(v0,v1,v2)}}class EdgeNudger extends Algorithm{constructor(metroGraphData,bundlingSettings){super(null),this.metroGraphData=metroGraphData,this.bundlingSettings=bundlingSettings}run(){this.CreateMetroOrdering(),this.InitRadii(),this.FinalizePaths()}InitRadii(){new HubRadiiCalculator(this.metroGraphData,this.bundlingSettings).CreateNodeRadii()}CreateMetroOrdering(){this.metroOrdering=new GeneralMetroMapOrdering(this.metroGraphData.Metrolines)}FinalizePaths(){this.CreateBundleBases(),this.CreateSegmentsInsideHubs(),this.CreateCurves()}CreateBundleBases(){new BundleBasesCalculator(this.metroOrdering,this.metroGraphData,this.bundlingSettings).Run()}CreateCurves(){for(let i=0;i<this.metroGraphData.Metrolines.length;i++)this.CreateCurveLine(this.metroGraphData.Metrolines[i],this.metroGraphData.Edges[i])}CreateCurveLine(line,edge){const c=new Curve;let currentEnd=EdgeNudger.FindCurveStart(this.metroGraphData,this.metroOrdering,line);const hubSegsOfLine=EdgeNudger.HubSegsOfLine(this.metroGraphData,this.metroOrdering,line);for(const seg of hubSegsOfLine)null!=seg&&(c.addSegment(LineSegment.mkPP(currentEnd,seg.start)),c.addSegment(seg),currentEnd=seg.end);c.addSegment(LineSegment.mkPP(currentEnd,EdgeNudger.FindCurveEnd(this.metroGraphData,this.metroOrdering,line))),edge.curve=c}static FindCurveStart(metroGraphData,metroOrdering,metroline){const u=metroGraphData.PointToStations.get(metroline.Polyline.startPoint.point),v=metroGraphData.PointToStations.get(metroline.Polyline.startPoint.next.point),bb=u.BundleBases.get(v),index=bb.IsParent?metroOrdering.GetLineIndexInOrder(u,v,metroline):metroOrdering.GetLineIndexInOrder(v,u,metroline);return bb.Points[index]}static FindCurveEnd(metroGraphData,metroOrdering,metroline){const u=metroGraphData.PointToStations.get(metroline.Polyline.endPoint.prev.point),v=metroGraphData.PointToStations.get(metroline.Polyline.endPoint.point),bb=v.BundleBases.get(u),index=bb.IsParent?metroOrdering.GetLineIndexInOrder(v,u,metroline):metroOrdering.GetLineIndexInOrder(u,v,metroline);return bb.Points[index]}static*HubSegsOfLine(metroGraphData,metroOrdering,line){for(let i=line.Polyline.startPoint.next;null!=i.next;i=i.next)yield EdgeNudger.SegOnLineVertex(metroGraphData,metroOrdering,line,i)}static SegOnLineVertex(metroGraphData,metroOrdering,line,i){const u=metroGraphData.PointToStations.get(i.prev.point),v=metroGraphData.PointToStations.get(i.point),h0=v.BundleBases.get(u),j0=metroOrdering.GetLineIndexInOrder(u,v,line);if(null==h0.OrientedHubSegments[j0]||null==h0.OrientedHubSegments[j0].Segment){const w=metroGraphData.PointToStations.get(i.next.point),otherBase=v.BundleBases.get(w),j1=metroOrdering.GetLineIndexInOrder(w,v,line);return LineSegment.mkPP(h0.Points[j0],otherBase.Points[j1])}return h0.OrientedHubSegments[j0].Segment}CreateSegmentsInsideHubs(){for(const metroline of this.metroGraphData.Metrolines)this.CreateOrientedSegsOnLine(metroline);this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs&&this.FanBezierSegs()}CreateOrientedSegsOnLine(line){for(let polyPoint=line.Polyline.startPoint.next;null!=polyPoint.next;polyPoint=polyPoint.next)this.CreateOrientedSegsOnLineVertex(line,polyPoint)}CreateOrientedSegsOnLineVertex(line,polyPoint){const u=this.metroGraphData.PointToStations.get(polyPoint.prev.point),v=this.metroGraphData.PointToStations.get(polyPoint.point),w=this.metroGraphData.PointToStations.get(polyPoint.next.point),h0=v.BundleBases.get(u),h1=v.BundleBases.get(w),j0=this.metroOrdering.GetLineIndexInOrder(u,v,line),j1=this.metroOrdering.GetLineIndexInOrder(w,v,line),seg=this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs?EdgeNudger.StandardBezier(h0.Points[j0],h0.Tangents[j0],h1.Points[j1],h1.Tangents[j1]):EdgeNudger.BiArc(h0.Points[j0],h0.Tangents[j0],h1.Points[j1],h1.Tangents[j1]);h0.OrientedHubSegments[j0].Segment=seg,h1.OrientedHubSegments[j1].Segment=seg}static ShowHubs(metroGraphData,metroMapOrdering,station,fileName,moreCurves=[]){let ttt=EdgeNudger.GetAllDebugCurves(metroMapOrdering,metroGraphData);null!=station&&ttt.push(debugCurve_DebugCurve.mkDebugCurveTWCI(255,1,"red",curveFactory_CurveFactory.CreateDiamond(5,25,station.Position))),ttt=ttt.concat(moreCurves)}static GetAllDebugCurves(metroMapOrdering,metroGraphData){return EdgeNudger.GraphNodes(metroGraphData).concat(EdgeNudger.VertexDebugCurves(metroMapOrdering,metroGraphData)).concat(EdgeNudger.DebugEdges(metroGraphData))}static DebugEdges(metroGraphData1){return metroGraphData1.Edges.map((e=>debugCurve_DebugCurve.mkDebugCurveTWCI(40,.1,"gray",e.curve)))}static VertexDebugCurves(metroMapOrdering,metroGraphData){return EdgeNudger.DebugCircles(metroGraphData).concat(EdgeNudger.DebugHubBases(metroGraphData)).concat(EdgeNudger.DebugSegs(metroGraphData)).concat(EdgeNudger.BetweenHubs(metroMapOrdering,metroGraphData))}static BetweenHubs(metroMapOrdering,metroGraphData){const ret=[];for(const ml of metroGraphData.Metrolines){const segs=EdgeNudger.GetInterestingSegs(metroGraphData,metroMapOrdering,ml),color=EdgeNudger.GetMonotoneColor(ml.Polyline.start,ml.Polyline.end,segs);for(const seg of segs)ret.push(debugCurve_DebugCurve.mkDebugCurveTWCI(100,ml.Width,color,LineSegment.mkPP(seg[0],seg[1])))}return ret}static GetInterestingSegs(metroGraphData,metroMapOrdering,line){const ret=new Array;if(0==metroGraphData.Stations.length||null==metroGraphData.Stations[0].BundleBases||0==metroGraphData.Stations[0].BundleBases.size)return[];let start=EdgeNudger.FindCurveStart(metroGraphData,metroMapOrdering,line);const cubicSegs=EdgeNudger.HubSegsOfLine(metroGraphData,metroMapOrdering,line);for(const seg of cubicSegs)null!=seg&&(ret.push([start,seg.start]),start=seg.end);return ret.push([start,EdgeNudger.FindCurveEnd(metroGraphData,metroMapOrdering,line)]),ret}static GetMonotoneColor(start,end,segs){return"green"}static DebugHubBases(metroGraphData){const dc=new Array;for(const s of metroGraphData.Stations)for(const h of s.BundleBases.values())dc.push(debugCurve_DebugCurve.mkDebugCurveTWCI(100,1,"red",LineSegment.mkPP(h.LeftPoint,h.RightPoint)));return dc}static DebugCircles(metroGraphData){return metroGraphData.Stations.map((station=>debugCurve_DebugCurve.mkDebugCurveTWCI(100,.1,"blue",curveFactory_CurveFactory.mkCircle(station.Radius,station.Position))))}static DebugSegs(metroGraphData){const ls=new Array;for(const s of metroGraphData.VirtualStations())for(const b of s.BundleBases.values())for(const h of b.OrientedHubSegments)if(null!=h)if(null==h.Segment){const uBase=h.Other.BundleBase,i=h.Index,j=h.Other.Index;ls.push(LineSegment.mkPP(b.Points[i],uBase.Points[j]))}else ls.push(h.Segment);return ls.map((s=>debugCurve_DebugCurve.mkDebugCurveTWCI(100,.01,"green",s)))}static GraphNodes(metroGraphData){return metroGraphData.Edges.map((e=>e.sourcePort.Curve)).concat(metroGraphData.Edges.map((e=>e.targetPort.Curve))).map((n=>debugCurve_DebugCurve.mkDebugCurveTWCI(40,1,"black",n)))}static BiArc(p0,ts,p4,te){const v=p0.sub(p4);if(v.length<GeomConstants.distanceEpsilon)return null;const vtse=v.dot(ts.sub(te)),a=2*(-ts.dot(te)-1),b=2*vtse,c=v.dot(v);let al;if(Math.abs(a)<GeomConstants.distanceEpsilon){if(!(Math.abs(b)>GeomConstants.distanceEpsilon))return null;al=-c/b}else{let d=b*b-4*a*c;d<0&&(d=0),d=Math.sqrt(d),al=(-b+d)/(2*a),al<0&&(al=(-b-d)/(2*a))}const p1=p0.add(ts.mul(al)),p3=p4.add(te.mul(al)),p2=point_Point.middle(p1,p3),curve=new Curve;if(curve.addSegs([EdgeNudger.ArcOn(p0,p1,p2),EdgeNudger.ArcOn(p2,p3,p4)]),ts.dot(p4.sub(p0))<=0&&ts.dot(te)<=0){return EdgeNudger.StandardBezier(p0,ts,p4,te)}return curve}static ArcOn(a,b,c){const t={center:null};if(Math.abs(point_Point.signedDoubledTriangleArea(a,b,c))<1e-4||!EdgeNudger.FindArcCenter(a,b,c,t))return LineSegment.mkPP(a,c);const center=t.center,radius=distPP(a,center);if(distPP(a,b)/radius<1e-4)return LineSegment.mkPP(a,c);const cenA=a.sub(center);let aAngle=Math.atan2(cenA.y,cenA.x);const cenC=c.sub(center);let cAngle=Math.atan2(cenC.y,cenC.x),delac=cAngle-aAngle;if(delac<0&&(delac+=2*Math.PI,cAngle+=2*Math.PI),delac<=Math.PI){return new Ellipse(aAngle,cAngle,new point_Point(radius,0),new point_Point(0,radius),center)}for(cAngle>2*Math.PI&&(cAngle-=2*Math.PI),aAngle=Math.PI-aAngle,cAngle=Math.PI-cAngle,aAngle<0&&(aAngle+=2*Math.PI);cAngle<aAngle;)cAngle+=2*Math.PI;return delac=cAngle-aAngle,new Ellipse(aAngle,cAngle,new point_Point(-radius,0),new point_Point(0,radius),center)}static FindArcCenter(a,b,c,t){const perp0=b.sub(a).rotate90Cw(),perp1=b.sub(c).rotate90Cw();return t.center=point_Point.lineLineIntersection(a,a.add(perp0),c,c.add(perp1)),null!=t.center}static StandardBezier(segStart,tangentAtStart,segEnd,tangentAtEnd){const len=distPP(segStart,segEnd)/4;return BezierSeg.mkBezier([segStart,segStart.add(tangentAtStart.mul(len)),segEnd.add(tangentAtEnd.mul(len)),segEnd])}FanBezierSegs(){let progress=!0;let steps=0;for(;progress&&steps++<5;){progress=!1;for(const s of this.metroGraphData.Stations)for(const segmentHub of s.BundleBases.values())progress||(progress=this.FanEdgesOfHubSegment(segmentHub))}}FanEdgesOfHubSegment(bundleHub){let ret=!1;for(let i=0;i<bundleHub.Count-1;i++)ret||(ret=this.FanCouple(bundleHub,i,bundleHub.CurveCenter,bundleHub.Curve.boundingBox.diagonal/2));return ret}FanCouple(bundleHub,i,center,radius){const lSeg=bundleHub.OrientedHubSegments[i],rSeg=bundleHub.OrientedHubSegments[i+1];if(null==lSeg)return!1;if(LineSegment.IntersectPPPP(lSeg.Segment.start,lSeg.Segment.end,rSeg.Segment.start,rSeg.Segment.end))return!1;if(point_Point.getTriangleOrientation(lSeg.value(0),lSeg.value(.5),lSeg.value(1))!=point_Point.getTriangleOrientation(rSeg.value(0),rSeg.value(.5),rSeg.value(1)))return!1;const ll=this.BaseLength(lSeg),rl=this.BaseLength(rSeg);return!(Math.abs(ll-rl)<GeomConstants.intersectionEpsilon)&&(ll>rl?this.AdjustLongerSeg(lSeg,rSeg,center,radius):this.AdjustLongerSeg(rSeg,lSeg,center,radius))}AdjustLongerSeg(longerSeg,shorterSeg,center,radius){const del0=longerSeg.value(0).sub(shorterSeg.value(0)),del1=longerSeg.value(1).sub(shorterSeg.value(1)),minDelLength=Math.min(del0.length,del1.length),midPointOfShorter=shorterSeg.value(.5),maxDelLen=Math.max(del0.length,del1.length);return 0!=this.NicelyAligned(longerSeg.Segment,del0,del1,midPointOfShorter,minDelLength,maxDelLen)&&this.FitLonger(longerSeg,del0,del1,midPointOfShorter,minDelLength,maxDelLen,center,radius)}FitLonger(longerOrientedSeg,del0,del1,midPointOfShorter,minDelLength,maxDel,center,radius){let seg=longerOrientedSeg.Segment;const start=seg.start,end=seg.end;let steps=0;let lowP1=seg.start.mul(1-EdgeNudger.SqueezeBound).add(seg.B(1).mul(EdgeNudger.SqueezeBound)),lowP2=seg.end.mul(1-EdgeNudger.SqueezeBound).add(seg.B(2).mul(EdgeNudger.SqueezeBound)),highP1=seg.B(1).mul(2).sub(seg.start),highP2=seg.B(2).mul(2).sub(seg.end);const t={highP:highP1};this.PullControlPointToTheCircle(seg.start,t,center,radius),highP1=t.highP;let r=this.NicelyAligned(seg,del0,del1,midPointOfShorter,minDelLength,maxDel);for(;;){if(-1==r){const p1=point_Point.middle(seg.B(1),lowP1),p2=point_Point.middle(seg.B(2),lowP2);highP1=seg.B(1),highP2=seg.B(2),seg=new BezierSeg(start,p1,p2,end)}else{const p1=point_Point.middle(seg.B(1),highP1),p2=(seg.B(2),highP2);lowP1=seg.B(1),lowP2=seg.B(2),seg=new BezierSeg(start,p1,p2,end)}if(0==(r=this.NicelyAligned(seg,del0,del1,midPointOfShorter,minDelLength,maxDel)))return longerOrientedSeg.Segment=seg,longerOrientedSeg.Other.Segment=seg,!0;if(steps++>10)return!1}}PullControlPointToTheCircle(start,t,center,radius){const closestPointOnLine=point_Point.ProjectionToLine(start,t.highP,center),maxOffset=Math.sqrt(radius*radius-closestPointOnLine.sub(center).lengthSquared),offsetNow=t.highP.sub(closestPointOnLine),offsetLen=offsetNow.length;offsetLen>maxOffset&&(t.highP=closestPointOnLine.add(offsetNow.mul(maxOffset/offsetLen)))}NicelyAligned(longerSeg,del0,del1,midPointOfShorter,minDelLength,maxDelLen){const midDel=longerSeg.value(.5).sub(midPointOfShorter),midDelLen=midDel.length;return del0.dot(midDel)<0||del1.dot(midDel)<0||midDelLen<minDelLength-.001?1:midDelLen>maxDelLen+.001?-1:0}BaseLength(seg){return seg.value(0).sub(seg.value(1)).lengthSquared}}EdgeNudger.SqueezeBound=.2;class SimulatedAnnealing{constructor(metroGraphData,bundlingSettings){this.stepsWithProgress=0,this.metroGraphData=metroGraphData,this.bundlingSettings=bundlingSettings,this.costCalculator=new CostCalculator(this.metroGraphData,this.bundlingSettings),this.cache=new IntersectionCache(this.metroGraphData,this.bundlingSettings,this.costCalculator,this.metroGraphData.Cdt)}static FixRouting(metroGraphData,bundlingSettings){return this.FixRoutingMBP(metroGraphData,bundlingSettings,null)}static FixRoutingMBP(metroGraphData,bundlingSettings,changedPoints){return new SimulatedAnnealing(metroGraphData,bundlingSettings).FixRoutingP(changedPoints)}FixRoutingP(changedPoints){this.stationsForOptimizations=this.GetStationsForOptimizations(changedPoints),this.cache.InitializeCostCache();let step=SimulatedAnnealing.MaxStep,energy=Number.POSITIVE_INFINITY,x=this.metroGraphData.VirtualStations().map((v=>v.Position)),iteration=0;for(;iteration++<SimulatedAnnealing.MaxIterations;){const coordinatesChanged=this.TryMoveStations();if(iteration<=1&&!coordinatesChanged)return!1;if(!coordinatesChanged)break;const oldEnergy=energy;energy=CostCalculator.Cost(this.metroGraphData,this.bundlingSettings),step=this.UpdateMaxStep(step,oldEnergy,energy);const oldX=x;if(x=this.metroGraphData.VirtualStations().map((v=>v.Position)),step<SimulatedAnnealing.MinStep||this.Converged(step,oldX,x))break}return!0}static stationsArePositionedCorrectly(metroGraphData){for(const e of metroGraphData.VirtualEdges())if(!this.edgeIsPositionedCorrectly(e,metroGraphData))return!1;return!0}static edgeIsPositionedCorrectly(e,metroGraphData){const u=e[0],v=e[1],allowedToIntersect=metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(u,v),ls=LineSegment.mkPP(u.Position,v.Position),intersected=Array.from(metroGraphData.looseIntersections.obstacleTree.GetNodeItemsIntersectingRectangle(ls.boundingBox)).filter((poly=>!allowedToIntersect.has(poly))).filter((poly=>Curve.CurvesIntersect(ls,poly)));return!(intersected.length>0)||(EdgeNudger.ShowHubs(metroGraphData,null,null,"/tmp/badcross.svg",[debugCurve_DebugCurve.mkDebugCurveTWCI(200,1,"Brown",ls),debugCurve_DebugCurve.mkDebugCurveTWCI(200,1,"Red",curveFactory_CurveFactory.mkCircle(2,u.Position)),debugCurve_DebugCurve.mkDebugCurveTWCI(200,1,"Blue",curveFactory_CurveFactory.mkCircle(5,v.Position)),debugCurve_DebugCurve.mkDebugCurveTWCI(100,1,"Blue",curveFactory_CurveFactory.mkCircle(5,v.Position))].concat(intersected.map((p=>debugCurve_DebugCurve.mkDebugCurveTWCI(100,1,"Pink",p))))),!1)}GetStationsForOptimizations(changedPoints){if(null==changedPoints)return new Set(this.metroGraphData.VirtualStations());{const result=new Set;for(const p of changedPoints){const s=this.metroGraphData.PointToStations.get(p);s&&!s.IsReal&&result.add(s)}return result}}Converged(step,oldx,newx){let den=0,num=0;for(let i=0;i<oldx.length;i++)num+=oldx[i].sub(newx[i]).lengthSquared,den+=oldx[i].lengthSquared;return Math.sqrt(num/den)<SimulatedAnnealing.MinRelativeChange}UpdateMaxStep(step,oldEnergy,newEnergy){return newEnergy+1<oldEnergy?(this.stepsWithProgress++,this.stepsWithProgress>=5&&(this.stepsWithProgress=0,step=Math.min(SimulatedAnnealing.MaxStep,step/.8))):(this.stepsWithProgress=0,step*=.8),step}TryMoveStations(){let coordinatesChanged=!1;const movedStations=new Set;for(const node of this.stationsForOptimizations)if(this.TryMoveStation(node)){coordinatesChanged=!0,movedStations.add(node);for(const adj of node.Neighbors)adj.IsReal||movedStations.add(adj)}return this.stationsForOptimizations=movedStations,coordinatesChanged}TryMoveStation(s){let direction=this.BuildDirection(s);if(0==direction.length)return!1;let stepLength=this.BuildStepLength(s,direction);if(stepLength<SimulatedAnnealing.MinStep&&(direction=function RandomPoint(){return new point_Point(1+2*random(),1+2*random())}(),stepLength=this.BuildStepLength(s,direction),stepLength<SimulatedAnnealing.MinStep))return!1;const step=direction.mul(stepLength),newPosition=s.Position.add(step);return!this.metroGraphData.PointToStations.has(newPosition)&&(!!this.moveIsLegalForAdjacentBundles(s,newPosition)&&(this.metroGraphData.MoveNode(s,newPosition),this.cache.UpdateCostCache(s),!0))}moveIsLegalForAdjacentBundles(s,sNewPosition){for(const poly of this.metroGraphData.looseIntersections.obstacleTree.AllHitItems(Rectangle.mkOnPoints([sNewPosition]),(poly=>Curve.PointRelativeToCurveLocation(sNewPosition,poly)!=PointLocation.Outside)))if(0==s.getELP().has(poly))return!1;for(const t of s.Neighbors){const obstaclesToIgnore=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,s);if(!this.metroGraphData.cdtIntersections.EdgeIsLegal_(t.Position,sNewPosition,t.CdtTriangle,obstaclesToIgnore))return!1}return!0}BuildDirection(node){const forceInk=this.BuildForceForInk(node),forcePL=this.BuildForceForPathLengths(node),forceR=this.BuildForceForRadius(node),forceBundle=this.BuildForceForBundle(node),force=forceInk.add(forcePL.add(forceR.add(forceBundle)));return force.length<.1?new point_Point(0,0):force.normalize()}BuildStepLength(node,direction){let stepLength=SimulatedAnnealing.MinStep,costGain=this.CostGain(node,node.Position.add(direction.mul(stepLength)));if(costGain<.01)return 0;for(;2*stepLength<=SimulatedAnnealing.MaxStep;){const newCostGain=this.CostGain(node,node.Position.add(direction.mul(2*stepLength)));if(newCostGain<=costGain)break;stepLength*=2,costGain=newCostGain}return stepLength}CostGain(node,newPosition){const MInf=-12345678,rGain=this.costCalculator.RadiusGain(node,newPosition);if(rGain<MInf)return MInf;const bundleGain=this.costCalculator.BundleGain(node,newPosition);if(bundleGain<MInf)return MInf;return rGain+this.costCalculator.InkGain(node,newPosition)+this.costCalculator.PathLengthsGain(node,newPosition)+bundleGain}BuildForceForInk(node){let direction=new point_Point(0,0);for(const adj of node.Neighbors){const p=adj.Position.sub(node.Position);direction=direction.add(p.normalize())}return direction.mul(this.bundlingSettings.InkImportance)}BuildForceForPathLengths(node){let direction=new point_Point(0,0);for(const mni of this.metroGraphData.MetroNodeInfosOfNode(node)){const metroline=mni.Metroline,u=mni.PolyPoint.next.point,v=mni.PolyPoint.prev.point,p1=u.sub(node.Position),p2=v.sub(node.Position);direction=direction.add(p1.div(p1.length*metroline.IdealLength)),direction=direction.add(p2.div(p2.length*metroline.IdealLength))}return direction.mul(this.bundlingSettings.PathLengthImportance)}BuildForceForRadius(node){let direction=new point_Point(0,0);const idealR=node.cachedIdealRadius,t={touchedObstacles:[]};if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(node,node.Position,idealR,t))throw EdgeNudger.ShowHubs(this.metroGraphData,null,node,"/tmp/hubs.svg",[debugCurve_DebugCurve.mkDebugCurveTWCI(255,1,"Brown",Intersections.containingPoly),debugCurve_DebugCurve.mkDebugCurveTWCI(100,1,"Blue",curveFactory_CurveFactory.mkCircle(idealR,node.Position))]),new Error;for(const d of t.touchedObstacles){const lforce=2*(1-d[1].sub(node.Position).length/idealR),dir=node.Position.sub(d[1]).normalize();direction=direction.add(dir.mul(lforce))}return direction.mul(this.bundlingSettings.HubRepulsionImportance)}BuildForceForBundle(station){let direction=new point_Point(0,0);for(const adjStation of station.Neighbors){SimulatedAnnealing.debcount++;const idealWidth=this.metroGraphData.GetWidthSSN(station,adjStation,this.bundlingSettings.EdgeSeparation),t={closestDist:[]};this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(station,adjStation,station.Position,adjStation.Position,idealWidth/2,t)||EdgeNudger.ShowHubs(this.metroGraphData,null,station,"/tmp/inside_forbid.svg",[debugCurve_DebugCurve.mkDebugCurveTWCI(100,.2,"Blue",LineSegment.mkPP(station.Position,adjStation.Position)),debugCurve_DebugCurve.mkDebugCurveTWCI(100,.2,"Red",curveFactory_CurveFactory.mkCircle(2,station.Position)),debugCurve_DebugCurve.mkDebugCurveTWCI(100,.2,"Red",curveFactory_CurveFactory.mkCircle(3,adjStation.Position))]);for(const d of t.closestDist){const lforce=2*(1-d[0].sub(d[1]).length/(idealWidth/2)),dir=d[0].sub(d[1]).normalize().neg();direction=direction.add(dir.mul(lforce))}}return direction.mul(this.bundlingSettings.BundleRepulsionImportance)}}SimulatedAnnealing.MaxIterations=100,SimulatedAnnealing.MaxStep=50,SimulatedAnnealing.MinStep=1,SimulatedAnnealing.MinRelativeChange=5e-4,SimulatedAnnealing.debcount=0;class StationPositionsAdjuster{constructor(metroGraphData,bundlingSettings){this.metroGraphData=metroGraphData,this.bundlingSettings=bundlingSettings}static FixRouting(metroGraphData,bundlingSettings){const adjuster=new StationPositionsAdjuster(metroGraphData,bundlingSettings);adjuster.GlueConflictingStations(),adjuster.UnglueEdgesFromBundleToSaveInk(!0);let step=0;for(;++step<10;){let progress=adjuster.GlueConflictingStations();if(progress||(progress=adjuster.RelaxConstrainedEdges()),progress||(progress=step<=3&&adjuster.UnglueEdgesFromBundleToSaveInk(!1)),progress||(progress=adjuster.GlueCollinearNeighbors(step)),progress||(progress=3==step&&adjuster.RemoveDoublePathCrossings()),!progress)break}for(metroGraphData.cdtIntersections.ComputeForcesForBundles=!0,adjuster.RemoveDoublePathCrossings(),adjuster.UnglueEdgesFromBundleToSaveInk(!0);adjuster.GlueConflictingStations(););metroGraphData.Initialize(!0)}GlueConflictingStations(){const circlesHierarchy=this.GetCirclesHierarchy();if(null==circlesHierarchy)return!1;const gluingMap=new Map,gluedDomain=new Set;if(CrossRectangleNodesSameType(circlesHierarchy,circlesHierarchy,((i,j)=>this.TryToGlueStations(i,j,gluingMap,gluedDomain))),0==gluingMap.size)return!1;for(let i=0;i<this.metroGraphData.Edges.length;i++)this.RegenerateEdge(gluingMap,i);const affectedPoints=new PointSet;for(const s of gluedDomain){affectedPoints.add(s.Position);for(const neig of s.Neighbors)neig.IsReal||affectedPoints.add(neig.Position)}return this.metroGraphData.Initialize(!1),SimulatedAnnealing.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,affectedPoints),!0}GetCirclesHierarchy(){for(const v of this.metroGraphData.VirtualStations())v.Radius=this.GetCurrentHubRadius(v);return CreateRectNodeOnArrayOfRectNodes(this.metroGraphData.VirtualStations().map((function rectNodeOfStation(i){const p=i.Position,r=Math.max(i.Radius,5),del=new point_Point(r,r),b=Rectangle.mkPP(p.add(del),p.sub(del));return mkRectangleNode(i,b)})))}GetCurrentHubRadius(node){if(node.IsReal)return node.BoundaryCurve.boundingBox.diagonal/2;{const idealR=node.cachedIdealRadius;let r=this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(node,node.Position,idealR);for(const adj of node.Neighbors)r=Math.min(r,node.Position.sub(adj.Position).length);return r}}TryToGlueStations(i,j,gluingMap,gluedDomain){if(!setsAreEqual(i.getELP(),j.getELP()))return!1;i.Position.sub(j.Position).length>=Math.max(i.Radius,5)+Math.max(j.Radius,5)||this.TryGlueOrdered(i,j,gluedDomain,gluingMap)||this.TryGlueOrdered(j,i,gluedDomain,gluingMap)}TryGlueOrdered(i,j,gluedDomain,gluingMap){return!(gluingMap.has(i)||gluedDomain.has(i)||!this.StationGluingIsAllowed(i,j,gluingMap))&&(this.Map(i,j,gluedDomain,gluingMap),!0)}Map(i,j,gluedDomain,gluingMap){gluingMap.set(i,j),gluedDomain.add(j)}StationGluingIsAllowed(i,j,gluingMap){for(const adj of i.Neighbors){const k=StationPositionsAdjuster.Glued(adj,gluingMap),obstaclesToIgnore=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(k,i);if(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(k,j,obstaclesToIgnore))return!1}return!(this.ComputeCostDeltaAfterStationGluing(i,j,gluingMap)<0)}ComputeCostDeltaAfterStationGluing(i,j,gluingMap){const d=i.Position.sub(j.Position).length;if(i.Radius>=d||j.Radius>=d)return 1;let gain=0;const oldInk=this.metroGraphData.Ink;let newInk=this.metroGraphData.Ink-j.Position.sub(i.Position).length;for(const adj of i.Neighbors){const k=StationPositionsAdjuster.Glued(adj,gluingMap);newInk-=k.Position.sub(i.Position).length,newInk+=0==this.metroGraphData.RealEdgeCount(k,j)?k.Position.sub(j.Position).length:0}gain+=CostCalculator.InkError(oldInk,newInk,this.bundlingSettings);for(const metroInfo of this.metroGraphData.MetroNodeInfosOfNode(i)){const oldLength=metroInfo.Metroline.Length;let newLength=metroInfo.Metroline.Length;const pi=metroInfo.PolyPoint,pa=pi.prev,pb=pi.next;newLength-=pa.point.sub(i.Position).length+pb.point.sub(i.Position).length,newLength+=pa.point.sub(j.Position).length+pb.point.sub(j.Position).length,gain+=CostCalculator.PathLengthsError(oldLength,newLength,metroInfo.Metroline.IdealLength,this.bundlingSettings)}return gain}RegenerateEdge(gluingMap,edgeIndex){const poly=this.metroGraphData.Metrolines[edgeIndex].Polyline;for(const p of poly)if(!this.metroGraphData.PointToStations.has(p))return;let atLeastOnGlued=!1;for(const p of poly)if(gluingMap.has(this.metroGraphData.PointToStations.get(p))){atLeastOnGlued=!0;break}if(!atLeastOnGlued)return;const metrolines=Array.from(poly).map((p=>this.metroGraphData.PointToStations.get(p)));this.metroGraphData.Edges[edgeIndex].curve=Polyline.mkFromPoints(StationPositionsAdjuster.GluedPolyline(metrolines,gluingMap))}static GluedPolyline(metroline,gluedMap){let i;StationPositionsAdjuster.debCount++;const ret=new lib_src.B;ret.push(metroline[0]);const seenStations=new Set;for(i=1;i<metroline.length-1;i++){const station=StationPositionsAdjuster.Glued(metroline[i],gluedMap);if(seenStations.has(station))for(;ret.top!=station;)seenStations.delete(ret.pop());else point_Point.closeDistEps(station.Position,ret.top.Position)||(seenStations.add(station),ret.push(station))}return ret.push(metroline[i]),Array.from(ret).reverse().map((n=>n.Position))}static Glued(i,gluedMap){var _a;return null!==(_a=gluedMap.get(i))&&void 0!==_a?_a:i}UnglueEdgesFromBundleToSaveInk(alwaysExecuteSA){const segsToPolylines=new PointPairMap;this.ink=this.metroGraphData.Ink,this.polylineLength=new Map;for(const metroline of this.metroGraphData.Metrolines){this.polylineLength.set(metroline,metroline.Length);for(let pp=metroline.Polyline.startPoint;null!=pp.next;pp=pp.next){addToPointPairMap(segsToPolylines,new PointPair(pp.point,pp.next.point),metroline)}}const affectedPoints=new PointSet;let progress=!1;for(const metroline of this.metroGraphData.Metrolines){const obstaclesAllowedToIntersect=setIntersection(this.metroGraphData.PointToStations.get(metroline.Polyline.start).getELP(),this.metroGraphData.PointToStations.get(metroline.Polyline.end).getELP());this.TrySeparateOnPolyline(metroline,segsToPolylines,affectedPoints,obstaclesAllowedToIntersect)&&(progress=!0)}return progress&&this.metroGraphData.Initialize(!1),(alwaysExecuteSA||progress)&&SimulatedAnnealing.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,alwaysExecuteSA?null:affectedPoints),progress}TrySeparateOnPolyline(metroline,segsToPolylines,affectedPoints,obstaclesAllowedToIntersect){let progress=!1,relaxing=!0;for(;relaxing;){relaxing=!1;for(let p=metroline.Polyline.startPoint;null!=p.next&&null!=p.next.next;p=p.next)this.TryShortcutPolypoint(p,segsToPolylines,affectedPoints,obstaclesAllowedToIntersect)&&(relaxing=!0);relaxing&&(progress=!0)}return progress}TryShortcutPolypoint(pp,segsToPolylines,affectedPoints,obstaclesAllowedToIntersect){return!!this.SeparationShortcutAllowed(pp,segsToPolylines,obstaclesAllowedToIntersect)&&(affectedPoints.add(pp.point),affectedPoints.add(pp.next.point),affectedPoints.add(pp.next.next.point),this.RemoveShortcuttedPolypoint(pp,segsToPolylines),!0)}SeparationShortcutAllowed(pp,segsToPolylines,obstaclesAllowedToIntersect){const a=pp.point,b=pp.next.point,c=pp.next.next.point,aStation=this.metroGraphData.PointToStations.get(a),bStation=this.metroGraphData.PointToStations.get(b),cStation=this.metroGraphData.PointToStations.get(c),aUc=uniteSets(aStation.getELP(),cStation.getELP()),obstaclesToIgnore=function setIntersectionOfArray(arr){if(0==arr.length)return new Set;let ret=arr[0];for(let i=1;i<arr.length;i++)ret=setIntersection(ret,arr[i]);return ret}([obstaclesAllowedToIntersect,bStation.getELP(),aUc]);if(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(aStation,cStation,obstaclesToIgnore))return!1;return!(this.GetInkgain(pp,segsToPolylines,a,b,c)<0)}GetInkgain(pp,segsToPolylines,a,b,c){const[abPolylines,bcPolylines,abcPolylines]=this.FindPolylines(pp,segsToPolylines);let gain=0;const oldInk=this.ink;let newInk=this.ink;const ab=a.sub(b).length,bc=b.sub(c).length,ac=a.sub(c).length;abPolylines.size==abcPolylines.size&&(newInk-=ab),bcPolylines.size==abcPolylines.size&&(newInk-=bc);const t=segsToPolylines.get(new PointPair(a,c));t&&0!=t.size||(newInk+=ac),gain+=CostCalculator.InkError(oldInk,newInk,this.bundlingSettings);for(const metroline of abcPolylines){const oldLength=this.polylineLength.get(metroline),newLength=oldLength-(ab+bc-ac);gain+=CostCalculator.PathLengthsError(oldLength,newLength,metroline.IdealLength,this.bundlingSettings)}let nowR=this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(a));const widthABC=this.metroGraphData.GetWidthAN(Array.from(abcPolylines),this.bundlingSettings.EdgeSeparation),widthABD=this.metroGraphData.GetWidthAN(Array.from(substractSets(abPolylines,abcPolylines)),this.bundlingSettings.EdgeSeparation);let idealR=HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(nowR,a,c,b,widthABC,widthABD,this.bundlingSettings);idealR>nowR&&(gain-=CostCalculator.RError(idealR,nowR,this.bundlingSettings)),nowR=this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(c));const widthCBD=this.metroGraphData.GetWidthAN(Array.from(substractSets(bcPolylines,abcPolylines)),this.bundlingSettings.EdgeSeparation);return idealR=HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(nowR,c,b,a,widthCBD,widthABC,this.bundlingSettings),idealR>nowR&&(gain-=CostCalculator.RError(idealR,nowR,this.bundlingSettings)),gain}RemoveShortcuttedPolypoint(pp,segsToPolylines){const a=pp.point,b=pp.next.point,c=pp.next.next.point,[abPolylines,bcPolylines,abcPolylines]=this.FindPolylines(pp,segsToPolylines),ab=distPP(a,b),bc=distPP(b,c),ac=distPP(a,c);abPolylines.size==abcPolylines.size&&(this.ink-=ab),bcPolylines.size==abcPolylines.size&&(this.ink-=bc);const t=segsToPolylines.get(new PointPair(a,c));t&&0!=t.size||(this.ink+=ac);for(const metroline of abcPolylines){const l=this.polylineLength.get(metroline);this.polylineLength.set(metroline,l-(ab+bc-ac))}for(const metroline of abcPolylines){const pp=Array.from(metroline.Polyline.polylinePoints()).find((p=>p.point.equal(b)));this.RemovePolypoint(pp),removeFromPointPairMapTuple(segsToPolylines,[a,b],metroline),removeFromPointPairMapTuple(segsToPolylines,[b,c],metroline),val=metroline,addToPointPairMap(segsToPolylines,new PointPair((key=[a,c])[0],key[1]),val)}var key,val}FindPolylines(pp,segsToPolylines){const a=pp.point,b=pp.next.point,c=pp.next.next.point,abPolylines=segsToPolylines.get_(a,b),bcPolylines=segsToPolylines.get_(b,c);return[abPolylines,bcPolylines,setIntersection(abPolylines,bcPolylines)]}RemovePolypoint(p){const prev=p.prev,next=p.next;prev.next=next,next.prev=prev}GlueCollinearNeighbors(step){const affectedPoints=new PointSet;let progress=!1;for(const node of this.metroGraphData.Stations)this.GlueCollinearNeighborsSPN(node,affectedPoints,step)&&(progress=!0);return progress&&(this.metroGraphData.Initialize(!1),SimulatedAnnealing.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,affectedPoints)),progress}GlueCollinearNeighborsSPN(node,affectedPoints,step){if(node.Neighbors.length<=1)return!1;const gluedEdges=new TupleMap,neighbors=node.Neighbors;for(let i=0;i<neighbors.length;i++)this.TryToGlueEdges(node,neighbors[i],neighbors[(i+1)%neighbors.length],gluedEdges,step);if(gluedEdges.isEmpty)return!1;for(const keyValueTriple of gluedEdges)this.GlueEdge(keyValueTriple),affectedPoints.add(keyValueTriple[0].Position),affectedPoints.add(keyValueTriple[1].Position),affectedPoints.add(keyValueTriple[2]);return!0}TryToGlueEdges(node,a,b,gluedEdges,step){if(point_Point.anglePCP(a.Position,node.Position,b.Position)<this.bundlingSettings.AngleThreshold){const la=distPP(a.Position,node.Position),lb=distPP(b.Position,node.Position),ratio=Math.min(la,lb)/Math.max(la,lb);if(ratio<.05)return;if(la<lb){if(this.EdgeGluingIsAllowedSSS(node,a,b))return void this.AddEdgeToGlue(node,b,a,a.Position,gluedEdges)}else if(this.EdgeGluingIsAllowedSSS(node,b,a))return void this.AddEdgeToGlue(node,a,b,b.Position,gluedEdges);if(step<5&&ratio>.5){const newPosition=this.ConstructGluingPoint(node,a,b);this.EdgeGluingIsAllowedSSSP(node,a,b,newPosition)&&this.AddEdgeToGlue(node,b,a,newPosition,gluedEdges)}}}ConstructGluingPoint(node,a,b){const len=Math.min(distPP(a.Position,node.Position),distPP(b.Position,node.Position)/2),dir=a.Position.sub(node.Position).normalize().add(b.Position.sub(node.Position).normalize());return node.Position.add(dir.mul(len/2))}EdgeGluingIsAllowedSSS(node,a,b){if(a.IsReal||b.IsReal)return!1;if(!setsAreEqual(a.getELP(),b.getELP()))return!1;if(!this.metroGraphData.cdtIntersections.EdgeIsLegal(a,b,a.Position,b.Position))return!1;const enterableForEdgeNodeB=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(node,b);if(InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(LineSegment.mkPP(node.Position,a.Position),this.metroGraphData.LooseTree).find((ii=>!enterableForEdgeNodeB.has(ii.seg1))))return!1;if(InteractiveEdgeRouter.IntersectionsOfLineAndRectangleNodeOverPolylineLR(LineSegment.mkPP(a.Position,b.Position),this.metroGraphData.LooseTree).find((ii=>!enterableForEdgeNodeB.has(ii.seg1))))return!1;return!(this.ComputeCostDeltaAfterEdgeGluing(node,a,b,a.Position)<0)}EdgeGluingIsAllowedSSSP(node,a,b,gluingPoint){if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(gluingPoint,0,setIntersection(a.getELP(),b.getELP())))return!1;if(!this.metroGraphData.cdtIntersections.EdgeIsLegal(node,null,node.Position,gluingPoint))return!1;if(!this.metroGraphData.cdtIntersections.EdgeIsLegal(a,null,a.Position,gluingPoint))return!1;if(!this.metroGraphData.cdtIntersections.EdgeIsLegal(b,null,b.Position,gluingPoint))return!1;return!(this.ComputeCostDeltaAfterEdgeGluing(node,a,b,gluingPoint)<0)}ComputeCostDeltaAfterEdgeGluing(node,a,b,newp){let gain=0;const oldInk=this.metroGraphData.Ink,newInk=this.metroGraphData.Ink-distPP(node.Position,b.Position)-distPP(node.Position,a.Position)+distPP(node.Position,newp)+distPP(newp,a.Position)+distPP(newp,b.Position);gain+=CostCalculator.InkError(oldInk,newInk,this.bundlingSettings);for(const metroline of this.metroGraphData.GetIjInfo(node,b).Metrolines){const oldLength=metroline.Length,newLength=metroline.Length-distPP(node.Position,b.Position)+distPP(node.Position,newp)+distPP(newp,b.Position);gain+=CostCalculator.PathLengthsError(oldLength,newLength,metroline.IdealLength,this.bundlingSettings)}for(const metroline of this.metroGraphData.GetIjInfo(node,a).Metrolines){const oldLength=metroline.Length,newLength=metroline.Length-distPP(node.Position,a.Position)+distPP(node.Position,newp)+distPP(newp,a.Position);gain+=CostCalculator.PathLengthsError(oldLength,newLength,metroline.IdealLength,this.bundlingSettings)}const id2=node.cachedIdealRadius,nowR=this.GetCurrentHubRadius(node),idealR=HubRadiiCalculator.GetMinRadiusForTwoAdjacentBundles(nowR,node,node.Position,a,b,this.metroGraphData,this.bundlingSettings);return idealR>nowR&&(gain+=CostCalculator.RError(idealR,nowR,this.bundlingSettings)),id2>distPP(node.Position,newp)&&!node.IsReal&&(gain-=CostCalculator.RError(id2,distPP(node.Position,newp),this.bundlingSettings)),gain}AddEdgeToGlue(node,b,a,newp,gluedEdges){gluedEdges.has(a,node)||gluedEdges.has(b,node)||gluedEdges.has(node,a)||gluedEdges.has(node,b)||(gluedEdges.set(node,a,newp),gluedEdges.set(node,b,newp))}GlueEdge(keyValuePair){const node=keyValuePair[0],a=keyValuePair[1],newp=keyValuePair[2];for(const polylinePoint of node.MetroNodeInfos.map((i=>i.PolyPoint)))null!=polylinePoint.next&&polylinePoint.next.point.equal(a.Position)?this.SplitPolylinePoint(polylinePoint,newp):null!=polylinePoint.prev&&polylinePoint.prev.point.equal(a.Position)&&this.SplitPolylinePoint(polylinePoint.prev,newp)}SplitPolylinePoint(node,pointToInsert){if(node.point==pointToInsert||node.next.point==pointToInsert)return;const p=PolylinePoint.mkFromPoint(pointToInsert);p.polyline=node.polyline,p.next=node.next,p.prev=node,p.next.prev=p,p.prev.next=p}RelaxConstrainedEdges(){const affectedPoints=new PointSet;let progress=!1;for(const edge of this.metroGraphData.VirtualEdges())this.RelaxConstrainedEdge(edge[0],edge[1],affectedPoints)&&(progress=!0);return progress&&(this.metroGraphData.Initialize(!1),SimulatedAnnealing.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,affectedPoints)),progress}RelaxConstrainedEdge(a,b,affectedPoints){const idealWidth=this.metroGraphData.GetWidthSSN(a,b,this.bundlingSettings.EdgeSeparation),t={closestDist:new Array};this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(a,b,a.Position,b.Position,.99*idealWidth/2,t);const closestPoints=t.closestDist;if(closestPoints.length>0){let bestPoint,bestDist=-1;for(const d of closestPoints){if(Math.min(distPP(a.Position,d[1]),distPP(b.Position,d[1]))/distPP(a.Position,b.Position)<.1)continue;const dist=distPP(d[0],d[1]);(-1==bestDist||dist<bestDist)&&(bestDist=dist,bestPoint=d[1])}if(-1==bestDist)return!1;if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(bestPoint,0,setIntersection(a.getELP(),b.getELP())))return!1;affectedPoints.add(bestPoint),affectedPoints.add(a.Position),affectedPoints.add(b.Position);for(const metroline of this.metroGraphData.GetIjInfo(a,b).Metrolines){let pp=null;for(const ppp of metroline.Polyline.polylinePoints())if(ppp.point.equal(a.Position)){pp=ppp;break}null!=pp.next&&pp.next.point.equal(b.Position)?this.SplitPolylinePoint(pp,bestPoint):this.SplitPolylinePoint(pp.prev,bestPoint)}return!0}return!1}RemoveDoublePathCrossings(){const progress=new PathFixer(this.metroGraphData,this.metroGraphData.PointIsAcceptableForEdge.bind(this)).run();return progress&&(this.metroGraphData.Initialize(!1),SimulatedAnnealing.FixRouting(this.metroGraphData,this.bundlingSettings)),progress}}StationPositionsAdjuster.debCount=0;class MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph{constructor(sourceVisVertices,targetVisVertices,visibilityGraph){this.upperBound=Number.POSITIVE_INFINITY,this._visGraph=visibilityGraph,visibilityGraph.ClearPrevEdgesTable();for(const v of visibilityGraph.Vertices())v.Distance=Number.POSITIVE_INFINITY;this.sources=sourceVisVertices,this.targets=new Set(targetVisVertices)}GetPath(){const pq=new GenericBinaryHeapPriorityQueue;for(const v of this.sources)v.Distance=0,pq.Enqueue(v,0);for(;!pq.IsEmpty()&&(this._current=pq.Dequeue(),!this.targets.has(this._current));){for(const e of this._current.OutEdges)this.PassableOutEdge(e)&&this.ProcessNeighbor(pq,e,e.Target);for(const e of this._current.InEdges.filter(this.PassableInEdge.bind))this.ProcessNeighbor(pq,e,e.Source)}return null==this._visGraph.PreviosVertex(this._current)?null:this.CalculatePath()}PassableOutEdge(e){return this.targets.has(e.Target)||!MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e)}PassableInEdge(e){return this.targets.has(e.Source)||!MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph.IsForbidden(e)}static IsForbidden(e){return(null!=e.IsPassable&&!e.IsPassable()||e)instanceof TollFreeVisibilityEdge}ProcessNeighbor(pq,l,v){const len=l.Length,c=this._current.Distance+len;c>=this.upperBound||(this.targets.has(v)&&(this.upperBound=c,this.closestTarget=v),null==this._visGraph.PreviosVertex(v)?(v.Distance=c,this._visGraph.SetPreviousEdge(v,l),pq.Enqueue(v,c)):c<v.Distance&&(v.Distance=c,this._visGraph.SetPreviousEdge(v,l),pq.DecreasePriority(v,c)))}CalculatePath(){if(null==this.closestTarget)return null;const ret=new Array;let v=this.closestTarget;do{ret.push(v),v=this._visGraph.PreviosVertex(v)}while(v.Distance>0);return ret.push(v),ret.reverse()}}class BundleRouter extends Algorithm{constructor(edgesToRoute,shortestPathRouter,visibilityGraph,bundlingSettings,loosePadding,tightHierarchy,looseHierarchy,edgeLooseEnterable,edgeTightEnterable,loosePolylineOfPort){super(null),this.bundlingSettings=bundlingSettings,this.edgesToRoute=edgesToRoute,this.regularEdges=edgesToRoute.filter((e=>e.source!=e.target)),this.VisibilityGraph=visibilityGraph,this.shortestPathRouter=shortestPathRouter,this.LoosePadding=loosePadding,this.LooseHierarchy=looseHierarchy,this.TightHierarchy=tightHierarchy,this.EdgeLooseEnterable=edgeLooseEnterable,this.EdgeTightEnterable=edgeTightEnterable,this.loosePolylineOfPort=loosePolylineOfPort}ThereAreOverlaps(hierarchy){return FindIntersectionWithProperty(hierarchy,hierarchy,Curve.CurvesIntersect)}run(){this.ThereAreOverlaps(this.TightHierarchy)?this.Status=BundlingStatus.Overlaps:(this.FixLocationsForHookAnywherePorts(this.edgesToRoute),this.RoutePathsWithSteinerDijkstra()?(this.FixChildParentEdges(),this.bundlingSettings.StopAfterShortestPaths||this.OrderOptimizeNudgeEtc(),this.RouteSelfEdges(),this.FixArrowheads()):this.Status=BundlingStatus.EdgeSeparationIsTooLarge)}OrderOptimizeNudgeEtc(){const metroGraphData=new MetroGraphData(this.regularEdges,this.LooseHierarchy,this.TightHierarchy,this.bundlingSettings,this.shortestPathRouter.CdtProperty,this.EdgeLooseEnterable,this.EdgeTightEnterable,this.loosePolylineOfPort);StationPositionsAdjuster.FixRouting(metroGraphData,this.bundlingSettings),new EdgeNudger(metroGraphData,this.bundlingSettings).run()}FixChildParentEdges(){for(const edge of this.regularEdges){const sPort=edge.sourcePort,ePort=edge.targetPort;if(sPort.Curve.boundingBox.containsRect(ePort.Curve.boundingBox)){const ii=Curve.intersectionOne(sPort.Curve,LineSegment.mkPP(edge.curve.start,edge.curve.end),!1);edge.curve.startPoint.point=ii.x}if(ePort.Curve.boundingBox.containsRect(sPort.Curve.boundingBox)){const ii=Curve.intersectionOne(ePort.Curve,LineSegment.mkPP(edge.curve.start,edge.curve.end),!0);edge.curve.endPoint.point=ii.x}}}static CreateConstrainedDelaunayTriangulation(looseHierarchy){const obstacles=Array.from(looseHierarchy.GetAllLeaves());let rectangle=looseHierarchy.irect;return rectangle=rectangle.pad(rectangle.diagonal/4),BundleRouter.GetConstrainedDelaunayTriangulation(obstacles.concat([rectangle.perimeter()]))}static GetConstrainedDelaunayTriangulation(obstacles){const constrainedDelaunayTriangulation=new Cdt(null,obstacles,null);return constrainedDelaunayTriangulation.run(),constrainedDelaunayTriangulation}FixLocationsForHookAnywherePorts(edges){for(const edge of edges){let isHookPort=edge.sourcePort instanceof HookUpAnywhereFromInsidePort;if(isHookPort){const hookPort=edge.sourcePort;hookPort.SetLocation(this.FigureOutHookLocation(hookPort.LoosePolyline,edge.targetPort,edge))}else if(isHookPort=edge.targetPort instanceof HookUpAnywhereFromInsidePort,isHookPort){const hookPort=edge.targetPort;hookPort.SetLocation(this.FigureOutHookLocation(hookPort.LoosePolyline,edge.sourcePort,edge))}}}FigureOutHookLocation(poly,otherEdgeEndPort,edgeGeom){const clusterPort=otherEdgeEndPort;return null==clusterPort?this.FigureOutHookLocationForSimpleOtherPort(poly,otherEdgeEndPort,edgeGeom):this.FigureOutHookLocationForClusterOtherPort(poly,clusterPort,edgeGeom)}FigureOutHookLocationForClusterOtherPort(poly,otherEdgeEndPort,edgeGeom){const shapes=this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(edgeGeom),path=new MultipleSourceMultipleTargetsShortestPathOnVisibilityGraph(Array.from(otherEdgeEndPort.LoosePolyline).map(this.VisibilityGraph.FindVertex.bind),Array.from(poly).map(this.VisibilityGraph.FindVertex.bind),this.VisibilityGraph).GetPath();for(const sh of shapes)sh.IsTransparent=!1;return path[path.length-1].point}FigureOutHookLocationForSimpleOtherPort(poly,otherEdgeEndPort,edgeGeom){const otherEdgeEnd=otherEdgeEndPort.Location,shapes=this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(edgeGeom),path=new SingleSourceMultipleTargetsShortestPathOnVisibilityGraph(this.VisibilityGraph.FindVertex(otherEdgeEnd),Array.from(poly).map(this.VisibilityGraph.FindVertex.bind),this.VisibilityGraph).GetPath();for(const sh of shapes)sh.IsTransparent=!1;return path[path.length-1].point}RoutePathsWithSteinerDijkstra(){return this.shortestPathRouter.VisibilityGraph=this.VisibilityGraph,this.shortestPathRouter.BundlingSettings=this.bundlingSettings,this.shortestPathRouter.geomEdges=this.regularEdges,this.shortestPathRouter.ObstacleHierarchy=this.LooseHierarchy,this.shortestPathRouter.RouteEdges(),!(null!=this.shortestPathRouter.CdtProperty&&!this.AnalyzeEdgeSeparation())}AnalyzeEdgeSeparation(){const crossedCdtEdges=new Map;this.shortestPathRouter.FillCrossedCdtEdges(crossedCdtEdges);const pathsOnCdtEdge=this.GetPathsOnCdtEdge(crossedCdtEdges),es=this.CalculateMaxAllowedEdgeSeparation(pathsOnCdtEdge);if(es>=this.bundlingSettings.EdgeSeparation)return!0;if(es<=.02){for(const e of this.regularEdges)e.curve=null;return!1}return this.bundlingSettings.EdgeSeparation=es,this.shortestPathRouter.RouteEdges(),!0}GetPathsOnCdtEdge(crossedEdges){const res=new Map;for(const edge of crossedEdges.keys())for(const cdtEdge of crossedEdges.get(edge))addToMap(res,cdtEdge,edge);return res}CalculateMaxAllowedEdgeSeparation(pathsOnCdtEdge){let l=.01,r=10;if(this.EdgeSeparationIsOkMN(pathsOnCdtEdge,r))return r;for(;Math.abs(r-l)>.01;){const cen=(l+r)/2;this.EdgeSeparationIsOkMN(pathsOnCdtEdge,cen)?l=cen:r=cen}return l}EdgeSeparationIsOkMN(pathsOnCdtEdge,separation){const total=pathsOnCdtEdge.size;if(0==total)return!0;let ok=0;for(const edge of pathsOnCdtEdge.keys())this.EdgeSeparationIsOk(edge,pathsOnCdtEdge.get(edge),separation)&&ok++;return ok/total>this.bundlingSettings.MinimalRatioOfGoodCdtEdges}EdgeSeparationIsOk(edge,paths,separation){return Array.from(paths).map((v=>v.lineWidth)).reduce(((a,b)=>a+b),0)+(paths.size-1)*separation<=edge.Capacity}RouteSelfEdges(){for(const edge of this.edgesToRoute)if(edge.source==edge.target){const t={smoothedPolyline:null};edge.curve=GeomEdge.RouteSelfEdge(edge.source.boundaryCurve,2*this.LoosePadding,t)}}FixArrowheads(){for(const edge of this.edgesToRoute)Arrowhead.trimSplineAndCalculateArrowheadsII(edge,edge.source.boundaryCurve,edge.target.boundaryCurve,edge.curve,!1)}}BundleRouter.SuperLoosePaddingCoefficient=1.1;class SdBoneEdge{constructor(visibilityEdge,source,target){this.numberOfPassedPaths=0,this.VisibilityEdge=visibilityEdge,this.Source=source,this.Target=target}get TargetPoint(){return this.Target.Point}get SourcePoint(){return this.Source.Point}get IsOccupied(){return this.numberOfPassedPaths>0}get IsPassable(){return this.Target.IsTargetOfRouting||this.Source.IsSourceOfRouting||null==this.VisibilityEdge.IsPassable||this.VisibilityEdge.IsPassable()}AddOccupiedEdge(){this.numberOfPassedPaths++}RemoveOccupiedEdge(){this.numberOfPassedPaths--}}class SdVertex{constructor(visibilityVertex){this.InBoneEdges=new Array,this.OutBoneEdges=new Array,this.VisibilityVertex=visibilityVertex}get Prev(){return null==this.PrevEdge?null:this.PrevEdge.Source==this?this.PrevEdge.Target:this.PrevEdge.Source}get Point(){return this.VisibilityVertex.point}get Cost(){return this.IsSourceOfRouting?this.cost:null==this.Prev?Number.POSITIVE_INFINITY:this.cost}set Cost(value){this.cost=value}SetPreviousToNull(){this.PrevEdge=null}}class SdShortestPath{constructor(makeTransparentShapesOfEdgeGeometryAndGetTheShapes,cdt,gates){this.EdgesToRoutes=new Map,this.EdgesToRouteSources=new Map,this.MakeTransparentShapesOfEdgeGeometry=makeTransparentShapesOfEdgeGeometryAndGetTheShapes,this.CdtProperty=cdt,this.Gates=gates}CreateGraphElements(){for(const sdVertex of this.vertexArray){const vv=sdVertex.VisibilityVertex;for(const vEdge of vv.InEdges){const boneEdge=new SdBoneEdge(vEdge,this.VisibilityVerticesToSdVerts.get(vEdge.Source),this.VisibilityVerticesToSdVerts.get(vEdge.Target)),otherSdVertex=this.VisibilityVerticesToSdVerts.get(vEdge.Source);sdVertex.InBoneEdges.push(boneEdge),otherSdVertex.OutBoneEdges.push(boneEdge)}}}CreateRoutingGraph(){this.vertexArray=[],this.VisibilityVerticesToSdVerts=new Map;for(const v of this.VisibilityGraph.Vertices()){const sdVert=new SdVertex(v);this.vertexArray.push(sdVert),this.VisibilityVerticesToSdVerts.set(v,sdVert)}this.CreateGraphElements()}RouteEdges(){this.Initialize(),this.RestoreCapacities();for(const geomEdge of this.geomEdges)this.EdgesToRoutes.set(geomEdge,this.RouteEdge(geomEdge));this.RerouteEdges();for(const geomEdge of this.geomEdges)this.SetEdgeGeometryCurve(geomEdge)}SetEdgeGeometryCurve(geomEdge){const poly=new Polyline;let curV=this.EdgesToRouteSources.get(geomEdge);poly.addPoint(curV.Point);for(const edge of this.EdgesToRoutes.get(geomEdge))edge.SourcePoint.equal(curV.Point)?(poly.addPoint(edge.TargetPoint),curV=edge.Target):(poly.addPoint(edge.SourcePoint),curV=edge.Source);geomEdge.curve=poly;geomEdge.sourcePort instanceof ClusterBoundaryPort&&SdShortestPath.ExtendPolylineStartToClusterBoundary(poly,geomEdge.sourcePort.Curve);geomEdge.targetPort instanceof ClusterBoundaryPort&&SdShortestPath.ExtendPolylineEndToClusterBoundary(poly,geomEdge.targetPort.Curve)}static ExtendPolylineEndToClusterBoundary(poly,curve){const par=curve.closestParameter(poly.end);poly.addPoint(curve.value(par))}static ExtendPolylineStartToClusterBoundary(poly,curve){const par=curve.closestParameter(poly.start);poly.PrependPoint(curve.value(par))}RerouteEdges(){this.RestoreCapacities();for(const geomEdge of this.geomEdges){const newRoute=this.RerouteEdge(geomEdge);this.EdgesToRoutes.set(geomEdge,newRoute)}}RestoreCapacities(){null!=this.CdtProperty&&this.CdtProperty.RestoreEdgeCapacities()}RerouteEdge(geomEdge){const route=this.EdgesToRoutes.get(geomEdge);for(const edge of route)edge.RemoveOccupiedEdge();return this.RouteEdge(geomEdge)}RouteEdge(geomEdge){this.CurrentEdgeGeometry=geomEdge;for(let i=0;i<this.vertexArray.length;i++){const sdv=this.vertexArray[i];sdv.SetPreviousToNull(),sdv.IsTargetOfRouting=sdv.IsSourceOfRouting=!1}const transparentShapes=this.MakeTransparentShapesOfEdgeGeometry(geomEdge),ret=this.RouteEdgeWithGroups();for(const shape of transparentShapes)shape.IsTransparent=!1;return ret}RouteEdgeWithGroups(){for(let i=0;i<2;i++){this.SetLengthCoefficient(),this.Queue=new GenericBinaryHeapPriorityQueue,this.sourceLoosePoly=this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.sourcePort,!0),this.targetLoosePoly=this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.targetPort,!1);const ret=this.RouteOnKnownSourceTargetVertices(this.CurrentEdgeGeometry.targetPort.Location.sub(this.CurrentEdgeGeometry.sourcePort.Location).normalize(),0==i);if(null!=ret)return ret;for(let j=0;j<this.vertexArray.length;j++)this.vertexArray[j].SetPreviousToNull()}throw new Error}RouteOnKnownSourceTargetVertices(pathDirection,lookingForMonotonePath){for(this.LowestCostToTarget=Number.POSITIVE_INFINITY,this.ClosestTargetVertex=null;this.Queue.count>0;){const hu={priority:0},bestNode=this.Queue.DequeueAndGetPriority(hu);if(!(hu.priority>=this.LowestCostToTarget)){for(let i=0;i<bestNode.OutBoneEdges.length;i++){const outBoneEdge=bestNode.OutBoneEdges[i];outBoneEdge.IsPassable&&this.ProcessOutcomingBoneEdge(bestNode,outBoneEdge,pathDirection,lookingForMonotonePath)}for(let i=0;i<bestNode.InBoneEdges.length;i++){const inBoneEdge=bestNode.InBoneEdges[i];inBoneEdge.IsPassable&&this.ProcessIncomingBoneEdge(bestNode,inBoneEdge,pathDirection,lookingForMonotonePath)}}}return this.GetPathAndUpdateRelatedCosts()}ProcessOutcomingBoneEdge(v,outBoneEdge,pathDirection,lookingForMonotonePath){lookingForMonotonePath&&pathDirection.dot(outBoneEdge.TargetPoint.sub(outBoneEdge.SourcePoint))<0||this.ProcessBoneEdge(v,outBoneEdge.Target,outBoneEdge)}ProcessIncomingBoneEdge(v,inBoneEdge,pathDirection,lookingForMonotonePath){lookingForMonotonePath&&pathDirection.dot(inBoneEdge.SourcePoint.sub(inBoneEdge.TargetPoint))<0||this.ProcessBoneEdge(v,inBoneEdge.Source,inBoneEdge)}ProcessBoneEdge(v,queueCandidate,boneEdge){const newCost=this.GetEdgeAdditionalCost(boneEdge,v.Cost);if(!(queueCandidate.Cost<=newCost))if(queueCandidate.Cost=newCost,queueCandidate.PrevEdge=boneEdge,this.Queue.ContainsElement(queueCandidate))this.Queue.DecreasePriority(queueCandidate,newCost);else{if(queueCandidate.IsTargetOfRouting){let costToTarget=0;return this.CurrentEdgeGeometry.targetPort instanceof ClusterBoundaryPort&&(costToTarget=this.LengthCoefficient*queueCandidate.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length),void(newCost+costToTarget<this.LowestCostToTarget&&(this.LowestCostToTarget=newCost+costToTarget,this.ClosestTargetVertex=queueCandidate))}this.Enqueue(queueCandidate)}}GetPathAndUpdateRelatedCosts(){let current=this.ClosestTargetVertex;if(null==current)return null;const result=new Array;for(;null!=current.PrevEdge;)result.push(current.PrevEdge),this.RegisterPathInBoneEdge(current.PrevEdge),current=current.Prev;return this.EdgesToRouteSources.set(this.CurrentEdgeGeometry,current),result.reverse(),result}RegisterPathInBoneEdge(boneEdge){boneEdge.AddOccupiedEdge(),null!=this.CdtProperty&&0!=this.BundlingSettings.CapacityOverflowCoefficient&&this.UpdateResidualCostsOfCrossedCdtEdges(boneEdge)}UpdateResidualCostsOfCrossedCdtEdges(boneEdge){for(const cdtEdge of boneEdge.CrossedCdtEdges)this.AdjacentToSourceOrTarget(cdtEdge)||(cdtEdge.ResidualCapacity==cdtEdge.Capacity?cdtEdge.ResidualCapacity-=this.CurrentEdgeGeometry.lineWidth:cdtEdge.ResidualCapacity-=this.CurrentEdgeGeometry.lineWidth+this.BundlingSettings.EdgeSeparation)}H(v){return v.Cost+this.LengthCoefficient*v.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length}GetEdgeAdditionalCost(boneEdge,previousCost){const len=boneEdge.TargetPoint.sub(boneEdge.SourcePoint).length;return this.LengthCoefficient*len+previousCost+(boneEdge.IsOccupied?0:this.BundlingSettings.InkImportance*len)+this.CapacityOverflowCost(boneEdge)}CapacityOverflowCost(boneEdge){if(null==this.CdtProperty||0==this.BundlingSettings.CapacityOverflowCoefficient)return 0;let ret=0;for(const cdtEdge of this.CrossedCdtEdgesOfBoneEdge(boneEdge))ret+=this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier,this.BundlingSettings,this.CurrentEdgeGeometry,cdtEdge);return ret}CrossedCdtEdgesOfBoneEdge(boneEdge){return null!=boneEdge.CrossedCdtEdges?Array.from(boneEdge.CrossedCdtEdges):Array.from(boneEdge.CrossedCdtEdges=this.ThreadBoneEdgeThroughCdt(boneEdge))}ThreadBoneEdgeThroughCdt(boneEdge){const start=boneEdge.SourcePoint,currentTriangle=boneEdge.Source.Triangle,crossedEdges=new Set,end=boneEdge.TargetPoint;if(Cdt.PointIsInsideOfTriangle(end,currentTriangle))return crossedEdges;const threader=new CdtThreader(currentTriangle,start,end);for(;threader.MoveNext();){const piercedEdge=threader.CurrentPiercedEdge;this.Gates.has(piercedEdge)&&crossedEdges.add(piercedEdge)}return crossedEdges}static CostOfCrossingCdtEdge(capacityOverflMult,bundlingSettings,currentEdgeGeometry,e){let w=currentEdgeGeometry.lineWidth;e.Capacity!=e.ResidualCapacity&&(w+=bundlingSettings.EdgeSeparation);const del=e.ResidualCapacity-w;return del>=0?0:del*capacityOverflMult*-1}CostOfCrossingCdtEdgeLocal(capacityOverflMult,bundlingSettings,currentEdgeGeometry,e){return this.AdjacentToSourceOrTarget(e)?0:SdShortestPath.CostOfCrossingCdtEdge(capacityOverflMult,bundlingSettings,currentEdgeGeometry,e)}AdjacentToSourceOrTarget(e){return e.upperSite.Owner==this.sourceLoosePoly||e.lowerSite.Owner==this.sourceLoosePoly||e.upperSite.Owner==this.targetLoosePoly||e.lowerSite.Owner==this.targetLoosePoly}SetLengthCoefficient(){const idealEdgeLength=this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);this.LengthCoefficient=this.BundlingSettings.PathLengthImportance/idealEdgeLength}GetIdealDistanceBetweenSourceAndTarget(geomEdge){return geomEdge.sourcePort.Location.sub(geomEdge.targetPort.Location).length}SetPortVerticesAndObstacles(port,sources){let poly;if(port instanceof ClusterBoundaryPort){poly=port.LoosePolyline;for(const point of poly){let initialCost=0;sources&&(initialCost=this.LengthCoefficient*point.sub(this.CurrentEdgeGeometry.sourcePort.Location).length),this.AddAndEnqueueVertexToEnds(point,sources,initialCost)}}else if(port instanceof HookUpAnywhereFromInsidePort){poly=port.LoosePolyline;for(const point of poly)this.AddAndEnqueueVertexToEnds(point,sources,0)}else{this.AddAndEnqueueVertexToEnds(port.Location,sources,0);const polys=Array.from(this.ObstacleHierarchy.GetNodeItemsIntersectingRectangle(port.Curve.boundingBox));let mindiag=polys[0].boundingBox.diagonal;poly=polys[0];for(let i=1;i<polys.length;i++){const pl=polys[i],diag=pl.boundingBox.diagonal;diag<mindiag&&(mindiag=diag,poly=pl)}}return poly}Enqueue(simpleSdVertex){this.Queue.Enqueue(simpleSdVertex,this.H(simpleSdVertex))}AddAndEnqueueVertexToEnds(point,isSource,initialCost){const v=this.FindVertex(point),sdVert=this.VisibilityVerticesToSdVerts.get(v);isSource?(sdVert.IsSourceOfRouting=!0,sdVert.Cost=initialCost,this.Enqueue(sdVert)):sdVert.IsTargetOfRouting=!0}FindVertex(p){return this.VisibilityGraph.FindVertex(p)}Initialize(){this.CreateRoutingGraph(),null!=this.CdtProperty&&(this.capacityOverlowPenaltyMultiplier=SdShortestPath.CapacityOverflowPenaltyMultiplier(this.BundlingSettings),this.SetVertexTriangles(),this.CalculateCapacitiesOfTrianglulation())}CalculateCapacitiesOfTrianglulation(){for(const e of this.Gates)SdShortestPath.CalculateCdtEdgeCapacityForEdge(e)}static CalculateCdtEdgeCapacityForEdge(e){if(e.Constrained||null==e.CwTriangle||null==e.CcwTriangle)return;const startPoly=e.upperSite.Owner,endPoly=e.lowerSite.Owner;if(startPoly!=endPoly){const distA=Polygon.DistancePoint(new Polygon(startPoly),e.lowerSite.point),distB=Polygon.DistancePoint(new Polygon(endPoly),e.upperSite.point);e.Capacity=(distA+distB)/2}}SetVertexTriangles(){CrossRectangleNodes(CreateRectNodeOnArrayOfRectNodes(Array.from(this.CdtProperty.GetTriangles()).map((t=>mkRectangleNode(t,t.BoundingBox())))),CreateRectNodeOnArrayOfRectNodes(this.vertexArray.map((v=>mkRectangleNode(v,Rectangle.mkOnPoints([v.Point]))))),((a,b)=>this.TryToAssigenTriangleToVertex(a,b)));for(const v of this.vertexArray);}TryToAssigenTriangleToVertex(triangle,vertex){null==vertex.Triangle&&Cdt.PointIsInsideOfTriangle(vertex.Point,triangle)&&(vertex.Triangle=triangle)}static CapacityOverflowPenaltyMultiplier(bundlingSettings){return bundlingSettings.CapacityOverflowCoefficient*(bundlingSettings.PathLengthImportance+bundlingSettings.InkImportance)}FillCrossedCdtEdges(crossedCdtEdges){for(const geometryEdge of this.geomEdges){this.sourceLoosePoly=this.SetPortVerticesAndObstacles(geometryEdge.sourcePort,!0),this.targetLoosePoly=this.SetPortVerticesAndObstacles(geometryEdge.targetPort,!1);for(const boneEdge of this.EdgesToRoutes.get(geometryEdge))for(const cdtEdge of this.CrossedCdtEdgesOfBoneEdge(boneEdge))this.AdjacentToSourceOrTarget(cdtEdge)||addToMap(crossedCdtEdges,geometryEdge,cdtEdge)}}}class MultiEdgeRouter{constructor(multiEdges,interactiveEdgeRouter,nodeBoundaryCurves,bundlingSettings,transparentShapeSetter){this.multiEdges=multiEdges,this.interactiveEdgeRouter=interactiveEdgeRouter,this.bundlingSettings=bundlingSettings,this.transparentShapeSetter=transparentShapeSetter,this.nodeTree=CreateRectangleNodeOnData(nodeBoundaryCurves,(c=>c.boundingBox))}run(){for(const graph of this.GetIndependantPreGraphs()){new BundleRouter(graph.edges,new SdShortestPath(this.transparentShapeSetter,null,null),this.interactiveEdgeRouter.VisibilityGraph,this.bundlingSettings,this.interactiveEdgeRouter.LoosePadding,this.interactiveEdgeRouter.TightHierarchy,this.interactiveEdgeRouter.LooseHierarchy,null,null,null).run()}}GetPortCurve(port){return this.nodeTree.FirstHitNodeWithPredicate(port.Location,((point,c)=>Curve.PointRelativeToCurveLocation(point,c)!=PointLocation.Outside?HitTestBehavior.Stop:HitTestBehavior.Continue)).UserData}GetIndependantPreGraphs(){const preGraphs=this.CreateInitialPregraphs();for(;;){const count=preGraphs.length,t={preGraphs:preGraphs};if(this.UniteConnectedPreGraphs(t),count<=preGraphs.length)break}return preGraphs}UniteConnectedPreGraphs(t){const intersectionGraph=MultiEdgeRouter.GetIntersectionGraphOfPreGraphs(t.preGraphs);if(null==intersectionGraph)return;const connectedComponents=GetConnectedComponents(intersectionGraph),newPreGraphList=new Array;for(const component of connectedComponents){let preGraph=null;for(const i of component)null==preGraph?(preGraph=t.preGraphs[i],newPreGraphList.push(preGraph)):preGraph.AddGraph(t.preGraphs[i])}t.preGraphs=newPreGraphList;for(const pg of t.preGraphs)this.AddIntersectingNodes(pg)}AddIntersectingNodes(pg){const rect=pg.boundingBox;for(const curve of this.nodeTree.GetNodeItemsIntersectingRectangle(rect))pg.AddNodeBoundary(curve)}static GetIntersectionGraphOfPreGraphs(preGraphs){const intersectingPairs=MultiEdgeRouter.EnumeratePairsOfIntersectedPreGraphs(preGraphs);return intersectingPairs.length?mkGraphOnEdgesN(intersectingPairs,preGraphs.length):null}static EnumeratePairsOfIntersectedPreGraphs(preGraphs){const rn=CreateRectangleNodeOnData(Array.from(Array(preGraphs.length).keys()),(i=>preGraphs[i].boundingBox)),list=new Array;return CrossRectangleNodesSameType(rn,rn,((i,j)=>list.push(new IntPair(i,j)))),list}CreateInitialPregraphs(){return this.multiEdges.map((a=>this.CreatePregraphFromSetOfEdgeGeometries(a)))}CreatePregraphFromSetOfEdgeGeometries(egs){const nodeBoundaries=new Set,eg=egs[0],c=this.GetPortCurve(eg.sourcePort),rect=c.boundingBox;nodeBoundaries.add(c),nodeBoundaries.add(eg.targetPort.Curve),rect.addRec(eg.targetPort.Curve.boundingBox);const overlapped=this.nodeTree.GetNodeItemsIntersectingRectangle(rect);for(const nodeBoundary of overlapped)nodeBoundaries.add(nodeBoundary);return PreGraph.constructorStatic(egs,nodeBoundaries)}}class SplineRouter extends Algorithm{constructor(graph,edges,tightPadding=2,loosePadding=1.5,coneAngle=Math.PI/180*30,bundlingSettings=null,cancelToken=null){super(cancelToken),this.continueOnOverlaps=!0,this.shapesToTightLooseCouples=new Map,this.portLocationsToLoosePolylines=new PointMap,this.multiEdgesSeparation=5,this.routeMultiEdgesAsBundles=!0,this.UsePolylineEndShortcutting=!0,this.UseInnerPolylingShortcutting=!0,this.AllowedShootingStraightLines=!0,this._overlapsDetected=!1,this.KeepOriginalSpline=!1,this.ArrowHeadRatio=0,this.bidirectional=!1,this._edges=edges,this.BundlingSettings=bundlingSettings,this.geomGraph=graph,this.LoosePadding=loosePadding,this.tightPadding=tightPadding,this.coneAngle=coneAngle;const obstacles=ShapeCreator.GetShapes(this.geomGraph,this._edges);null==this.BundlingSettings&&graph.layoutSettings&&graph.layoutSettings.edgeRoutingSettings&&graph.layoutSettings.edgeRoutingSettings.BundlingSettings&&(this.BundlingSettings=graph.layoutSettings.edgeRoutingSettings.BundlingSettings),this.Initialize(obstacles,this.coneAngle)}get ContinueOnOverlaps(){return this.continueOnOverlaps}set ContinueOnOverlaps(value){this.continueOnOverlaps=value}*edges(){if(null!=this._edges)for(const e of this._edges)yield e}get LoosePadding(){return this.loosePadding}set LoosePadding(value){this.loosePadding=value}get MultiEdgesSeparation(){return this.multiEdgesSeparation}set MultiEdgesSeparation(value){this.multiEdgesSeparation=value}static mk2(graph,edgeRoutingSettings){return SplineRouter.mk5(graph,edgeRoutingSettings.Padding,edgeRoutingSettings.PolylinePadding,edgeRoutingSettings.ConeAngle,edgeRoutingSettings.BundlingSettings)}static mk4(graph,tightTightPadding,loosePadding,coneAngle){return new SplineRouter(graph,Array.from(graph.edges()),tightTightPadding,loosePadding,coneAngle,null)}static mk5(graph,tightTightPadding,loosePadding,coneAngle,bundlingSettings){return new SplineRouter(graph,Array.from(graph.edges()),tightTightPadding,loosePadding,coneAngle,bundlingSettings)}static mk6(graph,tightPadding,loosePadding,coneAngle,inParentEdges,outParentEdges){const ret=SplineRouter.mk4(graph,tightPadding,loosePadding,coneAngle),obstacles=ShapeCreatorForRoutingToParents.GetShapes(inParentEdges,outParentEdges);return ret.Initialize(obstacles,coneAngle),ret}Initialize(obstacles,coneAngleValue){this.rootShapes=obstacles.filter((s=>null==s.Parents||0==s.Parents.length)),this.coneAngle=coneAngleValue,0==this.coneAngle&&(this.coneAngle=Math.PI/6)}run(){this.geomGraph.isEmpty()||(this.GetOrCreateRoot(),this.RouteOnRoot(),this.RemoveRoot())}RouteOnRoot(){this.CalculatePortsToShapes(),this.CalculatePortsToEnterableShapes(),this.CalculateShapeToBoundaries(this.root),this.OverlapsDetected&&!this.ContinueOnOverlaps||(this.BindLooseShapes(),this.SetLoosePolylinesForAnywherePorts(),this.CalculateVisibilityGraph(),this.RouteOnVisGraph())}CalculatePortsToEnterableShapes(){this.portsToEnterableShapes=new Map;for(const[port,shape]of this.portsToShapes){const portShapes=new Set;SplineRouter.EdgesAttachedToPortAvoidTheNode(port)||portShapes.add(shape),this.portsToEnterableShapes.set(port,portShapes)}for(const rootShape of this.rootShapes)for(const sh of rootShape.Descendants())for(const port of sh.Ports){insertRange(this.portsToEnterableShapes.get(port),Array.from(sh.Ancestors()).filter((s=>null!=s.BoundaryCurve)))}}static EdgesAttachedToPortAvoidTheNode(port){return port instanceof CurvePort||port instanceof ClusterBoundaryPort}SetLoosePolylinesForAnywherePorts(){for(const[shape,cpl]of this.shapesToTightLooseCouples)for(const port of shape.Ports){if(port instanceof HookUpAnywhereFromInsidePort){port.LoosePolyline=cpl.LooseShape.BoundaryCurve}if(port instanceof ClusterBoundaryPort){port.LoosePolyline=cpl.LooseShape.BoundaryCurve}}}BindLooseShapes(){this.looseRoot=new Shape;for(const shape of this.root.Children){const looseShape=this.shapesToTightLooseCouples.get(shape).LooseShape;this.BindLooseShapesUnderShape(shape),this.looseRoot.AddChild(looseShape)}}BindLooseShapesUnderShape(shape){const loose=this.shapesToTightLooseCouples.get(shape).LooseShape;for(const child of shape.Children){const childLooseShape=this.shapesToTightLooseCouples.get(child).LooseShape;loose.AddChild(childLooseShape),this.BindLooseShapesUnderShape(child)}}CalculateShapeToBoundaries(shape){if(this.ProgressStep(),0==shape.Children.length)return;for(const child of shape.Children)this.CalculateShapeToBoundaries(child);const obstacleCalculator=new ShapeObstacleCalculator(shape,this.tightPadding,this.AdjustedLoosePadding,this.shapesToTightLooseCouples);obstacleCalculator.Calculate(),this.OverlapsDetected||(this.OverlapsDetected=obstacleCalculator.OverlapsDetected)}get OverlapsDetected(){return this._overlapsDetected}set OverlapsDetected(value){this._overlapsDetected=value}get AdjustedLoosePadding(){return null==this.BundlingSettings?this.LoosePadding:this.LoosePadding*BundleRouter.SuperLoosePaddingCoefficient}GroupEdgesByPassport(){const ret=new Array;for(const edge of this._edges){const edgePassport=this.EdgePassport(edge);let pair=ret.find((p=>setsAreEqual(p.passport,edgePassport)));pair||(pair={passport:edgePassport,edges:[]},ret.push(pair)),pair.edges.push(edge)}return ret}RouteOnVisGraph(){if(this.ancestorSets=SplineRouter.GetAncestorSetsMap(Array.from(this.root.Descendants())),null==this.BundlingSettings)for(const edgeGroup of this.GroupEdgesByPassport()){const passport=edgeGroup.passport,obstacleShapes=this.GetObstaclesFromPassport(passport),interactiveEdgeRouter=this.CreateInteractiveEdgeRouter(Array.from(obstacleShapes));this.RouteEdgesWithTheSamePassport(edgeGroup,interactiveEdgeRouter,obstacleShapes)}else this.RouteBundles()}RouteEdgesWithTheSamePassport(edgeGeometryGroup,interactiveEdgeRouter,obstacleShapes){const t={regularEdges:[],multiEdges:[]};if(this.RouteMultiEdgesAsBundles){this.SplitOnRegularAndMultiedges(edgeGeometryGroup.edges,t);for(const edge of t.regularEdges)this.RouteEdge(interactiveEdgeRouter,edge);null!=t.multiEdges&&(this.ScaleDownLooseHierarchy(interactiveEdgeRouter,obstacleShapes),this.RouteMultiEdges(t.multiEdges,interactiveEdgeRouter,edgeGeometryGroup.passport))}else for(const eg of edgeGeometryGroup.edges)this.RouteEdge(interactiveEdgeRouter,eg)}get RouteMultiEdgesAsBundles(){return this.routeMultiEdgesAsBundles}set RouteMultiEdgesAsBundles(value){this.routeMultiEdgesAsBundles=value}RouteEdge(interactiveEdgeRouter,edge){const transparentShapes=this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(edge);this.ProgressStep(),this.RouteEdgeGeometry(edge,interactiveEdgeRouter),SplineRouter.SetTransparency(transparentShapes,!1)}ScaleDownLooseHierarchy(interactiveEdgeRouter,obstacleShapes){const loosePolys=new Array;for(const obstacleShape of obstacleShapes){const tl=this.shapesToTightLooseCouples.get(obstacleShape);loosePolys.push(InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tl.TightPolyline,tl.Distance/1.1))}interactiveEdgeRouter.LooseHierarchy=SplineRouter.CreateLooseObstacleHierarachy(loosePolys),interactiveEdgeRouter.ClearActivePolygons(),interactiveEdgeRouter.AddActivePolygons(loosePolys.map((poly=>new Polygon(poly))))}RouteMultiEdges(multiEdges,interactiveEdgeRouter,parents){const nodeBoundaries=[];for(const p of parents)for(const ch of p.Children)nodeBoundaries.push(ch.BoundaryCurve);const bs=new BundlingSettings;bs.InkImportance=1e-5,bs.EdgeSeparation=this.MultiEdgesSeparation;new MultiEdgeRouter(multiEdges,interactiveEdgeRouter,nodeBoundaries,bs,(a=>this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(a))).run()}SplitOnRegularAndMultiedges(edges,t){const portLocationPairsToEdges=new PointPairMap;for(const eg of edges)SplineRouter.IsEdgeToParent(eg)?t.regularEdges.push(eg):SplineRouter.RegisterInPortLocationsToEdges(eg,portLocationPairsToEdges);t.multiEdges=null;for(const edgeGroup of portLocationPairsToEdges.values())1==edgeGroup.length||this.OverlapsDetected?t.regularEdges.push(edgeGroup[0]):(null==t.multiEdges&&(t.multiEdges=new Array),t.multiEdges.push(edgeGroup))}static RegisterInPortLocationsToEdges(eg,portLocationPairsToEdges){let list;const pp=new PointPair(eg.sourcePort.Location,eg.targetPort.Location);list=portLocationPairsToEdges.get(pp),list||(list=new Array,portLocationPairsToEdges.set(pp,list)),list.push(eg)}static IsEdgeToParent(e){return e.sourcePort instanceof HookUpAnywhereFromInsidePort||e.targetPort instanceof HookUpAnywhereFromInsidePort}CreateInteractiveEdgeRouter(obstacleShapes){const loosePolys=new Set(obstacleShapes.map((sh=>this.shapesToTightLooseCouples.get(sh).LooseShape.BoundaryCurve))),router=new InteractiveEdgeRouter(this.cancelToken);return router.ObstacleCalculator=new InteractiveObstacleCalculator(obstacleShapes.map((sh=>sh.BoundaryCurve)),this.tightPadding,this.loosePadding,!1),router.VisibilityGraph=this.visGraph,router.TightHierarchy=this.CreateTightObstacleHierarachy(obstacleShapes),router.LooseHierarchy=SplineRouter.CreateLooseObstacleHierarachy(Array.from(loosePolys)),router.UseSpanner=!0,router.LookForRoundedVertices=!0,router.TightPadding=this.tightPadding,router.LoosePadding=this.LoosePadding,router.UseEdgeLengthMultiplier=this.UseEdgeLengthMultiplier,router.UsePolylineEndShortcutting=this.UsePolylineEndShortcutting,router.UseInnerPolylingShortcutting=this.UseInnerPolylingShortcutting,router.AllowedShootingStraightLines=this.AllowedShootingStraightLines,router.AddActivePolygons(Array.from(loosePolys).map((polyline=>new Polygon(polyline)))),router}GetObstaclesFromPassport(passport){if(0==passport.size)return new Set(this.root.Children);const commonAncestors=this.GetCommonAncestorsAbovePassport(passport),allAncestors=this.GetAllAncestors(passport),ret=new Set;for(const p of passport)for(const child of p.Children)allAncestors.has(child)||ret.add(child);const enqueued=uniteSets(new Set(passport),ret),queue=new src.o;for(const shape of passport)commonAncestors.has(shape)||queue.enqueue(shape);for(;queue.length>0;){const a=queue.dequeue();for(const parent of a.Parents){for(const sibling of parent.Children)allAncestors.has(sibling)||ret.add(sibling);commonAncestors.has(parent)||enqueued.has(parent)||(queue.enqueue(parent),enqueued.add(parent))}}return ret}GetAllAncestors(passport){if(0==passport.size)return new Set;let ret=new Set(passport);for(const shape of passport)ret=uniteSets(ret,this.ancestorSets.get(shape));return ret}GetCommonAncestorsAbovePassport(passport){if(0==passport.size)return new Set;const en=Array.from(passport);let ret=this.ancestorSets.get(en[0]);for(let i=1;i<en.length;i++){const shape=en[i];ret=setIntersection(ret,this.ancestorSets.get(shape))}return ret}RouteBundles(){this.ScaleLooseShapesDown(),this.CalculateEdgeEnterablePolylines();const looseHierarchy=this.GetLooseHierarchy(),cdt=BundleRouter.CreateConstrainedDelaunayTriangulation(looseHierarchy),shortestPath=new SdShortestPath((a=>this.MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(a)),cdt,this.FindCdtGates(cdt));new BundleRouter(this._edges,shortestPath,this.visGraph,this.BundlingSettings,this.LoosePadding,this.GetTightHierarchy(),looseHierarchy,this.enterableLoose,this.enterableTight,(port=>this.LoosePolyOfOriginalShape(this.portsToShapes.get(port)))).run()}CreateTheMapToParentLooseShapes(shape,loosePolylinesToLooseParentShapeMap){for(const childShape of shape.Children){const poly=this.shapesToTightLooseCouples.get(childShape).LooseShape.BoundaryCurve;loosePolylinesToLooseParentShapeMap.set(poly,shape),this.CreateTheMapToParentLooseShapes(childShape,loosePolylinesToLooseParentShapeMap)}}FindCdtGates(cdt){const loosePolylinesToLooseParentShapeMap=new Map;this.CreateTheMapToParentLooseShapes(this.root,loosePolylinesToLooseParentShapeMap);const gates=new Set;for(const cdtSite of cdt.PointsToSites.values())for(const cdtEdge of cdtSite.Edges){if(null==cdtEdge.CwTriangle&&null==cdtEdge.CcwTriangle)continue;const a=cdtSite.Owner,b=cdtEdge.lowerSite.Owner;if(a==b)continue;const aParent=loosePolylinesToLooseParentShapeMap.get(a);if(aParent){aParent==loosePolylinesToLooseParentShapeMap.get(b)&&gates.add(cdtEdge)}}return gates}CalculateEdgeEnterablePolylines(){this.enterableLoose=new Map,this.enterableTight=new Map;for(const edge of this.edges()){const looseSet=new Set,tightSet=new Set;this.GetEdgeEnterablePolylines(edge,looseSet,tightSet),this.enterableLoose.set(edge,looseSet),this.enterableTight.set(edge,tightSet)}}GetEdgeEnterablePolylines(edge,looseEnterable,tightEnterable){const sourceShape=this.portsToShapes.get(edge.sourcePort),targetShape=this.portsToShapes.get(edge.targetPort);sourceShape!=this.root&&this.GetEnterablesForShape(sourceShape,looseEnterable,tightEnterable),targetShape!=this.root&&this.GetEnterablesForShape(targetShape,looseEnterable,tightEnterable)}GetEnterablesForShape(shape,looseEnterable,tightEnterable){for(const a of this.ancestorSets.get(shape)){const la=this.LoosePolyOfOriginalShape(a);la&&looseEnterable.add(la);const ta=this.TightPolyOfOriginalShape(a);ta&&tightEnterable.add(ta)}}GetTightHierarchy(){return CreateRectNodeOnArrayOfRectNodes(Array.from(this.shapesToTightLooseCouples.values()).map((tl=>mkRectangleNode(tl.TightPolyline,tl.TightPolyline.boundingBox))))}GetLooseHierarchy(){const loosePolylines=new Set;for(const t of this.shapesToTightLooseCouples.values())loosePolylines.add(t.LooseShape.BoundaryCurve);return CreateRectNodeOnArrayOfRectNodes(Array.from(loosePolylines).map((p=>mkRectangleNode(p,p.boundingBox))))}ScaleLooseShapesDown(){for(const[,tl]of this.shapesToTightLooseCouples)tl.LooseShape.BoundaryCurve=InteractiveObstacleCalculator.LoosePolylineWithFewCorners(tl.TightPolyline,tl.Distance/BundleRouter.SuperLoosePaddingCoefficient)}EdgePassport(edge){const ret=new Set,sourceShape=this.portsToShapes.get(edge.sourcePort),targetShape=this.portsToShapes.get(edge.targetPort);return this.IsAncestor(sourceShape,targetShape)?(insertRange(ret,targetShape.Parents),ret.add(sourceShape),ret):this.IsAncestor(targetShape,sourceShape)?(insertRange(ret,sourceShape.Parents),ret.add(targetShape),ret):(sourceShape!=this.looseRoot&&insertRange(ret,sourceShape.Parents),targetShape!=this.looseRoot&&insertRange(ret,targetShape.Parents),ret)}*AllPorts(){for(const edge of this.edges())yield edge.sourcePort,yield edge.targetPort}CalculatePortsToShapes(){this.portsToShapes=new Map;for(const shape of this.root.Descendants())for(const port of shape.Ports)this.portsToShapes.set(port,shape);for(const port of this.AllPorts())this.portsToShapes.has(port)||(this.root.Ports.add(port),this.portsToShapes.set(port,this.root))}RouteEdgeGeometry(edge,iRouter){const addedEdges=new Array;edge.sourcePort instanceof HookUpAnywhereFromInsidePort||addRange(addedEdges,this.AddVisibilityEdgesFromPort(edge.sourcePort)),edge.targetPort instanceof HookUpAnywhereFromInsidePort||addRange(addedEdges,this.AddVisibilityEdgesFromPort(edge.targetPort));const t={smoothedPolyline:null};if(point_Point.closeDistEps(edge.sourcePort.Location,edge.targetPort.Location)?edge.curve=GeomEdge.RouteSelfEdge(edge.sourcePort.Curve,Math.max(2*this.LoosePadding,edge.GetMaxArrowheadLength()),t):edge.curve=iRouter.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(edge.sourcePort,edge.targetPort,!0,t),edge.smoothedPolyline=t.smoothedPolyline,null==edge.curve)throw new Error;for(const visibilityEdge of addedEdges)VisibilityGraph.RemoveEdge(visibilityEdge);Arrowhead.trimSplineAndCalculateArrowheadsII(edge,edge.sourcePort.Curve,edge.targetPort.Curve,edge.curve,!1)}*AddVisibilityEdgesFromPort(port){let portShape,boundaryCouple;if(port instanceof CurvePort||!(portShape=this.portsToShapes.get(port))||!(boundaryCouple=this.shapesToTightLooseCouples.get(portShape)))return;const portLoosePoly=boundaryCouple.LooseShape;for(const point of portLoosePoly.BoundaryCurve)null==this.visGraph.FindEdgePP(port.Location,point)&&(yield this.visGraph.AddEdgePP(port.Location,point))}MakeTransparentShapesOfEdgeGeometryAndGetTheShapes(edge){const sourceShape=this.portsToShapes.get(edge.sourcePort),targetShape=this.portsToShapes.get(edge.targetPort),transparentLooseShapes=new Array;for(const shape of this.GetTransparentShapes(edge.sourcePort,edge.targetPort,sourceShape,targetShape))null!=shape&&transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));for(const shape of this.portsToEnterableShapes.get(edge.sourcePort))transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));for(const shape of this.portsToEnterableShapes.get(edge.targetPort))transparentLooseShapes.push(this.LooseShapeOfOriginalShape(shape));return SplineRouter.SetTransparency(transparentLooseShapes,!0),transparentLooseShapes}LooseShapeOfOriginalShape(s){return s==this.root?this.looseRoot:this.shapesToTightLooseCouples.get(s).LooseShape}LoosePolyOfOriginalShape(s){return this.LooseShapeOfOriginalShape(s).BoundaryCurve}TightPolyOfOriginalShape(s){return s==this.root?null:this.shapesToTightLooseCouples.get(s).TightPolyline}*GetTransparentShapes(sourcePort,targetPort,sourceShape,targetShape){for(const s of this.ancestorSets.get(sourceShape))yield s;for(const s of this.ancestorSets.get(targetShape))yield s;SplineRouter.EdgesAttachedToPortAvoidTheNode(sourcePort)||(yield sourceShape),SplineRouter.EdgesAttachedToPortAvoidTheNode(targetPort)||(yield targetShape)}static SetTransparency(shapes,v){for(const shape of shapes)shape.IsTransparent=v}IsAncestor(possibleAncestor,possiblePredecessor){let ancestors;return null!=possiblePredecessor&&null!=(ancestors=this.ancestorSets.get(possiblePredecessor))&&ancestors.has(possibleAncestor)}static CreateLooseObstacleHierarachy(loosePolys){return CreateRectNodeOnArrayOfRectNodes(loosePolys.map((poly=>mkRectangleNode(poly,poly.boundingBox))))}CreateTightObstacleHierarachy(obstacles){return CreateRectNodeOnArrayOfRectNodes(obstacles.map((sh=>this.shapesToTightLooseCouples.get(sh).TightPolyline)).map((tightPoly=>mkRectangleNode(tightPoly,tightPoly.boundingBox))))}CalculateVisibilityGraph(){const setOfPortLocations=null!=this.LineSweeperPorts?PointSet.mk(this.LineSweeperPorts):new PointSet;this.ProcessHookAnyWherePorts(setOfPortLocations),this.portRTree=mkRTree(Array.from(setOfPortLocations.values()).map((p=>[Rectangle.rectangleOnPoint(p),p]))),this.visGraph=new VisibilityGraph,this.FillVisibilityGraphUnderShape(this.root)}static ShowVisGraph(fileName,tmpVisGraph,obstacles,greenCurves=null,redCurves=null){const l=Array.from(tmpVisGraph.Edges).map((e=>debugCurve_DebugCurve.mkDebugCurveTWCI(100,1,null!=e.IsPassable&&e.IsPassable()?"green":"black",LineSegment.mkPP(e.SourcePoint,e.TargetPoint))));if(null!=obstacles)for(const p of obstacles){l.push(debugCurve_DebugCurve.mkDebugCurveTWCI(100,.3,"brown",p));for(const t of p)l.push(debugCurve_DebugCurve.mkDebugCurveTWCI(100,1,"green",curveFactory_CurveFactory.mkCircle(1,t)))}if(null!=greenCurves)for(const p of greenCurves)l.push(debugCurve_DebugCurve.mkDebugCurveTWCI(100,10,"navy",p));if(null!=redCurves)for(const p of redCurves)l.push(debugCurve_DebugCurve.mkDebugCurveTWCI(100,10,"red",p))}ProcessHookAnyWherePorts(setOfPortLocations){for(const edge of this.edges())edge.sourcePort instanceof HookUpAnywhereFromInsidePort||edge.sourcePort instanceof ClusterBoundaryPort||setOfPortLocations.add(edge.sourcePort.Location),edge.targetPort instanceof HookUpAnywhereFromInsidePort||edge.targetPort instanceof ClusterBoundaryPort||setOfPortLocations.add(edge.targetPort.Location)}FillVisibilityGraphUnderShape(shape){const children=shape.Children;for(const child of children)this.FillVisibilityGraphUnderShape(child);const tightLooseCouple=this.shapesToTightLooseCouples.get(shape),looseBoundary=tightLooseCouple?tightLooseCouple.LooseShape.BoundaryCurve:null,looseShape=tightLooseCouple?tightLooseCouple.LooseShape:this.looseRoot,obstacles=new Set(looseShape.Children.map((c=>c.BoundaryCurve))),portLocations=this.RemoveInsidePortsAndSplitBoundaryIfNeeded(looseBoundary);let tmpVisGraph=new VisibilityGraph,coneSpanner=ConeSpanner.mk([],tmpVisGraph,this.coneAngle,portLocations,looseBoundary);coneSpanner.run(),tmpVisGraph=new VisibilityGraph,coneSpanner=ConeSpanner.mk(Array.from(obstacles),tmpVisGraph,this.coneAngle,portLocations,looseBoundary),coneSpanner.run(),this.ProgressStep();for(const edge of tmpVisGraph.Edges)this.TryToCreateNewEdgeAndSetIsPassable(edge,looseShape);this.AddBoundaryEdgesToVisGraph(looseBoundary)}get Bidirectional(){return this.bidirectional}set Bidirectional(value){this.bidirectional=value}TryToCreateNewEdgeAndSetIsPassable(edge,looseShape){let e=this.visGraph.FindEdgePP(edge.SourcePoint,edge.TargetPoint);null==e&&(e=this.visGraph.AddEdgePP(edge.SourcePoint,edge.TargetPoint),null!=looseShape&&(e.IsPassable=()=>looseShape.IsTransparent))}AddBoundaryEdgesToVisGraph(boundary){if(null==boundary)return;let pn;for(let p=boundary.startPoint;pn=p.nextOnPolyline,this.visGraph.AddEdgePP(p.point,pn.point),pn!=boundary.startPoint;p=pn);}RemoveInsidePortsAndSplitBoundaryIfNeeded(boundary){const ret=new PointSet;if(null==boundary){for(const point of this.portRTree.GetAllLeaves())ret.add(point);return this.portRTree.Clear(),ret}const boundaryBox=boundary.boundingBox,portLocationsInQuestion=this.portRTree.GetAllIntersecting(boundaryBox);for(const point of portLocationsInQuestion)switch(Curve.PointRelativeToCurveLocation(point,boundary)){case PointLocation.Inside:ret.add(point),this.portLocationsToLoosePolylines.set(point,boundary),this.portRTree.Remove(Rectangle.rectangleOnPoint(point),point);break;case PointLocation.Boundary:this.portRTree.Remove(Rectangle.rectangleOnPoint(point),point),this.portLocationsToLoosePolylines.set(point,boundary);const polylinePoint=SplineRouter.FindPointOnPolylineToInsertAfter(boundary,point);if(null==polylinePoint)throw new Error;LineSweeper.InsertPointIntoPolylineAfter(boundary,polylinePoint,point)}return ret}static FindPointOnPolylineToInsertAfter(boundary,point){for(let p=boundary.startPoint;;){const pn=p.nextOnPolyline;if(point_Point.closeDistEps(point,p.point)||point_Point.closeDistEps(point,pn.point))return null;if(closeDistEps(point_Point.distToLineSegment(point,p.point,pn.point).dist,0))return p;if(p=pn,p==boundary.startPoint)throw new Error}}GetOrCreateRoot(){if(1==this.rootShapes.length){const r=this.rootShapes[0];if(null==r.BoundaryCurve)return void(this.root=r)}this.rootWasCreated=!0,this.root=new Shape(null);for(const rootShape of this.rootShapes)this.root.AddChild(rootShape)}RemoveRoot(){if(this.rootWasCreated)for(const rootShape of this.rootShapes)rootShape.RemoveParent(this.root)}static GetAncestorSetsMap(shapes){const ancSets=new Map;for(const child of shapes.filter((child=>!ancSets.has(child))))ancSets.set(child,SplineRouter.GetAncestorSet(child,ancSets));return ancSets}static GetAncestorSet(child,ancSets){const ret=new Set(child.Parents);for(const parent of child.Parents){let addition=ancSets.get(parent);addition||ancSets.set(parent,addition=SplineRouter.GetAncestorSet(parent,ancSets));for(const t of addition)ret.add(t)}return ret}static CreatePortsIfNeeded(edges){for(const edge of edges){if(null==edge.sourcePort){const ed=edge;new RelativeFloatingPort((()=>ed.source.boundaryCurve),(()=>ed.source.center),new point_Point(0,0))}if(null==edge.targetPort){const ed=edge;new RelativeFloatingPort((()=>ed.target.boundaryCurve),(()=>ed.target.center),new point_Point(0,0))}}}static ComputeLooseSplinePadding(nodeSeparation,edgePadding){return(nodeSeparation-2*edgePadding)/8}}SplineRouter.debCount=0;class StraightLineEdges extends Algorithm{constructor(edges,padding){super(null),this.edges=edges,this.padding=padding}run(){SplineRouter.CreatePortsIfNeeded(this.edges);for(const geomedge of this.edges)StraightLineEdges.RouteEdge(geomedge,this.padding)}static RouteEdge(geomedge,padding){const eg=geomedge;null==eg.sourcePort&&(eg.sourcePort=RelativeFloatingPort.mk((()=>geomedge.source.boundaryCurve),(()=>geomedge.source.center))),null==eg.targetPort&&(eg.targetPort=RelativeFloatingPort.mk((()=>geomedge.target.boundaryCurve),(()=>geomedge.target.center))),StraightLineEdges.ContainmentLoop(eg,padding)||(eg.curve=StraightLineEdges.GetEdgeLine(geomedge)),Arrowhead.trimSplineAndCalculateArrowheadsII(eg,eg.sourcePort.Curve,eg.targetPort.Curve,geomedge.curve,!1)}static ContainmentLoop(eg,padding){const sourceCurve=eg.sourcePort.Curve,targetCurve=eg.targetPort.Curve;if(null==sourceCurve||null==targetCurve)return!1;const targetBox=sourceCurve.boundingBox,sourceBox=targetCurve.boundingBox,targetInSource=targetBox.containsRect(sourceBox),sourceInTarget=!targetInSource&&sourceBox.containsRect(targetBox);return!(!targetInSource&&!sourceInTarget)&&(eg.curve=StraightLineEdges.CreateLoop(targetBox,sourceBox,sourceInTarget,padding),!0)}static CreateLoop(targetBox,sourceBox,sourceContainsTarget,padding){return sourceContainsTarget?StraightLineEdges.CreateLoop_(targetBox,sourceBox,padding,!1):StraightLineEdges.CreateLoop_(sourceBox,targetBox,padding,!0)}static CreateLoop_(sourceBox,targetBox,howMuchToStickOut,reverse){const center=sourceBox.center,closestPoint=StraightLineEdges.FindClosestPointOnBoxBoundary(sourceBox.center,targetBox);let dir=closestPoint.sub(center);const maxWidth=(Math.abs(dir.x)<GeomConstants.distanceEpsilon?Math.min(center.y-targetBox.bottom,targetBox.top-center.y):Math.min(center.x-targetBox.left,targetBox.right-center.x))/2,width=Math.min(howMuchToStickOut,maxWidth);dir.length<=GeomConstants.distanceEpsilon&&(dir=new point_Point(1,0));const hookDir=dir.normalize(),hookPerp=hookDir.rotate(Math.PI/2),p1=closestPoint.add(hookDir.mul(howMuchToStickOut)),p2=p1.add(hookPerp.mul(width)),p3=closestPoint.add(hookPerp.mul(width)),end=center.add(hookPerp.mul(width));return(reverse?SmoothedPolyline.mkFromPoints([end,p3,p2,p1,closestPoint,center]):SmoothedPolyline.mkFromPoints([center,closestPoint,p1,p2,p3,end])).createCurve()}static FindClosestPointOnBoxBoundary(c,targetBox){const x=c.x-targetBox.left<targetBox.right-c.x?targetBox.left:targetBox.right,y=c.y-targetBox.bottom<targetBox.top-c.y?targetBox.bottom:targetBox.top;return Math.abs(x-c.x)<Math.abs(y-c.y)?new point_Point(x,c.y):new point_Point(c.x,y)}static GetEdgeLine(geomedge){let sourcePoint,sourceBox,targetPoint,targetBox;null==geomedge.sourcePort?(sourcePoint=geomedge.source.center,sourceBox=geomedge.source.boundaryCurve):(sourcePoint=geomedge.sourcePort.Location,sourceBox=geomedge.sourcePort.Curve),null==geomedge.targetPort?(targetPoint=geomedge.target.center,targetBox=geomedge.target.boundaryCurve):(targetPoint=geomedge.targetPort.Location,targetBox=geomedge.targetPort.Curve);let line=LineSegment.mkPP(sourcePoint,targetPoint),intersects=Curve.getAllIntersections(sourceBox,line,!1);if(intersects.length>0){let c=line.trim(intersects[0].par1,1);c instanceof LineSegment&&(line=c,intersects=Curve.getAllIntersections(targetBox,line,!1),intersects.length>0&&(c=line.trim(0,intersects[0].par1),c instanceof LineSegment&&(line=c)))}return line}static CreateSimpleEdgeCurveWithUnderlyingPolyline(geomedge){const a=geomedge.source.center,b=geomedge.target.center;if(geomedge.source==geomedge.target){const dx=2/(3*geomedge.source.boundaryCurve.boundingBox.width),dy=geomedge.source.boundingBox.height/4;geomedge.underlyingPolyline=StraightLineEdges.CreateUnderlyingPolylineForSelfEdge(a,dx,dy),geomedge.curve=geomedge.underlyingPolyline.createCurve()}else geomedge.underlyingPolyline=SmoothedPolyline.mkFromPoints([a,b]),geomedge.curve=geomedge.underlyingPolyline.createCurve();Arrowhead.trimSplineAndCalculateArrowheadsII(geomedge,geomedge.source.boundaryCurve,geomedge.target.boundaryCurve,geomedge.curve,!1)}static CreateUnderlyingPolylineForSelfEdge(p0,dx,dy){const p1=p0.add(new point_Point(0,dy)),p2=p0.add(new point_Point(dx,dy)),p3=p0.add(new point_Point(dx,-1*dy)),p4=p0.add(new point_Point(0,-1*dy));let site=CornerSite.mkSiteP(p0);const polyline=new SmoothedPolyline(site);return site=CornerSite.mkSiteSP(site,p1),site=CornerSite.mkSiteSP(site,p2),site=CornerSite.mkSiteSP(site,p3),site=CornerSite.mkSiteSP(site,p4),CornerSite.mkSiteSP(site,p0),polyline}static SetStraightLineEdgesWithUnderlyingPolylines(graph){SplineRouter.CreatePortsIfNeeded(Array.from(graph.edges()));for(const geomedge of graph.edges())StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(geomedge)}}class routing_Routing extends Algorithm{constructor(settings,originalGraph,dbP,yLayerArrays,properLayeredGraph,intGraph){super(null),this.settings=settings,this.OriginalGraph=originalGraph,this.Database=dbP,this.ProperLayeredGraph=properLayeredGraph,this.LayerArrays=yLayerArrays,this.IntGraph=intGraph}run(){this.createSplines()}createSplines(){this.createRegularSplines(),this.createSelfSplines(),null!=this.IntGraph&&this.RouteFlatEdges(),null==this.OriginalGraph.graph.parent&&this.RouteUnroutedEdges()}RouteUnroutedEdges(){for(const n of this.OriginalGraph.deepNodes())for(const e of n.outEdges())e.curve||StraightLineEdges.RouteEdge(e,Math.max(e.source.padding,e.target.padding))}RouteFlatEdges(){}createRegularSplines(){for(const intEdgeList of this.Database.RegularMultiedges()){const m=intEdgeList.length,optimizeShortEdges=1==m&&!this.FanAtSourceOrTarget(intEdgeList[0]);for(let i=Math.floor(m/2);i<m;i++)this.createSplineForNonSelfEdge(intEdgeList[i],optimizeShortEdges);for(let i=Math.floor(m/2)-1;i>=0;i--)this.createSplineForNonSelfEdge(intEdgeList[i],optimizeShortEdges)}}FanAtSourceOrTarget(intEdge){return this.ProperLayeredGraph.OutDegreeIsMoreThanOne(intEdge.source)||this.ProperLayeredGraph.InDegreeIsMoreThanOne(intEdge.target)}createSelfSplines(){for(const[k,v]of this.Database.Multiedges.keyValues()){const ip=k;if(ip.x==ip.y){const anchor=this.Database.Anchors[ip.x];let offset=anchor.leftAnchor;for(const intEdge of v){const dx=this.settings.NodeSeparation+(this.settings.MinNodeWidth+offset),dy=anchor.bottomAnchor/2,p0=anchor.origin,p1=p0.add(new point_Point(0,dy)),p2=p0.add(new point_Point(dx,dy)),p3=p0.add(new point_Point(dx,-1*dy)),p4=p0.add(new point_Point(0,-1*dy));let s=CornerSite.mkSiteP(p0);const polyline=new SmoothedPolyline(s);s=CornerSite.mkSiteSP(s,p1),s=CornerSite.mkSiteSP(s,p2),s=CornerSite.mkSiteSP(s,p3),s=CornerSite.mkSiteSP(s,p4),CornerSite.mkSiteSP(s,p0);const c=polyline.createCurve();if(intEdge.curve=c,intEdge.edge.underlyingPolyline=polyline,offset=dx,null!=intEdge.edge.label){offset+=intEdge.edge.label.width;const center=intEdge.edge.label.center=new point_Point(c.value((c.parStart+c.parEnd)/2).x+intEdge.labelWidth/2,anchor.y),del=new point_Point(intEdge.edge.label.width/2,intEdge.edge.label.height/2),box=Rectangle.mkPP(center.add(del),center.sub(del));intEdge.edge.label.boundingBox=box}Arrowhead.trimSplineAndCalculateArrowheadsII(intEdge.edge,intEdge.edge.source.boundaryCurve,intEdge.edge.target.boundaryCurve,c,!1)}}}}createSplineForNonSelfEdge(es,optimizeShortEdges){null!=es.LayerEdges&&(this.drawSplineBySmothingThePolyline(es,optimizeShortEdges),es.IsVirtualEdge||(es.updateEdgeLabelPosition(this.Database.Anchors),Arrowhead.trimSplineAndCalculateArrowheadsII(es.edge,es.edge.source.boundaryCurve,es.edge.target.boundaryCurve,es.curve,!0)))}drawSplineBySmothingThePolyline(edgePath,optimizeShortEdges){const scalc=new SmoothedPolylineCalculator(edgePath,this.Database.Anchors,this.OriginalGraph,this.settings,this.LayerArrays,this.ProperLayeredGraph,this.Database),spline=scalc.getSpline(optimizeShortEdges);edgePath.reversed?(edgePath.curve=spline.reverse(),edgePath.underlyingPolyline=scalc.Reverse().GetPolyline):(edgePath.curve=spline,edgePath.underlyingPolyline=scalc.GetPolyline)}static UpdateLabel(e,anchor){let labelSide=null;anchor.labelIsToTheRightOfTheSpline?(e.label.center=new point_Point(anchor.x+anchor.rightAnchor/2,anchor.y),labelSide=LineSegment.mkPP(e.labelBBox.leftTop,e.labelBBox.leftBottom)):anchor.labelIsToTheLeftOfTheSpline&&(e.label.center=new point_Point(anchor.x-anchor.leftAnchor/2,anchor.y),labelSide=LineSegment.mkPP(e.labelBBox.rightTop,e.labelBBox.rightBottom));const segmentInFrontOfLabel=routing_Routing.GetSegmentInFrontOfLabel(e.curve,e.label.center.y);if(null!=segmentInFrontOfLabel&&0==Curve.getAllIntersections(e.curve,Curve.polyFromBox(e.labelBBox),!1).length){const t={curveClosestPoint:void 0,labelSideClosest:void 0};if(routing_Routing.FindClosestPoints(t,segmentInFrontOfLabel,labelSide))routing_Routing.ShiftLabel(e,t);else{const u=segmentInFrontOfLabel.closestParameter(labelSide.start),v=segmentInFrontOfLabel.closestParameter(labelSide.end);segmentInFrontOfLabel.value(u).sub(labelSide.start).length<segmentInFrontOfLabel.value(v).sub(labelSide.end).length?(t.curveClosestPoint=segmentInFrontOfLabel.value(u),t.labelSideClosest=labelSide.start):(t.curveClosestPoint=segmentInFrontOfLabel.value(v),t.labelSideClosest=labelSide.end),routing_Routing.ShiftLabel(e,t)}}}static ShiftLabel(e,t){const w=e.lineWidth/2,shift=t.curveClosestPoint.sub(t.labelSideClosest),shiftLength=shift.length;shiftLength>w&&(e.label.center=e.label.center.add(shift.div(shiftLength*(shiftLength-w))))}static FindClosestPoints(t,segmentInFrontOfLabel,labelSide){const di=Curve.minDistWithinIntervals(segmentInFrontOfLabel,labelSide,segmentInFrontOfLabel.parStart,segmentInFrontOfLabel.parEnd,labelSide.parStart,labelSide.parEnd,(segmentInFrontOfLabel.parStart+segmentInFrontOfLabel.parEnd)/2,(labelSide.parStart+labelSide.parEnd)/2);return!!di&&(t.curveClosestPoint=di.aX,t.labelSideClosest=di.bX,!0)}static GetSegmentInFrontOfLabel(edgeCurve,labelY){if(edgeCurve instanceof Curve){const curve=edgeCurve;for(const seg of curve.segs)if((seg.start.y-labelY)*(seg.end.y-labelY)<=0)return seg}return null}static GetNodeKind(vertexOffset,edgePath){return 0==vertexOffset?NodeKind.Top:vertexOffset<edgePath.count?NodeKind.Internal:NodeKind.Bottom}}function layeredLayoutRunner(geomGraph,cancelToken){new layeredLayout_LayeredLayout(geomGraph,geomGraph.layoutSettings,cancelToken).run()}function layoutGraphWithSugiayma(geomGraph,cancelToken=null,flipToScreenCoords=!0){driver_enforceLayoutSettings(geomGraph,geomGraph.layoutSettings?geomGraph.layoutSettings:new SugiyamaLayoutSettings_SugiyamaLayoutSettings),driver_layoutGeomGraphDetailed(geomGraph,cancelToken,layeredLayoutRunner,driver_edgeRouter,GeomGraph_optimalPackingRunner,flipToScreenCoords)}class layeredLayout_LayeredLayout extends Algorithm{constructor(originalGraph,settings,cancelToken){if(super(cancelToken),this.LayersAreDoubled=!1,null==originalGraph)return;this.originalGraph=originalGraph,this.sugiyamaSettings=settings;const nodeArray=Array.from(originalGraph.shallowNodes());this.nodeIdToIndex=new Map;let index=0;for(const n of nodeArray)this.nodeIdToIndex.set(n.id,index++);const intEdges=[];for(const edge of this.originalGraph.edges()){const source=this.nodeIdToIndex.get(edge.source.id);if(null==source)continue;const target=this.nodeIdToIndex.get(edge.target.id);if(null==target)continue;const intEdge=new PolyIntEdge(source,target,edge);intEdges.push(intEdge)}this.IntGraph=new BasicGraph(intEdges,originalGraph.shallowNodeCount),this.IntGraph.nodes=nodeArray,this.database=new Database(nodeArray.length);for(const e of this.IntGraph.edges)this.database.registerOriginalEdgeInMultiedges(e);this.cycleRemoval()}get verticalConstraints(){return this.sugiyamaSettings.verticalConstraints}get HorizontalConstraints(){return this.sugiyamaSettings.horizontalConstraints}run(){0!=this.originalGraph.shallowNodeCount?(!function preRunTransform(geomGraph,m){if(m.isIdentity())return;const matrixInverse=m.inverse();for(const n of geomGraph.shallowNodes())n.transform(matrixInverse);for(const e of geomGraph.edges())if(null!=e.label){const r=Rectangle.mkPP(matrixInverse.multiplyPoint(new point_Point(0,0)),matrixInverse.multiplyPoint(new point_Point(e.label.width,e.label.height)));e.label.width=r.width,e.label.height=r.height}}(this.originalGraph,this.sugiyamaSettings.transform),this.engineLayerArrays=this.calculateLayers(),this.sugiyamaSettings.edgeRoutingSettings.EdgeRoutingMode==EdgeRoutingMode.SugiyamaSplines&&this.runPostLayering(),function postRunTransform(geometryGraph,transform){if(transform.isIdentity())return;for(const n of geometryGraph.shallowNodes())n.transform(transform);for(const e of geometryGraph.edges())if(null!=e.label){const r=Rectangle.mkPP(transform.multiplyPoint(new point_Point(0,0)),transform.multiplyPoint(new point_Point(e.label.width,e.label.height)));e.label.width=r.width,e.label.height=r.height}!function TransformCurves(geometryGraph,m){for(const e of geometryGraph.edges())null!=e.label&&(e.label.center=m.multiplyPoint(e.label.center)),TransformEdgeCurve(m,e)}(geometryGraph,transform)}(this.originalGraph,this.sugiyamaSettings.transform),this.originalGraph.updateBoundingBox(),this.SetMargins()):this.originalGraph.boundingBox=Rectangle.mkEmpty()}SetMargins(){this.originalGraph.boundingBox.right+=this.sugiyamaSettings.margins.right,this.originalGraph.boundingBox.top+=this.sugiyamaSettings.margins.bottom,this.originalGraph.boundingBox.left-=this.sugiyamaSettings.margins.left,this.originalGraph.boundingBox.bottom-=this.sugiyamaSettings.margins.bottom}runPostLayering(){const routingSettings=this.sugiyamaSettings.edgeRoutingSettings,mode=null!=this.constrainedOrdering?EdgeRoutingMode.Spline:routingSettings.EdgeRoutingMode;switch(mode){case EdgeRoutingMode.SugiyamaSplines:this.calculateEdgeSplines();break;case EdgeRoutingMode.StraightLine:case EdgeRoutingMode.Spline:case EdgeRoutingMode.SplineBundling:throw new Error("not implemented");case EdgeRoutingMode.Rectilinear:case EdgeRoutingMode.RectilinearToCenter:throw new Error("Not implemented yet");default:throw new Error("Unexpected mode "+mode)}}SetLabels(){throw new Error("not implementedt")}cycleRemoval(){const verticalConstraints=this.sugiyamaSettings.verticalConstraints,feedbackSet=verticalConstraints.isEmpty?CycleRemoval.getFeedbackSet(this.IntGraph):verticalConstraints.getFeedbackSetExternal(this.IntGraph,this.nodeIdToIndex);this.database.addFeedbackSet(feedbackSet)}calculateLayers(){this.CreateGluedDagSkeletonForLayering();const layerArrays=this.CalculateLayerArrays();return this.UpdateNodePositionData(),layerArrays}UpdateNodePositionData(){this.TryToSatisfyMinWidhtAndMinHeight();for(let i=0;i<this.IntGraph.nodeCount&&i<this.database.Anchors.length;i++)this.IntGraph.nodes[i].center=this.database.Anchors[i].origin;if(this.sugiyamaSettings.GridSizeByX>0)for(let i=0;i<this.originalGraph.shallowNodeCount;i++)this.SnapLeftSidesOfTheNodeToGrid(i,this.sugiyamaSettings.GridSizeByX)}SnapLeftSidesOfTheNodeToGrid(i,gridSize){const node=this.IntGraph.nodes[i],anchor=this.database.Anchors[i];anchor.leftAnchor-=gridSize/2,anchor.rightAnchor-=gridSize/2;const left=node.boundingBox.left,delta=left-Math.floor(left/gridSize)*gridSize;Math.abs(delta)<.001||(Math.abs(delta)<=gridSize/2?node.center=node.center.add(new point_Point(-delta,0)):node.center=node.center.add(new point_Point(gridSize-delta,0)),anchor.x=node.center.x)}TryToSatisfyMinWidhtAndMinHeight(){this.TryToSatisfyMinWidth(),this.TryToSatisfyMinHeight()}TryToSatisfyMinWidth(){if(0==this.sugiyamaSettings.MinimalWidth)return;this.GetCurrentWidth()<this.sugiyamaSettings.MinimalWidth&&this.StretchWidth()}StretchWidth(){const desiredSpan=new RealNumberSpan;for(const node of this.originalGraph.shallowNodes())desiredSpan.AddValue(node.boundingBox.width/2),desiredSpan.AddValue(this.sugiyamaSettings.MinimalWidth-node.boundingBox.width/2);const currentSpan=new RealNumberSpan;for(const anchor of this.NodeAnchors())currentSpan.AddValue(anchor.x);if(currentSpan.length>GeomConstants.distanceEpsilon){const stretch=desiredSpan.length/currentSpan.length;if(stretch>1)for(const a of this.anchors)a.x*=stretch}}TryToSatisfyMinHeight(){if(0==this.sugiyamaSettings.MinimalHeight)return;this.GetCurrentHeight()<this.sugiyamaSettings.MinimalHeight&&this.StretchHeight()}GetCurrentHeight(){const span=new RealNumberSpan;for(const anchor of this.NodeAnchors())span.AddValue(anchor.top),span.AddValue(anchor.bottom);return span.length}StretchHeight(){const desiredSpan=new RealNumberSpan;for(const node of this.originalGraph.shallowNodes())desiredSpan.AddValue(node.boundingBox.height/2),desiredSpan.AddValue(this.sugiyamaSettings.MinimalHeight-node.boundingBox.height/2);const currentSpan=new RealNumberSpan;for(const anchor of this.NodeAnchors())currentSpan.AddValue(anchor.y);if(currentSpan.length>GeomConstants.distanceEpsilon){const stretch=desiredSpan.length/currentSpan.length;if(stretch>1)for(const a of this.anchors)a.y*=stretch}}*NodeAnchors(){const n=Math.min(this.IntGraph.nodeCount,this.anchors.length);for(let i=0;i<n;i++)yield this.anchors[i]}GetCurrentWidth(){const span=new RealNumberSpan;for(const anchor of this.NodeAnchors())span.AddValue(anchor.left),span.AddValue(anchor.right);return span.length}ExtendLayeringToUngluedSameLayerVertices(p){const vc=this.verticalConstraints;for(let i=0;i<p.length;i++)p[i]=p[vc.nodeToRepr(i)];return p}calculateEdgeSplines(){new routing_Routing(this.sugiyamaSettings,this.originalGraph,this.database,this.engineLayerArrays,this.properLayeredGraph,this.IntGraph).run()}YLayeringAndOrdering(layering){let yLayers=layering.GetLayers();Balancing.Balance(this.gluedDagSkeletonForLayering,yLayers,this.GetNodeCountsOfGluedDag(),null),yLayers=this.ExtendLayeringToUngluedSameLayerVertices(yLayers);let layerArrays=new LayerArrays(yLayers);if(null==this.HorizontalConstraints||this.HorizontalConstraints.IsEmpty)return layerArrays=this.YLayeringAndOrderingWithoutHorizontalConstraints(layerArrays),layerArrays;throw new Error("not implemented")}CreateProperLayeredGraph(layering){const n=layering.length;let nOfVV=0;for(const e of this.database.SkeletonEdges()){const span=EdgeSpan(layering,e);span>0&&(e.LayerEdges=new Array(span));let pe=0;if(span>1){let d0=n+nOfVV++,layerEdge=new LayerEdge(e.source,d0,e.CrossingWeight,e.weight);e.LayerEdges[pe++]=layerEdge;for(let j=0;j<span-2;j++)d0++,nOfVV++,layerEdge=new LayerEdge(d0-1,d0,e.CrossingWeight,e.weight),e.LayerEdges[pe++]=layerEdge;layerEdge=new LayerEdge(d0,e.target,e.CrossingWeight,e.weight),e.LayerEdges[pe]=layerEdge}else if(1==span){const layerEdge=new LayerEdge(e.source,e.target,e.CrossingWeight,e.weight);e.LayerEdges[pe]=layerEdge}}const extendedVertexLayering=new Array(this.originalGraph.shallowNodeCount+nOfVV).fill(0);for(const e of this.database.SkeletonEdges())if(null!=e.LayerEdges){let l=layering[e.source];extendedVertexLayering[e.source]=l--;for(const le of e.LayerEdges)extendedVertexLayering[le.Target]=l--}else extendedVertexLayering[e.source]=layering[e.source],extendedVertexLayering[e.target]=layering[e.target];return this.properLayeredGraph=new ProperLayeredGraph(new BasicGraph(Array.from(this.database.SkeletonEdges()),layering.length)),this.properLayeredGraph.BaseGraph.nodes=this.IntGraph.nodes,new LayerArrays(extendedVertexLayering)}YLayeringAndOrderingWithoutHorizontalConstraints(layerArraysIn){const layerArrays=this.CreateProperLayeredGraph(layerArraysIn.y);return Ordering.OrderLayers(this.properLayeredGraph,layerArrays,this.originalGraph.shallowNodeCount,this.sugiyamaSettings,this.cancelToken),MetroMapOrdering.UpdateLayerArrays1(this.properLayeredGraph,layerArrays),layerArrays}CalculateYLayers(){const layerArrays=this.YLayeringAndOrdering(new NetworkSimplexForGeneralGraph(this.gluedDagSkeletonForLayering,this.cancelToken));return null!=this.constrainedOrdering?layerArrays:this.InsertLayersIfNeeded(layerArrays)}InsertLayersIfNeeded(layerArrays){this.InsertVirtualEdgesIfNeeded(layerArrays);const r=this.AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays);if(r.needToInsertLayers){const t=LayerInserter.InsertLayers(this.properLayeredGraph,layerArrays,this.database,this.IntGraph);this.properLayeredGraph=t.layeredGraph,layerArrays=t.la,this.LayersAreDoubled=!0}else if(r.multipleEdges){const t=EdgePathsInserter.InsertPaths(this.properLayeredGraph,layerArrays,this.database,this.IntGraph);this.properLayeredGraph=t.layeredGraph,layerArrays=t.la}return this.RecreateIntGraphFromDataBase(),layerArrays}RecreateIntGraphFromDataBase(){let edges=new Array;for(const list of this.database.Multiedges.values())edges=edges.concat(list);this.IntGraph.SetEdges(edges,this.IntGraph.nodeCount)}InsertVirtualEdgesIfNeeded(layerArrays){if(null==this.constrainedOrdering)for(const[k,v]of this.database.Multiedges.keyValues())if(v.length%2==0&&layerArrays.y[k.x]-1==layerArrays.y[k.y]){const e=new GeomEdge(null),newVirtualEdge=new PolyIntEdge(k.x,k.y,e);newVirtualEdge.IsVirtualEdge=!0,v.splice(v.length/2,0,newVirtualEdge),this.IntGraph.addEdge(newVirtualEdge)}}AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays){let needToInsertLayers=!1,multipleEdges=!1;for(const ie of this.IntGraph.edges)if(ie.hasLabel&&layerArrays.y[ie.source]!=layerArrays.y[ie.target]){needToInsertLayers=!0;break}if(0==needToInsertLayers&&null==this.constrainedOrdering)for(const[k,v]of this.database.Multiedges.keyValues())if(v.length>1&&(multipleEdges=!0,layerArrays.y[k.x]-layerArrays.y[k.y]==1)){needToInsertLayers=!0;break}return{needToInsertLayers:needToInsertLayers,multipleEdges:multipleEdges}}UseBrandesXCalculations(layerArrays){return layerArrays.x.length>=this.sugiyamaSettings.BrandesThreshold}CalculateAnchorsAndYPositions(layerArrays){this.anchors=function CalculateAnchorSizes(database,properLayeredGraph,originalGraph,intGraph,settings){const anchors=database.Anchors=new Array(properLayeredGraph.NodeCount);for(let i=0;i<anchors.length;i++)anchors[i]=new Anchor(settings.LabelCornersPreserveCoefficient);for(let i=0;i<originalGraph.shallowNodeCount;i++)layeredLayout_LayeredLayout.CalcAnchorsForOriginalNode(i,intGraph,anchors,database,settings);for(const intEdge of database.AllIntEdges())if(null!=intEdge.LayerEdges){for(const layerEdge of intEdge.LayerEdges){const v=layerEdge.Target;if(v!=intEdge.target){const anchor=anchors[v];database.MultipleMiddles.has(v)?(anchor.leftAnchor=anchor.rightAnchor=4,anchor.topAnchor=anchor.bottomAnchor=VirtualNodeHeight(settings)/2):(anchor.leftAnchor=anchor.rightAnchor=.5,anchor.topAnchor=anchor.bottomAnchor=VirtualNodeHeight(settings)/2)}}if(intEdge.hasLabel){const a=anchors[intEdge.LayerEdges[intEdge.LayerEdges.length/2].Source],w=intEdge.labelWidth,h=intEdge.labelHeight;a.rightAnchor=w,a.leftAnchor=8,a.topAnchor<h/2&&(a.topAnchor=a.bottomAnchor=h/2),a.labelIsToTheRightOfTheSpline=!0}}return anchors}(this.database,this.properLayeredGraph,this.originalGraph,this.IntGraph,this.sugiyamaSettings),function CalcInitialYAnchorLocations(layerArrays,spaceBeforeMargins,originalGraph,database,intGraph,settings,layersAreDoubled){const anchors=database.Anchors;let ymax=originalGraph.Margins+spaceBeforeMargins,i=0;for(const yLayer of layerArrays.Layers){let bottomAnchorMax=0,topAnchorMax=0;for(const j of yLayer){const p=anchors[j];p.bottomAnchor>bottomAnchorMax&&(bottomAnchorMax=p.bottomAnchor),p.topAnchor>topAnchorMax&&(topAnchorMax=p.topAnchor)}MakeVirtualNodesTall(yLayer,bottomAnchorMax,topAnchorMax,originalGraph.shallowNodeCount,database.Anchors);const layerCenter=ymax+bottomAnchorMax+SetFlatEdgesForLayer(database,layerArrays,i,intGraph,settings,ymax);let layerTop=layerCenter+topAnchorMax;if(NeedToSnapTopsToGrid(settings)){layerTop+=SnapDeltaUp(layerTop,settings.GridSizeByY);for(const j of yLayer)anchors[j].top=layerTop}else if(NeedToSnapBottomsToGrid(settings)){let layerBottom=layerCenter-bottomAnchorMax;layerBottom+=SnapDeltaUp(layerBottom,layerBottom);for(const j of yLayer)anchors[j].bottom=layerBottom,layerTop=Math.max(anchors[j].top,layerTop)}else for(const j of yLayer)anchors[j].y=layerCenter;ymax=layerTop+settings.ActualLayerSeparation(layersAreDoubled),i++}SetFlatEdgesForLayer(database,layerArrays,i,intGraph,settings,ymax)}(layerArrays,500,this.originalGraph,this.database,this.IntGraph,this.sugiyamaSettings,this.LayersAreDoubled)}OptimizeEdgeLabelsLocations(){for(let i=0;i<this.anchors.length;i++){const a=this.anchors[i];if(a.labelIsToTheRightOfTheSpline){const sp=this.GetSuccessorAndPredecessor(i);if(!TryToPutLabelOutsideOfAngle(a,sp.predecessor,sp.successor)){const sumNow=sp.predecessor.origin.sub(a.origin).length+sp.successor.origin.sub(a.origin).length,nx=a.right-a.leftAnchor,xy=new point_Point(nx,a.y);sp.predecessor.origin.sub(xy).length+sp.successor.origin.sub(xy).length<sumNow&&PutLabelToTheLeft(a)}}}}GetSuccessorAndPredecessor(i){let predecessor,successor;for(const ie of this.properLayeredGraph.InEdges(i))predecessor=ie.Source;for(const ie of this.properLayeredGraph.OutEdges(i))successor=ie.Target;return{predecessor:this.anchors[predecessor],successor:this.anchors[successor]}}CalculateLayerArrays(){const layerArrays=this.CalculateYLayers();return null==this.constrainedOrdering?(this.CalculateAnchorsAndYPositions(layerArrays),this.UseBrandesXCalculations(layerArrays)?this.CalculateXPositionsByBrandes(layerArrays):this.CalculateXLayersByGansnerNorth(layerArrays)):this.anchors=this.database.Anchors,this.OptimizeEdgeLabelsLocations(),this.engineLayerArrays=layerArrays,this.StraightensShortEdges(),this.CalculateOriginalGraphBox(),layerArrays}StretchToDesiredAspectRatio(aspectRatio,desiredAR){aspectRatio>desiredAR?this.StretchInYDirection(aspectRatio/desiredAR):aspectRatio<desiredAR&&this.StretchInXDirection(desiredAR/aspectRatio)}StretchInYDirection(scaleFactor){const center=(this.originalGraph.boundingBox.top+this.originalGraph.boundingBox.bottom)/2;for(const a of this.database.Anchors)a.bottomAnchor=a.bottomAnchor*scaleFactor,a.topAnchor=a.topAnchor*scaleFactor,a.y=center+scaleFactor*(a.y-center);const h=this.originalGraph.height*scaleFactor;this.originalGraph.boundingBox=new Rectangle({left:this.originalGraph.boundingBox.left,top:center+h/2,right:this.originalGraph.boundingBox.right,bottom:center-h/2})}StretchInXDirection(scaleFactor){const center=(this.originalGraph.boundingBox.left+this.originalGraph.boundingBox.right)/2;for(const a of this.database.Anchors)a.leftAnchor=a.leftAnchor*scaleFactor,a.rightAnchor=a.rightAnchor*scaleFactor,a.x=center+scaleFactor*(a.x-center);const w=this.originalGraph.width*scaleFactor;this.originalGraph.boundingBox=new Rectangle({left:center-w/2,top:this.originalGraph.boundingBox.top,right:center+w/2,bottom:this.originalGraph.boundingBox.bottom})}CalculateOriginalGraphBox(){if(0==this.anchors.length)return 0;const box=new Rectangle({left:this.anchors[0].left,top:this.anchors[0].top,right:this.anchors[0].right,bottom:this.anchors[0].bottom});for(let i=1;i<this.anchors.length;i++){const a=this.anchors[i];box.add(a.leftTop),box.add(a.rightBottom)}const delta=box.leftTop.sub(box.rightBottom).length/2,del=new point_Point(-1*delta,delta);return box.add(box.leftTop.add(del)),box.add(box.rightBottom.sub(del)),this.originalGraph.boundingBox=box,0!=box.height?box.width/box.height:0}StraightensShortEdges(){for(;this.StraightenEdgePaths(););}StraightenEdgePaths(){let ret=!1;for(const e of this.database.AllIntEdges())2==e.LayerSpan&&(ret=this.ShiftVertexWithNeighbors(e.LayerEdges[0].Source,e.LayerEdges[0].Target,e.LayerEdges[1].Target)||ret);return ret}ShiftVertexWithNeighbors(u,i,v){const upper=this.database.Anchors[u],lower=this.database.Anchors[v],iAnchor=this.database.Anchors[i],x=(iAnchor.y-upper.y)*((lower.x-upper.x)/(lower.y-upper.y))+upper.x;return x>iAnchor.x+1e-4?this.TryShiftToTheRight(x,i):x<iAnchor.x-1e-4&&this.TryShiftToTheLeft(x,i)}TryShiftToTheLeft(x,v){const layer=this.engineLayerArrays.Layers[this.engineLayerArrays.y[v]],vPosition=this.engineLayerArrays.x[v];if(vPosition>0){const uAnchor=this.database.Anchors[layer[vPosition-1]],allowedX=Math.max(uAnchor.right+(this.sugiyamaSettings.NodeSeparation+this.database.Anchors[v].leftAnchor),x);return allowedX<this.database.Anchors[v].x-1&&(this.database.Anchors[v].x=allowedX,!0)}return this.database.Anchors[v].x=x,!0}TryShiftToTheRight(x,v){const layer=this.engineLayerArrays.Layers[this.engineLayerArrays.y[v]],vPosition=this.engineLayerArrays.x[v];if(vPosition<layer.length-1){const uAnchor=this.database.Anchors[layer[vPosition+1]],allowedX=Math.min(uAnchor.left-(this.sugiyamaSettings.NodeSeparation-this.database.Anchors[v].rightAnchor),x);return allowedX>this.database.Anchors[v].x+1&&(this.database.Anchors[v].x=allowedX,!0)}return this.database.Anchors[v].x=x,!0}CalculateXLayersByGansnerNorth(layerArrays){this.xLayoutGraph=this.CreateXLayoutGraph(layerArrays),this.CalculateXLayersByGansnerNorthOnProperLayeredGraph()}CalculateXLayersByGansnerNorthOnProperLayeredGraph(){const xLayers=new NetworkSimplex(this.xLayoutGraph,null).GetLayers();for(let i=0;i<this.database.Anchors.length;i++)this.anchors[i].x=xLayers[i]}CreateXLayoutGraph(layerArrays){let nOfVerts=this.properLayeredGraph.NodeCount;const edges=new Array;for(const e of this.properLayeredGraph.Edges){const n1=new PolyIntEdge(nOfVerts,e.Source,null),n2=new PolyIntEdge(nOfVerts,e.Target,null);n2.weight=e.Weight,n1.weight=e.Weight,n1.separation=0,n2.separation=0,nOfVerts++,edges.push(n1),edges.push(n2)}for(const layer of layerArrays.Layers)for(let i=layer.length-1;i>0;i--){const source=layer[i],target=layer[i-1],ie=new PolyIntEdge(source,target,null),sourceAnchor=this.database.Anchors[source],targetAnchor=this.database.Anchors[target],sep=sourceAnchor.leftAnchor+(targetAnchor.rightAnchor+this.sugiyamaSettings.NodeSeparation);ie.separation=Math.ceil(sep+.5),edges.push(ie)}const ret=new XLayoutGraph(this.IntGraph,this.properLayeredGraph,layerArrays,edges,nOfVerts);return ret.SetEdgeWeights(),ret}CalculateXPositionsByBrandes(layerArrays){XCoordsWithAlignment.CalculateXCoordinates(layerArrays,this.properLayeredGraph,this.originalGraph.shallowNodeCount,this.database.Anchors,this.sugiyamaSettings.NodeSeparation)}GluedDagSkeletonEdges(){const ret=new IntPairMap(this.IntGraph.nodeCount);for(const[k,v]of this.database.Multiedges.keyValues()){if(k.isDiagonal())continue;const e=this.verticalConstraints.gluedIntEdge(v[0]);e.source!=e.target&&ret.set(e.source,e.target,e)}const gluedUpDownConstraints=Array.from(this.verticalConstraints.gluedUpDownIntConstraints.values()).map((p=>function CreateUpDownConstrainedIntEdge(intPair,e){const intEdge=new PolyIntEdge(intPair.x,intPair.y,e);return intEdge.weight=0,intEdge.separation=1,intEdge}(p,null)));for(const e of gluedUpDownConstraints)ret.set(e.source,e.target,e);return Array.from(ret.values())}static CalcAnchorsForOriginalNode(i,intGraph,anchors,database,settings){const t={leftAnchor:0,rightAnchor:0,topAnchor:0,bottomAnchor:0};if(null!=intGraph.nodes){!function ExtendStandardAnchors(t,node,settings){t.rightAnchor=t.leftAnchor=(node.width+settings.GridSizeByX)/2,t.topAnchor=t.bottomAnchor=node.height/2}(t,intGraph.nodes[i],settings)}!function RightAnchorMultiSelfEdges(i,t,database,settings){const delta=function WidthOfSelfEdge(database,i,t,settings){let delta=0;const multiedges=database.GetMultiedge(i,i);if(multiedges.length>0){for(const e of multiedges)null!=e.edge.label&&(t.rightAnchor+=e.edge.label.width,t.topAnchor<e.edge.label.height/2&&(t.topAnchor=t.bottomAnchor=e.edge.label.height/2));delta+=(settings.NodeSeparation+settings.MinNodeWidth)*multiedges.length}return delta}(database,i,t,settings);t.rightAnchor+=delta}(i,t,database,settings);const hw=settings.MinNodeWidth/2;t.leftAnchor<hw&&(t.leftAnchor=hw),t.rightAnchor<hw&&(t.rightAnchor=hw);const hh=settings.MinNodeHeight/2;t.topAnchor<hh&&(t.topAnchor=hh),t.bottomAnchor<hh&&(t.bottomAnchor=hh),anchors[i]=Anchor.mkAnchor(t.leftAnchor,t.rightAnchor,t.topAnchor,t.bottomAnchor,intGraph.nodes[i],settings.LabelCornersPreserveCoefficient),anchors[i].padding=intGraph.nodes[i].padding}CreateGluedDagSkeletonForLayering(){this.gluedDagSkeletonForLayering=new BasicGraph(this.GluedDagSkeletonEdges(),this.originalGraph.shallowNodeCount),this.SetGluedEdgesWeights()}SetGluedEdgesWeights(){const gluedPairsToGluedEdge=new IntPairMap(this.IntGraph.nodeCount);for(const ie of this.gluedDagSkeletonForLayering.edges)gluedPairsToGluedEdge.set(ie.source,ie.target,ie);for(const[k,v]of this.database.Multiedges.keyValues())if(k.x!=k.y){const gluedPair=this.verticalConstraints.gluedIntPair(k);if(gluedPair.x==gluedPair.y)continue;const gluedIntEdge=gluedPairsToGluedEdge.get(gluedPair.x,gluedPair.y);for(const ie of v)gluedIntEdge.weight+=ie.weight}}GetNodeCountsOfGluedDag(){return this.verticalConstraints.isEmpty?new Array(this.IntGraph.nodeCount).fill(1):this.verticalConstraints.getGluedNodeCounts()}}function SnapDeltaUp(y,gridSize){if(0==gridSize)return 0;const delta=y-Math.floor(y/gridSize)*gridSize;return Math.abs(delta)<1e-4?0:gridSize-delta}function VirtualNodeHeight(settings){return 1.5*settings.MinNodeHeight/8}function SetFlatEdgesForLayer(database,layerArrays,i,intGraph,settings,ymax){let flatEdgesHeight=0;if(i>0){const flatPairs=function GetFlatPairs(layer,layering,intGraph){const pairs=new IntPairSet;for(const v of layer)if(!(v>=intGraph.nodeCount))for(const edge of intGraph.outEdges[v])layering[edge.source]==layering[edge.target]&&pairs.addNN(edge.source,edge.target);return Array.from(pairs.values())}(layerArrays.Layers[i-1],layerArrays.y,intGraph);if(flatPairs.length){const dyOfFlatEdge=settings.LayerSeparation/3,ym=ymax;flatEdgesHeight=Math.max(...flatPairs.map((pair=>function SetFlatEdgesLabelsHeightAndPositionts(pair,ymax,dy,database){let height=0;const list=database.GetMultiedgeI(pair);for(const edge of list){height+=dy;const label=edge.edge.label;null!=label&&(label.center=new point_Point(label.center.x,ymax+height+label.height/2),height+=label.height)}return height}(pair,ym,dyOfFlatEdge,database))))}}return flatEdgesHeight}function EdgeSpan(layers,e){return layers[e.source]-layers[e.target]}function MakeVirtualNodesTall(yLayer,bottomAnchorMax,topAnchorMax,originalNodeCount,anchors){if(function LayerIsOriginal(yLayer,origNodeCount){for(const j of yLayer)if(j<origNodeCount)return!0;return!1}(yLayer,originalNodeCount))for(const j of yLayer)if(j>=originalNodeCount){const p=anchors[j];p.bottomAnchor=bottomAnchorMax,p.topAnchor=topAnchorMax}}function NeedToSnapTopsToGrid(settings){return settings.SnapToGridByY==SnapToGridByY.Top}function NeedToSnapBottomsToGrid(settings){return settings.SnapToGridByY==SnapToGridByY.Bottom}function TryToPutLabelOutsideOfAngle(a,predecessor,successor){if(a.labelIsToTheRightOfTheSpline){if(point_Point.getTriangleOrientation(predecessor.origin,a.origin,successor.origin)==point_TriangleOrientation.Clockwise)return!0;const la=a.leftAnchor,ra=a.rightAnchor,x=a.x;return PutLabelToTheLeft(a),point_Point.getTriangleOrientation(predecessor.origin,a.origin,successor.origin)==point_TriangleOrientation.Counterclockwise?!0:(a.x=x,a.leftAnchor=la,a.rightAnchor=ra,a.labelIsToTheRightOfTheSpline=!0,a.labelIsToTheLeftOfTheSpline=!1,!1)}return!1}function PutLabelToTheLeft(a){const r=a.right,t=a.leftAnchor;a.leftAnchor=a.rightAnchor,a.rightAnchor=t,a.x=r-a.rightAnchor,a.labelIsToTheLeftOfTheSpline=!0,a.labelIsToTheRightOfTheSpline=!1}function TransformEdgeCurve(transformation,e){if(null!=e.curve){e.curve=e.curve.transform(transformation);const eg=e;null!=eg.sourceArrowhead&&(eg.sourceArrowhead.tipPosition=transformation.multiplyPoint(eg.sourceArrowhead.tipPosition)),null!=eg.targetArrowhead&&(eg.targetArrowhead.tipPosition=transformation.multiplyPoint(eg.targetArrowhead.tipPosition)),function TransformUnderlyingPolyline(e,transformation){if(null!=e.underlyingPolyline)for(let s=e.underlyingPolyline.headSite;null!=s;s=s.next)s.point=transformation.multiplyPoint(s.point)}(e,transformation)}}},"../../../.yarn/berry/cache/queue-typescript-npm-1.0.1-b291feb596-10c0.zip/node_modules/queue-typescript/lib/src/index.js":function(__unused_webpack_module,exports,__webpack_require__){const linked_list_typescript_1=__webpack_require__("../../../.yarn/berry/cache/linked-list-typescript-npm-1.0.15-58f04136fb-10c0.zip/node_modules/linked-list-typescript/lib/src/index.js");class Queue extends linked_list_typescript_1.LinkedList{constructor(...values){super(...values)}get front(){return this.head}enqueue(val){this.append(val)}dequeue(){return this.removeHead()}}exports.o=Queue},"../../../.yarn/berry/cache/stack-typescript-npm-1.0.4-94c4fe7556-10c0.zip/node_modules/stack-typescript/lib/src/index.js":function(__unused_webpack_module,exports,__webpack_require__){const linked_list_typescript_1=__webpack_require__("../../../.yarn/berry/cache/linked-list-typescript-npm-1.0.15-58f04136fb-10c0.zip/node_modules/linked-list-typescript/lib/src/index.js");class Stack extends linked_list_typescript_1.LinkedList{constructor(...values){super(...values)}get top(){return this.head}get size(){return this.length}push(val){this.prepend(val)}pop(){return this.removeHead()}}exports.B=Stack},"../../../.yarn/berry/cache/typescript-string-operations-npm-1.5.1-ec02792a09-10c0.zip/node_modules/typescript-string-operations/dist/index.js":function(__unused_webpack_module,exports){exports.fe=exports.Qf=void 0;class String{static regexNumber=/{(\d+(:\w*)?)}/g;static regexObject=/{(\w+(:\w*)?)}/g;static empty="";static Empty="";static IsNullOrWhiteSpace(value){return String.isNullOrWhiteSpace(value)}static Join(delimiter,...args){return String.join(delimiter,...args)}static Format(format,...args){return String.format(format,...args)}static isNullOrWhiteSpace(value){try{return null==value||"undefined"==value||value.toString().replace(/\s/g,"").length<1}catch(e){return console.log(e),!1}}static join(delimiter,...args){try{var firstArg=args[0];if(Array.isArray(firstArg)||firstArg instanceof Array){let tempString=String.empty;for(let i=0;i<firstArg.length;i++){var current=firstArg[i];i<firstArg.length-1?tempString+=current+delimiter:tempString+=current}return tempString}if("object"==typeof firstArg){let tempString=String.empty;const objectArg=firstArg;return Object.keys(firstArg).forEach((element=>{tempString+=objectArg[element]+delimiter})),tempString=tempString.slice(0,tempString.length-delimiter.length)}var stringArray=args;return String.joinString(delimiter,...stringArray)}catch(e){return console.log(e),String.empty}}static format(format,...args){try{return format.match(String.regexNumber)?String.formatString(String.regexNumber,format,args):format.match(String.regexObject)?String.formatString(String.regexObject,format,args,!0):format}catch(e){return console.log(e),String.empty}}static formatString(regex,format,args,parseByObject=!1){return format.replace(regex,(function(match,x){var s=match.split(":");let arg;return 1<s.length&&(x=s[0].replace("{",""),match=s[1].replace("}","")),null==(arg=(parseByObject?args[0]:args)[x])||null==arg||match.match(/{\d+}/)||void 0!==(arg=String.parsePattern(match,arg))&&null!=arg?arg:String.empty}))}static parsePattern(match,arg){switch(match){case"L":return arg.toLocaleLowerCase();case"U":return arg.toLocaleUpperCase();case"d":if("string"==typeof arg)return String.getDisplayDateFromString(arg);if(arg instanceof Date)return String.format("{0:00}.{1:00}.{2:0000}",arg.getDate(),arg.getMonth(),arg.getFullYear());break;case"s":if("string"==typeof arg)return String.getSortableDateFromString(arg);if(arg instanceof Date)return String.format("{0:0000}-{1:00}-{2:00}",arg.getFullYear(),arg.getMonth(),arg.getDate());break;case"n":{var replacedString=(arg="string"!=typeof arg?arg.toString():arg).replace(/,/g,".");if(isNaN(parseFloat(replacedString))||replacedString.length<=3)break;let parts=replacedString=replacedString.split(/\D+/g);var mod=(replacedString=(parts=1<replacedString.length?[String.joinString("",...replacedString.splice(0,replacedString.length-1)),replacedString[replacedString.length-1]]:parts)[0]).length%3,output=0<mod?replacedString.substring(0,mod):String.empty;replacedString=replacedString.substring(mod).match(/.{3}/g);return output+"."+String.join(".",replacedString)+(1<parts.length?","+parts[1]:"")}case"x":return this.decimalToHexString(arg);case"X":return this.decimalToHexString(arg,!0)}return"number"!=typeof arg&&isNaN(arg)||isNaN(+match)||String.isNullOrWhiteSpace(arg)?arg:String.formatNumber(arg,match)}static decimalToHexString(value,upperCase=!1){return value=parseFloat(value).toString(16),upperCase?value.toLocaleUpperCase():value}static getDisplayDateFromString(input){var splitted=input.split("-");if(splitted.length<=1)return input;let day=splitted[splitted.length-1];return input=splitted[splitted.length-2],splitted=splitted[splitted.length-3],(day=(day=day.split("T")[0]).split(" ")[0])+`.${input}.`+splitted}static getSortableDateFromString(input){var splitted=input.replace(",","").split(".");if(splitted.length<=1)return input;input=splitted[splitted.length-1].split(" ");let time=String.empty,result=(1<input.length&&(time=input[input.length-1]),splitted[splitted.length-1].split(" ")[0]+`-${splitted[splitted.length-2]}-`+splitted[splitted.length-3]);return!String.isNullOrWhiteSpace(time)&&1<time.length?result+="T"+time:result+="T00:00:00",result}static formatNumber(input,formatTemplate){return(formatTemplate=formatTemplate.length)<=(input=input.toString()).length?input:(formatTemplate-=input.length,++formatTemplate,new Array(formatTemplate).join("0")+input)}static joinString(delimiter,...args){let temp=String.empty;for(let i=0;i<args.length;i++)if(!("string"==typeof args[i]&&String.isNullOrWhiteSpace(args[i])||"number"!=typeof args[i]&&"string"!=typeof args[i])){temp+=""+args[i];for(let i2=i+1;i2<args.length;i2++)if(!String.isNullOrWhiteSpace(args[i2])){temp+=delimiter,i=i2-1;break}}return temp}}exports.Qf=String;exports.fe=class StringBuilder{Values;constructor(value=""){this.Values=[],String.isNullOrWhiteSpace(value)||(this.Values=new Array(value))}toString(){return this.Values.join(String.empty)}ToString(){return this.toString()}append(value){this.Values.push(value)}Append(value){this.append(value)}appendLine(value){this.Values.push("\r\n"+value)}AppendLine(value){this.appendLine(value)}appendFormat(format,...args){this.Values.push(String.format(format,...args))}AppendFormat(format,...args){this.appendFormat(format,...args)}appendLineFormat(format,...args){this.Values.push("\r\n"+String.format(format,...args))}AppendLineFormat(format,...args){return this.appendLineFormat(format,...args)}clear(){this.Values=[]}Clear(){this.clear()}}}}]);