(self.webpackChunkngx_graph=self.webpackChunkngx_graph||[]).push([[880],{"./projects/swimlane/ngx-graph/src/lib/graph/graph.component.scss?ngResource":function(module,__unused_webpack_exports,__webpack_require__){var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/@angular-devkit/build-angular/node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/@angular-devkit/build-angular/node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,".minimap .minimap-background {\n  fill: rgba(0, 0, 0, 0.1);\n}\n.minimap .minimap-drag {\n  fill: rgba(0, 0, 0, 0.2);\n  stroke: rgb(255, 255, 255);\n  stroke-width: 1px;\n  stroke-dasharray: 2px;\n  stroke-dashoffset: 2px;\n  cursor: pointer;\n}\n.minimap .minimap-drag.panning {\n  fill: rgba(0, 0, 0, 0.3);\n}\n.minimap .minimap-nodes {\n  opacity: 0.5;\n  pointer-events: none;\n}\n\n.graph {\n  -webkit-user-select: none;\n          user-select: none;\n}\n.graph .edge {\n  stroke: #666;\n  fill: none;\n}\n.graph .edge .edge-label {\n  stroke: none;\n  font-size: 12px;\n  fill: #251e1e;\n}\n.graph .panning-rect {\n  fill: rgba(0, 0, 0, 0);\n  cursor: move;\n}\n.graph .node-group.old-node {\n  transition: transform 0.5s ease-in-out;\n}\n.graph .node-group .node:focus {\n  outline: none;\n}\n.graph .compound-node rect {\n  opacity: 0.5;\n}\n.graph .cluster rect {\n  opacity: 0.2;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/swimlane/ngx-graph/src/public_api.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{uJ:function(){return GraphComponent},Y2:function(){return LayoutService},lx:function(){return MiniMapPosition},ut:function(){return NgxGraphModule}});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),debug_node_DTOmNMDH=__webpack_require__("./node_modules/@angular/core/fesm2022/debug_node-DTOmNMDH.mjs"),common_module_D4mHDfs1=__webpack_require__("./node_modules/@angular/common/fesm2022/common_module-D4mHDfs1.mjs"),graph_componentngResource=__webpack_require__("./projects/swimlane/ngx-graph/src/lib/graph/graph.component.scss?ngResource"),graph_componentngResource_default=__webpack_require__.n(graph_componentngResource),private_export_B_vy_9K7=__webpack_require__("./node_modules/@angular/animations/fesm2022/private_export-B_vy_9K7.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),src_select=__webpack_require__("./node_modules/d3-selection/src/select.js"),bundle=__webpack_require__("./node_modules/d3-shape/src/curve/bundle.js"),line=__webpack_require__("./node_modules/d3-shape/src/line.js"),sin=__webpack_require__("./node_modules/d3-ease/src/sin.js"),Subscription=(__webpack_require__("./node_modules/d3-transition/src/index.js"),__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js")),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js"),Observable=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Observable.js"),of=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/of.js"),fromEvent=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js"),takeUntil=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js"),debounceTime=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js"),transformation_matrix_src=__webpack_require__("./node_modules/transformation-matrix/src/index.js");const cache={};function id(){let newId=("0000"+(Math.random()*Math.pow(36,4)|0).toString(36)).slice(-4);return newId=`a${newId}`,cache[newId]?id():(cache[newId]=!0,newId)}var Orientation,Alignment,dagre=__webpack_require__("./node_modules/dagre/index.js");!function(Orientation){Orientation.LEFT_TO_RIGHT="LR",Orientation.RIGHT_TO_LEFT="RL",Orientation.TOP_TO_BOTTOM="TB",Orientation.BOTTOM_TO_TOM="BT"}(Orientation||(Orientation={})),function(Alignment){Alignment.CENTER="C",Alignment.UP_LEFT="UL",Alignment.UP_RIGHT="UR",Alignment.DOWN_LEFT="DL",Alignment.DOWN_RIGHT="DR"}(Alignment||(Alignment={}));var simulation=__webpack_require__("./node_modules/d3-force/src/simulation.js"),manyBody=__webpack_require__("./node_modules/d3-force/src/manyBody.js"),collide=__webpack_require__("./node_modules/d3-force/src/collide.js"),src_link=__webpack_require__("./node_modules/d3-force/src/link.js");function toD3Node(maybeNode){return"string"==typeof maybeNode?{id:maybeNode,x:0,y:0}:maybeNode}var dist=__webpack_require__("./node_modules/webcola/dist/index.js"),d3_dispatch_src=__webpack_require__("./node_modules/d3-dispatch/src/index.js"),d3_force_src=__webpack_require__("./node_modules/d3-force/src/index.js"),d3_timer_src=__webpack_require__("./node_modules/d3-timer/src/index.js");function toNode(nodes,nodeRef){return"number"==typeof nodeRef?nodes[nodeRef]:nodeRef}const layouts={dagre:class DagreLayout{defaultSettings={orientation:Orientation.LEFT_TO_RIGHT,marginX:20,marginY:20,edgePadding:100,rankPadding:100,nodePadding:50,multigraph:!0,compound:!0};settings={};dagreGraph;dagreNodes;dagreEdges;run(graph){this.createDagreGraph(graph),dagre.layout(this.dagreGraph),graph.edgeLabels=this.dagreGraph._edgeLabels;for(const dagreNodeId in this.dagreGraph._nodes){const dagreNode=this.dagreGraph._nodes[dagreNodeId],node=graph.nodes.find(n=>n.id===dagreNode.id);node.position={x:dagreNode.x,y:dagreNode.y},node.dimension={width:dagreNode.width,height:dagreNode.height}}return graph}updateEdge(graph,edge){const sourceNode=graph.nodes.find(n=>n.id===edge.source),targetNode=graph.nodes.find(n=>n.id===edge.target),dir=sourceNode.position.y<=targetNode.position.y?-1:1,startingPoint={x:sourceNode.position.x,y:sourceNode.position.y-dir*(sourceNode.dimension.height/2)},endingPoint={x:targetNode.position.x,y:targetNode.position.y+dir*(targetNode.dimension.height/2)};return edge.points=[startingPoint,endingPoint],graph}createDagreGraph(graph){const settings=Object.assign({},this.defaultSettings,this.settings);this.dagreGraph=new dagre.graphlib.Graph({compound:settings.compound,multigraph:settings.multigraph}),this.dagreGraph.setGraph({rankdir:settings.orientation,marginx:settings.marginX,marginy:settings.marginY,edgesep:settings.edgePadding,ranksep:settings.rankPadding,nodesep:settings.nodePadding,align:settings.align,acyclicer:settings.acyclicer,ranker:settings.ranker,multigraph:settings.multigraph,compound:settings.compound}),this.dagreGraph.setDefaultEdgeLabel(()=>({})),this.dagreNodes=graph.nodes.map(n=>{const node=Object.assign({},n);return node.width=n.dimension.width,node.height=n.dimension.height,node.x=n.position.x,node.y=n.position.y,node}),this.dagreEdges=graph.edges.map(l=>{const newLink=Object.assign({},l);return newLink.id||(newLink.id=id()),newLink});for(const node of this.dagreNodes)node.width||(node.width=20),node.height||(node.height=30),this.dagreGraph.setNode(node.id,node);for(const edge of this.dagreEdges)settings.multigraph?this.dagreGraph.setEdge(edge.source,edge.target,edge,edge.id):this.dagreGraph.setEdge(edge.source,edge.target);return this.dagreGraph}},dagreCluster:class DagreClusterLayout{defaultSettings={orientation:Orientation.LEFT_TO_RIGHT,marginX:20,marginY:20,edgePadding:100,rankPadding:100,nodePadding:50,multigraph:!0,compound:!0};settings={};dagreGraph;dagreNodes;dagreClusters;dagreEdges;run(graph){this.createDagreGraph(graph),dagre.layout(this.dagreGraph),graph.edgeLabels=this.dagreGraph._edgeLabels;const dagreToOutput=node=>{const dagreNode=this.dagreGraph._nodes[node.id];return{...node,position:{x:dagreNode.x,y:dagreNode.y},dimension:{width:dagreNode.width,height:dagreNode.height}}};return graph.clusters=(graph.clusters||[]).map(dagreToOutput),graph.nodes=graph.nodes.map(dagreToOutput),graph}updateEdge(graph,edge){const sourceNode=graph.nodes.find(n=>n.id===edge.source),targetNode=graph.nodes.find(n=>n.id===edge.target),dir=sourceNode.position.y<=targetNode.position.y?-1:1,startingPoint={x:sourceNode.position.x,y:sourceNode.position.y-dir*(sourceNode.dimension.height/2)},endingPoint={x:targetNode.position.x,y:targetNode.position.y+dir*(targetNode.dimension.height/2)};return edge.points=[startingPoint,endingPoint],graph}createDagreGraph(graph){const settings=Object.assign({},this.defaultSettings,this.settings);this.dagreGraph=new dagre.graphlib.Graph({compound:settings.compound,multigraph:settings.multigraph}),this.dagreGraph.setGraph({rankdir:settings.orientation,marginx:settings.marginX,marginy:settings.marginY,edgesep:settings.edgePadding,ranksep:settings.rankPadding,nodesep:settings.nodePadding,align:settings.align,acyclicer:settings.acyclicer,ranker:settings.ranker,multigraph:settings.multigraph,compound:settings.compound}),this.dagreGraph.setDefaultEdgeLabel(()=>({})),this.dagreNodes=graph.nodes.map(n=>{const node=Object.assign({},n);return node.width=n.dimension.width,node.height=n.dimension.height,node.x=n.position.x,node.y=n.position.y,node}),this.dagreClusters=graph.clusters||[],this.dagreEdges=graph.edges.map(l=>{const newLink=Object.assign({},l);return newLink.id||(newLink.id=id()),newLink});for(const node of this.dagreNodes)this.dagreGraph.setNode(node.id,node);for(const cluster of this.dagreClusters)this.dagreGraph.setNode(cluster.id,cluster),cluster.childNodeIds.forEach(childNodeId=>{this.dagreGraph.setParent(childNodeId,cluster.id)});for(const edge of this.dagreEdges)settings.multigraph?this.dagreGraph.setEdge(edge.source,edge.target,edge,edge.id):this.dagreGraph.setEdge(edge.source,edge.target);return this.dagreGraph}},dagreNodesOnly:class DagreNodesOnlyLayout{defaultSettings={orientation:Orientation.LEFT_TO_RIGHT,marginX:20,marginY:20,edgePadding:100,rankPadding:100,nodePadding:50,curveDistance:20,multigraph:!0,compound:!0};settings={};dagreGraph;dagreNodes;dagreEdges;run(graph){this.createDagreGraph(graph),dagre.layout(this.dagreGraph),graph.edgeLabels=this.dagreGraph._edgeLabels;for(const dagreNodeId in this.dagreGraph._nodes){const dagreNode=this.dagreGraph._nodes[dagreNodeId],node=graph.nodes.find(n=>n.id===dagreNode.id);node.position={x:dagreNode.x,y:dagreNode.y},node.dimension={width:dagreNode.width,height:dagreNode.height}}for(const edge of graph.edges)this.updateEdge(graph,edge);return graph}updateEdge(graph,edge){const sourceNode=graph.nodes.find(n=>n.id===edge.source),targetNode=graph.nodes.find(n=>n.id===edge.target),rankAxis="BT"===this.settings.orientation||"TB"===this.settings.orientation?"y":"x",orderAxis="y"===rankAxis?"x":"y",rankDimension="y"===rankAxis?"height":"width",dir=sourceNode.position[rankAxis]<=targetNode.position[rankAxis]?-1:1,startingPoint={[orderAxis]:sourceNode.position[orderAxis],[rankAxis]:sourceNode.position[rankAxis]-dir*(sourceNode.dimension[rankDimension]/2)},endingPoint={[orderAxis]:targetNode.position[orderAxis],[rankAxis]:targetNode.position[rankAxis]+dir*(targetNode.dimension[rankDimension]/2)},curveDistance=this.settings.curveDistance||this.defaultSettings.curveDistance;edge.points=[startingPoint,{[orderAxis]:startingPoint[orderAxis],[rankAxis]:startingPoint[rankAxis]-dir*curveDistance},{[orderAxis]:endingPoint[orderAxis],[rankAxis]:endingPoint[rankAxis]+dir*curveDistance},endingPoint];const edgeLabelId=`${edge.source}${edge.target}\0`,matchingEdgeLabel=graph.edgeLabels[edgeLabelId];return matchingEdgeLabel&&(matchingEdgeLabel.points=edge.points),graph}createDagreGraph(graph){const settings=Object.assign({},this.defaultSettings,this.settings);this.dagreGraph=new dagre.graphlib.Graph({compound:settings.compound,multigraph:settings.multigraph}),this.dagreGraph.setGraph({rankdir:settings.orientation,marginx:settings.marginX,marginy:settings.marginY,edgesep:settings.edgePadding,ranksep:settings.rankPadding,nodesep:settings.nodePadding,align:settings.align,acyclicer:settings.acyclicer,ranker:settings.ranker,multigraph:settings.multigraph,compound:settings.compound}),this.dagreGraph.setDefaultEdgeLabel(()=>({})),this.dagreNodes=graph.nodes.map(n=>{const node=Object.assign({},n);return node.width=n.dimension.width,node.height=n.dimension.height,node.x=n.position.x,node.y=n.position.y,node}),this.dagreEdges=graph.edges.map(l=>{const newLink=Object.assign({},l);return newLink.id||(newLink.id=id()),newLink});for(const node of this.dagreNodes)node.width||(node.width=20),node.height||(node.height=30),this.dagreGraph.setNode(node.id,node);for(const edge of this.dagreEdges)settings.multigraph?this.dagreGraph.setEdge(edge.source,edge.target,edge,edge.id):this.dagreGraph.setEdge(edge.source,edge.target);return this.dagreGraph}},d3ForceDirected:class D3ForceDirectedLayout{defaultSettings={force:(0,simulation.A)().force("charge",(0,manyBody.A)().strength(-150)).force("collide",(0,collide.A)(5)),forceLink:(0,src_link.A)().id(node=>node.id).distance(()=>100)};settings={};inputGraph;outputGraph;d3Graph;outputGraph$=new Subject.B;draggingStart;run(graph){return this.inputGraph=graph,this.d3Graph={nodes:[...this.inputGraph.nodes.map(n=>({...n}))],edges:[...this.inputGraph.edges.map(e=>({...e}))]},this.outputGraph={nodes:[],edges:[],edgeLabels:[]},this.outputGraph$.next(this.outputGraph),this.settings=Object.assign({},this.defaultSettings,this.settings),this.settings.force&&this.settings.force.nodes(this.d3Graph.nodes).force("link",this.settings.forceLink.links(this.d3Graph.edges)).alpha(.5).restart().on("tick",()=>{this.outputGraph$.next(this.d3GraphToOutputGraph(this.d3Graph))}),this.outputGraph$.asObservable()}updateEdge(graph,edge){const settings=Object.assign({},this.defaultSettings,this.settings);return settings.force&&settings.force.nodes(this.d3Graph.nodes).force("link",settings.forceLink.links(this.d3Graph.edges)).alpha(.5).restart().on("tick",()=>{this.outputGraph$.next(this.d3GraphToOutputGraph(this.d3Graph))}),this.outputGraph$.asObservable()}d3GraphToOutputGraph(d3Graph){return this.outputGraph.nodes=this.d3Graph.nodes.map(node=>({...node,id:node.id||id(),position:{x:node.x,y:node.y},dimension:{width:node.dimension&&node.dimension.width||20,height:node.dimension&&node.dimension.height||20},transform:`translate(${node.x-(node.dimension&&node.dimension.width||20)/2||0}, ${node.y-(node.dimension&&node.dimension.height||20)/2||0})`})),this.outputGraph.edges=this.d3Graph.edges.map(edge=>({...edge,source:toD3Node(edge.source).id,target:toD3Node(edge.target).id,points:[{x:toD3Node(edge.source).x,y:toD3Node(edge.source).y},{x:toD3Node(edge.target).x,y:toD3Node(edge.target).y}]})),this.outputGraph.edgeLabels=this.outputGraph.edges,this.outputGraph}onDragStart(draggingNode,$event){this.settings.force.alphaTarget(.3).restart();const node=this.d3Graph.nodes.find(d3Node=>d3Node.id===draggingNode.id);node&&(this.draggingStart={x:$event.x-node.x,y:$event.y-node.y},node.fx=$event.x-this.draggingStart.x,node.fy=$event.y-this.draggingStart.y)}onDrag(draggingNode,$event){if(!draggingNode)return;const node=this.d3Graph.nodes.find(d3Node=>d3Node.id===draggingNode.id);node&&(node.fx=$event.x-this.draggingStart.x,node.fy=$event.y-this.draggingStart.y)}onDragEnd(draggingNode,$event){if(!draggingNode)return;const node=this.d3Graph.nodes.find(d3Node=>d3Node.id===draggingNode.id);node&&(this.settings.force.alphaTarget(0),node.fx=void 0,node.fy=void 0)}},colaForceDirected:class ColaForceDirectedLayout{defaultSettings={force:(0,dist.d3adaptor)({...d3_dispatch_src,...d3_force_src,...d3_timer_src}).linkDistance(150).avoidOverlaps(!0),viewDimensions:{width:600,height:600}};settings={};inputGraph;outputGraph;internalGraph;outputGraph$=new Subject.B;draggingStart;run(graph){return this.inputGraph=graph,this.inputGraph.clusters||(this.inputGraph.clusters=[]),this.internalGraph={nodes:[...this.inputGraph.nodes.map(n=>({...n,width:n.dimension?n.dimension.width:20,height:n.dimension?n.dimension.height:20}))],groups:[...this.inputGraph.clusters.map(cluster=>({padding:5,groups:cluster.childNodeIds.map(nodeId=>this.inputGraph.clusters.findIndex(node=>node.id===nodeId)).filter(x=>x>=0),leaves:cluster.childNodeIds.map(nodeId=>this.inputGraph.nodes.findIndex(node=>node.id===nodeId)).filter(x=>x>=0)}))],links:[...this.inputGraph.edges.map(e=>{const sourceNodeIndex=this.inputGraph.nodes.findIndex(node=>e.source===node.id),targetNodeIndex=this.inputGraph.nodes.findIndex(node=>e.target===node.id);if(-1!==sourceNodeIndex&&-1!==targetNodeIndex)return{...e,source:sourceNodeIndex,target:targetNodeIndex}}).filter(x=>!!x)],groupLinks:[...this.inputGraph.edges.map(e=>{const sourceNodeIndex=this.inputGraph.nodes.findIndex(node=>e.source===node.id),targetNodeIndex=this.inputGraph.nodes.findIndex(node=>e.target===node.id);if(!(sourceNodeIndex>=0&&targetNodeIndex>=0))return e}).filter(x=>!!x)]},this.outputGraph={nodes:[],clusters:[],edges:[],edgeLabels:[]},this.outputGraph$.next(this.outputGraph),this.settings=Object.assign({},this.defaultSettings,this.settings),this.settings.force&&(this.settings.force=this.settings.force.nodes(this.internalGraph.nodes).groups(this.internalGraph.groups).links(this.internalGraph.links).alpha(.5).on("tick",()=>{this.settings.onTickListener&&this.settings.onTickListener(this.internalGraph),this.outputGraph$.next(this.internalGraphToOutputGraph(this.internalGraph))}),this.settings.viewDimensions&&(this.settings.force=this.settings.force.size([this.settings.viewDimensions.width,this.settings.viewDimensions.height])),this.settings.forceModifierFn&&(this.settings.force=this.settings.forceModifierFn(this.settings.force)),this.settings.force.start()),this.outputGraph$.asObservable()}updateEdge(graph,edge){const settings=Object.assign({},this.defaultSettings,this.settings);return settings.force&&settings.force.start(),this.outputGraph$.asObservable()}internalGraphToOutputGraph(internalGraph){return this.outputGraph.nodes=internalGraph.nodes.map(node=>({...node,id:node.id||id(),position:{x:node.x,y:node.y},dimension:{width:node.dimension&&node.dimension.width||20,height:node.dimension&&node.dimension.height||20},transform:`translate(${node.x-(node.dimension&&node.dimension.width||20)/2||0}, ${node.y-(node.dimension&&node.dimension.height||20)/2||0})`})),this.outputGraph.edges=internalGraph.links.map(edge=>{const source=toNode(internalGraph.nodes,edge.source),target=toNode(internalGraph.nodes,edge.target);return{...edge,source:source.id,target:target.id,points:[source.bounds.rayIntersection(target.bounds.cx(),target.bounds.cy()),target.bounds.rayIntersection(source.bounds.cx(),source.bounds.cy())]}}).concat(internalGraph.groupLinks.map(groupLink=>{const sourceNode=internalGraph.nodes.find(foundNode=>foundNode.id===groupLink.source),targetNode=internalGraph.nodes.find(foundNode=>foundNode.id===groupLink.target),source=sourceNode||internalGraph.groups.find(foundGroup=>foundGroup.id===groupLink.source),target=targetNode||internalGraph.groups.find(foundGroup=>foundGroup.id===groupLink.target);return{...groupLink,source:source.id,target:target.id,points:[source.bounds.rayIntersection(target.bounds.cx(),target.bounds.cy()),target.bounds.rayIntersection(source.bounds.cx(),source.bounds.cy())]}})),this.outputGraph.clusters=internalGraph.groups.map((group,index)=>({...this.inputGraph.clusters[index],dimension:{width:group.bounds?group.bounds.width():20,height:group.bounds?group.bounds.height():20},position:{x:group.bounds?group.bounds.x+group.bounds.width()/2:0,y:group.bounds?group.bounds.y+group.bounds.height()/2:0}})),this.outputGraph.edgeLabels=this.outputGraph.edges,this.outputGraph}onDragStart(draggingNode,$event){const nodeIndex=this.outputGraph.nodes.findIndex(foundNode=>foundNode.id===draggingNode.id),node=this.internalGraph.nodes[nodeIndex];node&&(this.draggingStart={x:node.x-$event.x,y:node.y-$event.y},node.fixed=1,this.settings.force.start())}onDrag(draggingNode,$event){if(!draggingNode)return;const nodeIndex=this.outputGraph.nodes.findIndex(foundNode=>foundNode.id===draggingNode.id),node=this.internalGraph.nodes[nodeIndex];node&&(node.x=this.draggingStart.x+$event.x,node.y=this.draggingStart.y+$event.y)}onDragEnd(draggingNode,$event){if(!draggingNode)return;const nodeIndex=this.outputGraph.nodes.findIndex(foundNode=>foundNode.id===draggingNode.id),node=this.internalGraph.nodes[nodeIndex];node&&(node.fixed=0)}}};let LayoutService=class LayoutService{getLayout(name){if(layouts[name])return new layouts[name];throw new Error(`Unknown layout type '${name}'`)}};var PanningAxis,MiniMapPosition;function throttle(context,func,wait,options){let args,result;options=options||{};let timeout=null,previous=0;function later(){previous=!1===options.leading?0:+new Date,timeout=null,result=func.apply(context,args)}return function(..._arguments){const now=+new Date;previous||!1!==options.leading||(previous=now);const remaining=wait-(now-previous);return args=_arguments,remaining<=0?(clearTimeout(timeout),timeout=null,previous=now,result=func.apply(context,args)):timeout||!1===options.trailing||(timeout=setTimeout(later,remaining)),result}}LayoutService=(0,tslib_es6.Cg)([(0,debug_node_DTOmNMDH._qm)()],LayoutService),function(PanningAxis){PanningAxis.Both="both",PanningAxis.Horizontal="horizontal",PanningAxis.Vertical="vertical"}(PanningAxis||(PanningAxis={})),function(MiniMapPosition){MiniMapPosition.UpperLeft="UpperLeft",MiniMapPosition.UpperRight="UpperRight"}(MiniMapPosition||(MiniMapPosition={}));var ordinal=__webpack_require__("./node_modules/d3-scale/src/ordinal.js");const colorSets=[{name:"vivid",selectable:!0,group:"Ordinal",domain:["#647c8a","#3f51b5","#2196f3","#00b862","#afdf0a","#a7b61a","#f3e562","#ff9800","#ff5722","#ff4514"]},{name:"natural",selectable:!0,group:"Ordinal",domain:["#bf9d76","#e99450","#d89f59","#f2dfa7","#a5d7c6","#7794b1","#afafaf","#707160","#ba9383","#d9d5c3"]},{name:"cool",selectable:!0,group:"Ordinal",domain:["#a8385d","#7aa3e5","#a27ea8","#aae3f5","#adcded","#a95963","#8796c0","#7ed3ed","#50abcc","#ad6886"]},{name:"fire",selectable:!0,group:"Ordinal",domain:["#ff3d00","#bf360c","#ff8f00","#ff6f00","#ff5722","#e65100","#ffca28","#ffab00"]},{name:"solar",selectable:!0,group:"Continuous",domain:["#fff8e1","#ffecb3","#ffe082","#ffd54f","#ffca28","#ffc107","#ffb300","#ffa000","#ff8f00","#ff6f00"]},{name:"air",selectable:!0,group:"Continuous",domain:["#e1f5fe","#b3e5fc","#81d4fa","#4fc3f7","#29b6f6","#03a9f4","#039be5","#0288d1","#0277bd","#01579b"]},{name:"aqua",selectable:!0,group:"Continuous",domain:["#e0f7fa","#b2ebf2","#80deea","#4dd0e1","#26c6da","#00bcd4","#00acc1","#0097a7","#00838f","#006064"]},{name:"flame",selectable:!1,group:"Ordinal",domain:["#A10A28","#D3342D","#EF6D49","#FAAD67","#FDDE90","#DBED91","#A9D770","#6CBA67","#2C9653","#146738"]},{name:"ocean",selectable:!1,group:"Ordinal",domain:["#1D68FB","#33C0FC","#4AFFFE","#AFFFFF","#FFFC63","#FDBD2D","#FC8A25","#FA4F1E","#FA141B","#BA38D1"]},{name:"forest",selectable:!1,group:"Ordinal",domain:["#55C22D","#C1F33D","#3CC099","#AFFFFF","#8CFC9D","#76CFFA","#BA60FB","#EE6490","#C42A1C","#FC9F32"]},{name:"horizon",selectable:!1,group:"Ordinal",domain:["#2597FB","#65EBFD","#99FDD0","#FCEE4B","#FEFCFA","#FDD6E3","#FCB1A8","#EF6F7B","#CB96E8","#EFDEE0"]},{name:"neons",selectable:!1,group:"Ordinal",domain:["#FF3333","#FF33FF","#CC33FF","#0000FF","#33CCFF","#33FFFF","#33FF66","#CCFF33","#FFCC00","#FF6600"]},{name:"picnic",selectable:!1,group:"Ordinal",domain:["#FAC51D","#66BD6D","#FAA026","#29BB9C","#E96B56","#55ACD2","#B7332F","#2C83C9","#9166B8","#92E7E8"]},{name:"night",selectable:!1,group:"Ordinal",domain:["#2B1B5A","#501356","#183356","#28203F","#391B3C","#1E2B3C","#120634","#2D0432","#051932","#453080","#75267D","#2C507D","#4B3880","#752F7D","#35547D"]},{name:"nightLights",selectable:!1,group:"Ordinal",domain:["#4e31a5","#9c25a7","#3065ab","#57468b","#904497","#46648b","#32118d","#a00fb3","#1052a2","#6e51bd","#b63cc3","#6c97cb","#8671c1","#b455be","#7496c3"]}];class ColorHelper{scale;colorDomain;domain;customColors;constructor(scheme,domain,customColors){"string"==typeof scheme&&(scheme=colorSets.find(cs=>cs.name===scheme)),this.colorDomain=scheme.domain,this.domain=domain,this.customColors=customColors,this.scale=this.generateColorScheme(scheme,this.domain)}generateColorScheme(scheme,domain){return"string"==typeof scheme&&(scheme=colorSets.find(cs=>cs.name===scheme)),(0,ordinal.A)().range(scheme.domain).domain(domain)}getColor(value){if(null==value)throw new Error("Value can not be null");if("function"==typeof this.customColors)return this.customColors(value);const formattedValue=value.toString();let found;return this.customColors&&this.customColors.length>0&&(found=this.customColors.find(mapping=>mapping.name.toLowerCase()===formattedValue.toLowerCase())),found?found.value:this.scale(value)}}function calculateViewDimensions({width:width,height:height}){let chartWidth=width,chartHeight=height;return chartWidth=Math.max(0,chartWidth),chartHeight=Math.max(0,chartHeight),{width:Math.floor(chartWidth),height:Math.floor(chartHeight)}}let VisibilityObserver=class VisibilityObserver{element;zone;visible=new debug_node_DTOmNMDH.bkB;timeout;isVisible=!1;constructor(element,zone){this.element=element,this.zone=zone,this.runCheck()}destroy(){clearTimeout(this.timeout)}onVisibilityChange(){this.zone.run(()=>{this.isVisible=!0,this.visible.emit(!0)})}runCheck(){const check=()=>{if(!this.element)return;const{offsetHeight:offsetHeight,offsetWidth:offsetWidth}=this.element.nativeElement;offsetHeight&&offsetWidth?(clearTimeout(this.timeout),this.onVisibilityChange()):(clearTimeout(this.timeout),this.zone.runOutsideAngular(()=>{this.timeout=setTimeout(()=>check(),100)}))};this.zone.runOutsideAngular(()=>{this.timeout=setTimeout(()=>check())})}static ctorParameters=()=>[{type:debug_node_DTOmNMDH.aKT},{type:debug_node_DTOmNMDH.SKi}];static propDecorators={visible:[{type:debug_node_DTOmNMDH.k7i}]}};var NgxGraphStates;VisibilityObserver=(0,tslib_es6.Cg)([(0,debug_node_DTOmNMDH.WLR)({selector:"visibility-observer",standalone:!1})],VisibilityObserver),function(NgxGraphStates){NgxGraphStates.Init="init",NgxGraphStates.Subscribe="subscribe",NgxGraphStates.Transform="transform",NgxGraphStates.Output="output"}(NgxGraphStates||(NgxGraphStates={}));let GraphComponent=class GraphComponent{el;zone;cd;layoutService;nodes=[];clusters=[];compoundNodes=[];links=[];activeEntries=[];curve;draggingEnabled=!0;nodeHeight;nodeMaxHeight;nodeMinHeight;nodeWidth;nodeMinWidth;nodeMaxWidth;panningEnabled=!0;panningAxis=PanningAxis.Both;enableZoom=!0;zoomSpeed=.1;minZoomLevel=.1;maxZoomLevel=4;autoZoom=!1;panOnZoom=!0;animate=!1;autoCenter=!1;update$;center$;zoomToFit$;panToNode$;layout;layoutSettings;enableTrackpadSupport=!1;showMiniMap=!1;miniMapMaxWidth=100;miniMapMaxHeight;miniMapPosition=MiniMapPosition.UpperRight;view;scheme="cool";customColors;deferDisplayUntilPosition=!1;centerNodesOnPositionChange=!0;enablePreUpdateTransform=!0;select=new debug_node_DTOmNMDH.bkB;activate=new debug_node_DTOmNMDH.bkB;deactivate=new debug_node_DTOmNMDH.bkB;zoomChange=new debug_node_DTOmNMDH.bkB;clickHandler=new debug_node_DTOmNMDH.bkB;stateChange=new debug_node_DTOmNMDH.bkB;linkTemplate;nodeTemplate;clusterTemplate;defsTemplate;miniMapNodeTemplate;nodeElements;linkElements;chartWidth;isMouseMoveCalled=!1;graphSubscription=new Subscription.yU;colors;dims;seriesDomain;transform;isPanning=!1;isDragging=!1;draggingNode;initialized=!1;graph;graphDims={width:0,height:0};_oldLinks=[];oldNodes=new Set;oldClusters=new Set;oldCompoundNodes=new Set;transformationMatrix=(0,transformation_matrix_src.D_)();_touchLastX=null;_touchLastY=null;minimapScaleCoefficient=3;minimapTransform;minimapOffsetX=0;minimapOffsetY=0;isMinimapPanning=!1;minimapClipPathId;width;height;resizeSubscription;visibilityObserver;destroy$=new Subject.B;constructor(el,zone,cd,layoutService){this.el=el,this.zone=zone,this.cd=cd,this.layoutService=layoutService}groupResultsBy=node=>node.label;get zoomLevel(){return this.transformationMatrix.a}set zoomLevel(level){this.zoomTo(Number(level))}get panOffsetX(){return this.transformationMatrix.e}set panOffsetX(x){this.panTo(Number(x),null)}get panOffsetY(){return this.transformationMatrix.f}set panOffsetY(y){this.panTo(null,Number(y))}ngOnInit(){this.update$&&this.update$.pipe((0,takeUntil.Q)(this.destroy$)).subscribe(()=>{this.update()}),this.center$&&this.center$.pipe((0,takeUntil.Q)(this.destroy$)).subscribe(()=>{this.center()}),this.zoomToFit$&&this.zoomToFit$.pipe((0,takeUntil.Q)(this.destroy$)).subscribe(options=>{this.zoomToFit(options||{})}),this.panToNode$&&this.panToNode$.pipe((0,takeUntil.Q)(this.destroy$)).subscribe(nodeId=>{this.panToNodeId(nodeId)}),this.minimapClipPathId=`minimapClip${id()}`,this.stateChange.emit({state:NgxGraphStates.Subscribe})}ngOnChanges(changes){this.basicUpdate();const{layoutSettings:layoutSettings}=changes;this.setLayout(this.layout),layoutSettings&&this.setLayoutSettings(this.layoutSettings),this.layout&&this.nodes.length&&this.links.length&&this.update()}setLayout(layout){this.initialized=!1,layout||(layout="dagre"),"string"==typeof layout&&(this.layout=this.layoutService.getLayout(layout),this.setLayoutSettings(this.layoutSettings))}setLayoutSettings(settings){this.layout&&"string"!=typeof this.layout&&(this.layout.settings=settings)}ngOnDestroy(){this.unbindEvents(),this.visibilityObserver&&(this.visibilityObserver.visible.unsubscribe(),this.visibilityObserver.destroy()),this.destroy$.next(),this.destroy$.complete()}ngAfterViewInit(){this.bindWindowResizeEvent(),this.visibilityObserver=new VisibilityObserver(this.el,this.zone),this.visibilityObserver.visible.subscribe(this.update.bind(this)),setTimeout(()=>this.update())}update(){this.basicUpdate(),this.curve||(this.curve=bundle.A.beta(1)),this.zone.run(()=>{this.dims=calculateViewDimensions({width:this.width,height:this.height}),this.seriesDomain=this.getSeriesDomain(),this.setColors(),this.createGraph(),this.updateTransform(),this.initialized||this.stateChange.emit({state:NgxGraphStates.Init}),this.initialized=!0})}createGraph(){this.graphSubscription.unsubscribe(),this.graphSubscription=new Subscription.yU;const initializeNode=n=>(n.meta||(n.meta={}),n.id||(n.id=id()),n.dimension?n.meta.forceDimensions=void 0===n.meta.forceDimensions||n.meta.forceDimensions:(n.dimension={width:this.nodeWidth?this.nodeWidth:30,height:this.nodeHeight?this.nodeHeight:30},n.meta.forceDimensions=!1),n.position||(n.position={x:0,y:0},this.deferDisplayUntilPosition&&(n.hidden=!0)),n.data=n.data?n.data:{},n);this.graph={nodes:this.nodes.map(n=>initializeNode(n)),clusters:this.clusters.map(n=>initializeNode(n)),compoundNodes:this.compoundNodes.map(n=>initializeNode(n)),edges:this.links.map(e=>(e=>(e.id||(e.id=id()),e))(e))},requestAnimationFrame(()=>this.draw())}draw(){const result=this.layout.run(this.graph),result$=result instanceof Observable.c?result:(0,of.of)(result);this.graphSubscription.add(result$.subscribe(graph=>{this.graph=graph,this.tick()}))}tick(){const oldNodes=new Set,oldClusters=new Set,oldCompoundNodes=new Set;this.graph.nodes.forEach(n=>{n.transform=`translate(${n.position.x-(this.centerNodesOnPositionChange?n.dimension.width/2:0)||0}, ${n.position.y-(this.centerNodesOnPositionChange?n.dimension.height/2:0)||0})`,n.data||(n.data={}),n.data.color=this.colors.getColor(this.groupResultsBy(n)),this.deferDisplayUntilPosition&&(n.hidden=!1),oldNodes.add(n.id)}),(this.graph.clusters||[]).forEach(n=>{n.transform=`translate(${n.position.x-(this.centerNodesOnPositionChange?n.dimension.width/2:0)||0}, ${n.position.y-(this.centerNodesOnPositionChange?n.dimension.height/2:0)||0})`,n.data||(n.data={}),n.data.color=this.colors.getColor(this.groupResultsBy(n)),this.deferDisplayUntilPosition&&(n.hidden=!1),oldClusters.add(n.id)}),(this.graph.compoundNodes||[]).forEach(n=>{n.transform=`translate(${n.position.x-(this.centerNodesOnPositionChange?n.dimension.width/2:0)||0}, ${n.position.y-(this.centerNodesOnPositionChange?n.dimension.height/2:0)||0})`,n.data||(n.data={}),n.data.color=this.colors.getColor(this.groupResultsBy(n)),this.deferDisplayUntilPosition&&(n.hidden=!1),oldCompoundNodes.add(n.id)}),setTimeout(()=>{this.oldNodes=oldNodes,this.oldClusters=oldClusters,this.oldCompoundNodes=oldCompoundNodes},500);const newLinks=[];for(const edgeLabelId in this.graph.edgeLabels){const edgeLabel=this.graph.edgeLabels[edgeLabelId],normKey=edgeLabelId.replace(/[^\w-]*/g,""),isMultigraph=this.layout&&"string"!=typeof this.layout&&this.layout.settings&&this.layout.settings.multigraph;let oldLink=isMultigraph?this._oldLinks.find(ol=>`${ol.source}${ol.target}${ol.id}`===normKey):this._oldLinks.find(ol=>`${ol.source}${ol.target}`===normKey);const linkFromGraph=isMultigraph?this.graph.edges.find(nl=>`${nl.source}${nl.target}${nl.id}`===normKey):this.graph.edges.find(nl=>`${nl.source}${nl.target}`===normKey);oldLink?oldLink.data&&linkFromGraph&&linkFromGraph.data&&JSON.stringify(oldLink.data)!==JSON.stringify(linkFromGraph.data)&&(oldLink.data=linkFromGraph.data):oldLink=linkFromGraph||edgeLabel,oldLink.oldLine=oldLink.line;const points=edgeLabel.points,line=this.generateLine(points),newLink=Object.assign({},oldLink);newLink.line=line,newLink.points=points,this.updateMidpointOnEdge(newLink,points);const textPos=points[Math.floor(points.length/2)];textPos&&(newLink.textTransform=`translate(${textPos.x||0},${textPos.y||0})`),newLink.textAngle=0,newLink.oldLine||(newLink.oldLine=newLink.line),this.calcDominantBaseline(newLink),newLinks.push(newLink)}this.graph.edges=newLinks,this.graph.edges&&(this._oldLinks=this.graph.edges.map(l=>{const newL=Object.assign({},l);return newL.oldLine=l.line,newL})),this.applyNodeDimensions(),this.redrawLines(),this.updateMinimap(),requestAnimationFrame(()=>{this.applyNodeDimensions(),this.redrawLines(),this.updateMinimap(),this.autoZoom?this.zoomToFit({autoCenter:!!this.autoCenter&&this.autoCenter}):this.autoCenter&&this.center(),this.stateChange.emit({state:NgxGraphStates.Output})}),this.cd.markForCheck()}getMinimapTransform(){switch(this.miniMapPosition){case MiniMapPosition.UpperLeft:return"";case MiniMapPosition.UpperRight:return"translate("+(this.dims.width-this.graphDims.width/this.minimapScaleCoefficient)+",0)";default:return""}}updateGraphDims(){let minX=1/0,maxX=-1/0,minY=1/0,maxY=-1/0;for(let i=0;i<this.graph.nodes.length;i++){const node=this.graph.nodes[i];minX=node.position.x<minX?node.position.x:minX,minY=node.position.y<minY?node.position.y:minY,maxX=node.position.x+node.dimension.width>maxX?node.position.x+node.dimension.width:maxX,maxY=node.position.y+node.dimension.height>maxY?node.position.y+node.dimension.height:maxY}minX-=100,minY-=100,maxX+=100,maxY+=100,this.graphDims.width=maxX-minX,this.graphDims.height=maxY-minY,this.minimapOffsetX=minX,this.minimapOffsetY=minY}updateMinimap(){this.graph.nodes&&this.graph.nodes.length&&(this.updateGraphDims(),this.miniMapMaxWidth&&(this.minimapScaleCoefficient=this.graphDims.width/this.miniMapMaxWidth),this.miniMapMaxHeight&&(this.minimapScaleCoefficient=Math.max(this.minimapScaleCoefficient,this.graphDims.height/this.miniMapMaxHeight)),this.minimapTransform=this.getMinimapTransform())}applyNodeDimensions(){this.nodeElements&&this.nodeElements.length&&this.nodeElements.forEach(elem=>{const nativeElement=elem.nativeElement,node=this.graph.nodes.find(n=>n.id===nativeElement.id);if(!node)return;let dims;try{if(dims=nativeElement.getBBox(),!dims.width||!dims.height)return}catch(ex){return}if(this.nodeHeight?node.dimension.height=node.dimension.height&&node.meta.forceDimensions?node.dimension.height:this.nodeHeight:node.dimension.height=node.dimension.height&&node.meta.forceDimensions?node.dimension.height:dims.height,this.nodeMaxHeight&&(node.dimension.height=Math.max(node.dimension.height,this.nodeMaxHeight)),this.nodeMinHeight&&(node.dimension.height=Math.min(node.dimension.height,this.nodeMinHeight)),this.nodeWidth)node.dimension.width=node.dimension.width&&node.meta.forceDimensions?node.dimension.width:this.nodeWidth;else if(nativeElement.getElementsByTagName("text").length){let maxTextDims;try{for(const textElem of nativeElement.getElementsByTagName("text")){const currentBBox=textElem.getBBox();maxTextDims?(currentBBox.width>maxTextDims.width&&(maxTextDims.width=currentBBox.width),currentBBox.height>maxTextDims.height&&(maxTextDims.height=currentBBox.height)):maxTextDims=currentBBox}}catch(ex){return}node.dimension.width=node.dimension.width&&node.meta.forceDimensions?node.dimension.width:maxTextDims.width+20}else node.dimension.width=node.dimension.width&&node.meta.forceDimensions?node.dimension.width:dims.width;this.nodeMaxWidth&&(node.dimension.width=Math.max(node.dimension.width,this.nodeMaxWidth)),this.nodeMinWidth&&(node.dimension.width=Math.min(node.dimension.width,this.nodeMinWidth))})}redrawLines(_animate=this.animate){this.linkElements.forEach(linkEl=>{const edge=this.graph.edges.find(lin=>lin.id===linkEl.nativeElement.id);if(edge){(0,src_select.A)(linkEl.nativeElement).select(".line").attr("d",edge.oldLine).transition().ease(sin.i5).duration(_animate?500:0).attr("d",edge.line);(0,src_select.A)(this.el.nativeElement).select(`#${edge.id}`).attr("d",edge.oldTextPath).transition().ease(sin.i5).duration(_animate?500:0).attr("d",edge.textPath),this.updateMidpointOnEdge(edge,edge.points)}})}calcDominantBaseline(link){const firstPoint=link.points[0],lastPoint=link.points[link.points.length-1];link.oldTextPath=link.textPath,lastPoint.x<firstPoint.x?(link.dominantBaseline="text-before-edge",link.textPath=this.generateLine([...link.points].reverse())):(link.dominantBaseline="text-after-edge",link.textPath=link.line)}generateLine(points){return line.A().x(d=>d.x).y(d=>d.y).curve(this.curve)(points)}onZoom($event,direction){if(this.enableTrackpadSupport&&!$event.ctrlKey)return void this.pan(-1*$event.deltaX,-1*$event.deltaY);const zoomFactor=1+("in"===direction?this.zoomSpeed:-this.zoomSpeed),newZoomLevel=this.zoomLevel*zoomFactor;if(!(newZoomLevel<=this.minZoomLevel||newZoomLevel>=this.maxZoomLevel)&&this.enableZoom)if(!0===this.panOnZoom&&$event){const mouseX=$event.clientX,mouseY=$event.clientY,svg=this.el.nativeElement.querySelector("svg"),svgGroup=svg.querySelector("g.chart"),point=svg.createSVGPoint();point.x=mouseX,point.y=mouseY;const svgPoint=point.matrixTransform(svgGroup.getScreenCTM().inverse());this.pan(svgPoint.x,svgPoint.y,!0),this.zoom(zoomFactor),this.pan(-svgPoint.x,-svgPoint.y,!0)}else this.zoom(zoomFactor)}pan(x,y,ignoreZoomLevel=!1){const zoomLevel=ignoreZoomLevel?1:this.zoomLevel;this.transformationMatrix=(0,transformation_matrix_src.pd)(this.transformationMatrix,(0,transformation_matrix_src.Tl)(x/zoomLevel,y/zoomLevel)),this.updateTransform()}panTo(x,y){if(null==x||isNaN(x)||null==y||isNaN(y))return;const panX=-this.panOffsetX-x*this.zoomLevel+this.dims.width/2,panY=-this.panOffsetY-y*this.zoomLevel+this.dims.height/2;this.transformationMatrix=(0,transformation_matrix_src.pd)(this.transformationMatrix,(0,transformation_matrix_src.Tl)(panX/this.zoomLevel,panY/this.zoomLevel)),this.updateTransform()}zoom(factor){this.transformationMatrix=(0,transformation_matrix_src.pd)(this.transformationMatrix,(0,transformation_matrix_src.hs)(factor,factor)),this.zoomChange.emit(this.zoomLevel),this.updateTransform()}zoomTo(level){this.transformationMatrix.a=isNaN(level)?this.transformationMatrix.a:Number(level),this.transformationMatrix.d=isNaN(level)?this.transformationMatrix.d:Number(level),this.zoomChange.emit(this.zoomLevel),this.enablePreUpdateTransform&&this.updateTransform(),this.update()}onDrag(event){if(!this.draggingEnabled)return;const node=this.draggingNode;this.layout&&"string"!=typeof this.layout&&this.layout.onDrag&&this.layout.onDrag(node,event),node.position.x+=event.movementX/this.zoomLevel,node.position.y+=event.movementY/this.zoomLevel;const x=node.position.x-(this.centerNodesOnPositionChange?node.dimension.width/2:0),y=node.position.y-(this.centerNodesOnPositionChange?node.dimension.height/2:0);node.transform=`translate(${x}, ${y})`;for(const link of this.graph.edges)if((link.target===node.id||link.source===node.id||link.target.id===node.id||link.source.id===node.id)&&this.layout&&"string"!=typeof this.layout){const result=this.layout.updateEdge(this.graph,link),result$=result instanceof Observable.c?result:(0,of.of)(result);this.graphSubscription.add(result$.subscribe(graph=>{this.graph=graph,this.redrawEdge(link)}))}this.redrawLines(!1),this.updateMinimap()}redrawEdge(edge){const line=this.generateLine(edge.points);this.calcDominantBaseline(edge),edge.oldLine=edge.line,edge.line=line}updateTransform(){this.transform=(0,transformation_matrix_src.ex)((0,transformation_matrix_src.c2)(this.transformationMatrix,100)),this.stateChange.emit({state:NgxGraphStates.Transform})}onClick(event){this.select.emit(event)}onActivate(event){this.activeEntries.indexOf(event)>-1||(this.activeEntries=[event,...this.activeEntries],this.activate.emit({value:event,entries:this.activeEntries}))}onDeactivate(event){const idx=this.activeEntries.indexOf(event);this.activeEntries.splice(idx,1),this.activeEntries=[...this.activeEntries],this.deactivate.emit({value:event,entries:this.activeEntries})}getSeriesDomain(){return this.nodes.map(d=>this.groupResultsBy(d)).reduce((nodes,node)=>-1!==nodes.indexOf(node)?nodes:nodes.concat([node]),[]).sort()}trackLinkBy(index,link){return link.id}trackNodeBy(index,node){return node.id}setColors(){this.colors=new ColorHelper(this.scheme,this.seriesDomain,this.customColors)}onMouseMove($event){this.isMouseMoveCalled=!0,(this.isPanning||this.isMinimapPanning)&&this.panningEnabled?this.panWithConstraints(this.panningAxis,$event):this.isDragging&&this.draggingEnabled&&this.onDrag($event)}onMouseDown(event){this.isMouseMoveCalled=!1}graphClick(event){this.isMouseMoveCalled||this.clickHandler.emit(event)}onTouchStart(event){this._touchLastX=event.changedTouches[0].clientX,this._touchLastY=event.changedTouches[0].clientY,this.isPanning=!0}onTouchMove($event){if(this.isPanning&&this.panningEnabled){const clientX=$event.changedTouches[0].clientX,clientY=$event.changedTouches[0].clientY,movementX=clientX-this._touchLastX,movementY=clientY-this._touchLastY;this._touchLastX=clientX,this._touchLastY=clientY,this.pan(movementX,movementY)}}onTouchEnd(){this.isPanning=!1}onMouseUp(event){this.isDragging=!1,this.isPanning=!1,this.isMinimapPanning=!1,this.layout&&"string"!=typeof this.layout&&this.layout.onDragEnd&&this.layout.onDragEnd(this.draggingNode,event)}onNodeMouseDown(event,node){this.draggingEnabled&&(this.isDragging=!0,this.draggingNode=node,this.layout&&"string"!=typeof this.layout&&this.layout.onDragStart&&this.layout.onDragStart(node,event))}onMinimapDragMouseDown(){this.isMinimapPanning=!0}onMinimapPanTo(event){const x=event.offsetX-(this.dims.width-(this.graphDims.width+this.minimapOffsetX)/this.minimapScaleCoefficient),y=event.offsetY+this.minimapOffsetY/this.minimapScaleCoefficient;this.panTo(x*this.minimapScaleCoefficient,y*this.minimapScaleCoefficient),this.isMinimapPanning=!0}center(){this.panTo(this.graphDims.width/2,this.graphDims.height/2)}zoomToFit(zoomOptions){this.dims=calculateViewDimensions({width:this.width,height:this.height}),this.updateGraphDims();const heightZoom=this.dims.height/this.graphDims.height,widthZoom=this.dims.width/this.graphDims.width;let zoomLevel=Math.min(heightZoom,widthZoom,1);zoomLevel<this.minZoomLevel&&(zoomLevel=this.minZoomLevel),zoomLevel>this.maxZoomLevel&&(zoomLevel=this.maxZoomLevel),!0!==zoomOptions?.force&&zoomLevel===this.zoomLevel||(this.zoomLevel=zoomLevel,!0!==zoomOptions?.autoCenter&&this.updateTransform(),!0===zoomOptions?.autoCenter&&this.center(),this.zoomChange.emit(this.zoomLevel))}panToNodeId(nodeId){const node=this.graph.nodes.find(n=>n.id===nodeId);node&&this.panTo(node.position.x,node.position.y)}getCompoundNodeChildren(ids){return this.nodes.filter(node=>ids.includes(node.id))}panWithConstraints(key,event){let x=event.movementX,y=event.movementY;switch(this.isMinimapPanning&&(x=-this.minimapScaleCoefficient*x*this.zoomLevel,y=-this.minimapScaleCoefficient*y*this.zoomLevel),key){case PanningAxis.Horizontal:this.pan(x,0);break;case PanningAxis.Vertical:this.pan(0,y);break;default:this.pan(x,y)}}updateMidpointOnEdge(edge,points){if(edge&&points)if(points.length%2==1)edge.midPoint=points[Math.floor(points.length/2)];else if(this.layout?.settings?.properties?.["elk.direction"])this._calcMidPointElk(edge,points);else{const _first=points[points.length/2],_second=points[points.length/2-1];edge.midPoint={x:(_first.x+_second.x)/2,y:(_first.y+_second.y)/2}}}_calcMidPointElk(edge,points){let _firstX=null,_secondX=null,_firstY=null,_secondY=null;const orientation=this.layout.settings?.properties["elk.direction"];("RIGHT"===orientation?points.some(p=>p.y!==points[0].y):points.some(p=>p.x!==points[0].x))?(_firstX=points[points.length-1],_secondX=points[points.length-2],_firstY=points[points.length-1],_secondY=points[points.length-2]):"RIGHT"===orientation?(_firstX=points[0],_secondX=points[points.length-1],_firstY=points[points.length/2],_secondY=points[points.length/2-1]):(_firstX=points[points.length/2],_secondX=points[points.length/2-1],_firstY=points[0],_secondY=points[points.length-1]),edge.midPoint={x:(_firstX.x+_secondX.x)/2,y:(_firstY.y+_secondY.y)/2}}basicUpdate(){if(this.view)this.width=this.view[0],this.height=this.view[1];else{const dims=this.getContainerDims();dims&&(this.width=dims.width,this.height=dims.height)}this.width||(this.width=600),this.height||(this.height=400),this.width=Math.floor(this.width),this.height=Math.floor(this.height),this.cd&&this.cd.markForCheck()}getContainerDims(){let width,height;const hostElem=this.el.nativeElement;if(null!==hostElem.parentNode){const dims=hostElem.parentNode.getBoundingClientRect();width=dims.width,height=dims.height}return width&&height?{width:width,height:height}:null}hasGraphDims(){return this.graphDims.width>0&&this.graphDims.height>0}hasNodeDims(){return this.graph.nodes?.every(node=>node.dimension.width>0&&node.dimension.height>0)}hasCompoundNodeDims(){return this.graph.compoundNodes?.every(node=>node.dimension.width>0&&node.dimension.height>0)}hasClusterDims(){return this.graph.clusters?.every(node=>node.dimension.width>0&&node.dimension.height>0)}hasDims(){return this.hasGraphDims()&&this.hasNodeDims()&&(!this.compoundNodes?.length||this.hasCompoundNodeDims()||!this.clusters?.length||this.hasClusterDims())}unbindEvents(){this.resizeSubscription&&this.resizeSubscription.unsubscribe()}bindWindowResizeEvent(){const subscription=(0,fromEvent.R)(window,"resize").pipe((0,debounceTime.B)(200)).subscribe(e=>{this.update(),this.cd&&this.cd.markForCheck()});this.resizeSubscription=subscription}static ctorParameters=()=>[{type:debug_node_DTOmNMDH.aKT},{type:debug_node_DTOmNMDH.SKi},{type:core.ChangeDetectorRef},{type:LayoutService}];static propDecorators={nodes:[{type:debug_node_DTOmNMDH.pde}],clusters:[{type:debug_node_DTOmNMDH.pde}],compoundNodes:[{type:debug_node_DTOmNMDH.pde}],links:[{type:debug_node_DTOmNMDH.pde}],activeEntries:[{type:debug_node_DTOmNMDH.pde}],curve:[{type:debug_node_DTOmNMDH.pde}],draggingEnabled:[{type:debug_node_DTOmNMDH.pde}],nodeHeight:[{type:debug_node_DTOmNMDH.pde}],nodeMaxHeight:[{type:debug_node_DTOmNMDH.pde}],nodeMinHeight:[{type:debug_node_DTOmNMDH.pde}],nodeWidth:[{type:debug_node_DTOmNMDH.pde}],nodeMinWidth:[{type:debug_node_DTOmNMDH.pde}],nodeMaxWidth:[{type:debug_node_DTOmNMDH.pde}],panningEnabled:[{type:debug_node_DTOmNMDH.pde}],panningAxis:[{type:debug_node_DTOmNMDH.pde}],enableZoom:[{type:debug_node_DTOmNMDH.pde}],zoomSpeed:[{type:debug_node_DTOmNMDH.pde}],minZoomLevel:[{type:debug_node_DTOmNMDH.pde}],maxZoomLevel:[{type:debug_node_DTOmNMDH.pde}],autoZoom:[{type:debug_node_DTOmNMDH.pde}],panOnZoom:[{type:debug_node_DTOmNMDH.pde}],animate:[{type:debug_node_DTOmNMDH.pde}],autoCenter:[{type:debug_node_DTOmNMDH.pde}],update$:[{type:debug_node_DTOmNMDH.pde}],center$:[{type:debug_node_DTOmNMDH.pde}],zoomToFit$:[{type:debug_node_DTOmNMDH.pde}],panToNode$:[{type:debug_node_DTOmNMDH.pde}],layout:[{type:debug_node_DTOmNMDH.pde}],layoutSettings:[{type:debug_node_DTOmNMDH.pde}],enableTrackpadSupport:[{type:debug_node_DTOmNMDH.pde}],showMiniMap:[{type:debug_node_DTOmNMDH.pde}],miniMapMaxWidth:[{type:debug_node_DTOmNMDH.pde}],miniMapMaxHeight:[{type:debug_node_DTOmNMDH.pde}],miniMapPosition:[{type:debug_node_DTOmNMDH.pde}],view:[{type:debug_node_DTOmNMDH.pde}],scheme:[{type:debug_node_DTOmNMDH.pde}],customColors:[{type:debug_node_DTOmNMDH.pde}],deferDisplayUntilPosition:[{type:debug_node_DTOmNMDH.pde}],centerNodesOnPositionChange:[{type:debug_node_DTOmNMDH.pde}],enablePreUpdateTransform:[{type:debug_node_DTOmNMDH.pde}],select:[{type:debug_node_DTOmNMDH.k7i}],activate:[{type:debug_node_DTOmNMDH.k7i}],deactivate:[{type:debug_node_DTOmNMDH.k7i}],zoomChange:[{type:debug_node_DTOmNMDH.k7i}],clickHandler:[{type:debug_node_DTOmNMDH.k7i}],stateChange:[{type:debug_node_DTOmNMDH.k7i}],linkTemplate:[{type:core.ContentChild,args:["linkTemplate"]}],nodeTemplate:[{type:core.ContentChild,args:["nodeTemplate"]}],clusterTemplate:[{type:core.ContentChild,args:["clusterTemplate"]}],defsTemplate:[{type:core.ContentChild,args:["defsTemplate"]}],miniMapNodeTemplate:[{type:core.ContentChild,args:["miniMapNodeTemplate"]}],nodeElements:[{type:core.ViewChildren,args:["nodeElement"]}],linkElements:[{type:core.ViewChildren,args:["linkElement"]}],groupResultsBy:[{type:debug_node_DTOmNMDH.pde}],zoomLevel:[{type:debug_node_DTOmNMDH.pde,args:["zoomLevel"]}],panOffsetX:[{type:debug_node_DTOmNMDH.pde,args:["panOffsetX"]}],panOffsetY:[{type:debug_node_DTOmNMDH.pde,args:["panOffsetY"]}],onMouseMove:[{type:debug_node_DTOmNMDH.Z$l,args:["document:mousemove",["$event"]]}],onMouseDown:[{type:debug_node_DTOmNMDH.Z$l,args:["document:mousedown",["$event"]]}],graphClick:[{type:debug_node_DTOmNMDH.Z$l,args:["document:click",["$event"]]}],onTouchMove:[{type:debug_node_DTOmNMDH.Z$l,args:["document:touchmove",["$event"]]}],onMouseUp:[{type:debug_node_DTOmNMDH.Z$l,args:["document:mouseup",["$event"]]}]}};(0,tslib_es6.Cg)([function throttleable(duration,options){return function innerDecorator(target,key,descriptor){return{configurable:!0,enumerable:descriptor.enumerable,get:function getter(){return Object.defineProperty(this,key,{configurable:!0,enumerable:descriptor.enumerable,value:throttle(this,descriptor.value,duration,options)}),this[key]}}}}(500)],GraphComponent.prototype,"updateMinimap",null),GraphComponent=(0,tslib_es6.Cg)([(0,debug_node_DTOmNMDH.uAl)({selector:"ngx-graph",template:'<div\n  class="ngx-graph-outer"\n  [style.width.px]="width"\n  [@animationState]="\'active\'"\n  [@.disabled]="!animate"\n  (mouseWheelUp)="onZoom($event, \'in\')"\n  (mouseWheelDown)="onZoom($event, \'out\')"\n  mouseWheel\n>\n  <svg:svg class="ngx-graph" [attr.width]="width" [attr.height]="height">\n    <svg:g\n      *ngIf="initialized && graph"\n      [attr.transform]="transform"\n      (touchstart)="onTouchStart($event)"\n      (touchend)="onTouchEnd()"\n      class="graph chart"\n    >\n      <defs>\n        <ng-container *ngIf="defsTemplate" [ngTemplateOutlet]="defsTemplate"></ng-container>\n        <svg:path\n          class="text-path"\n          *ngFor="let link of graph.edges"\n          [attr.d]="link.textPath"\n          [attr.id]="link.id"\n        ></svg:path>\n      </defs>\n\n      <svg:rect\n        class="panning-rect"\n        [attr.width]="dims.width * 100"\n        [attr.height]="dims.height * 100"\n        [attr.transform]="\'translate(\' + (-dims.width || 0) * 50 + \',\' + (-dims.height || 0) * 50 + \')\'"\n        (mousedown)="isPanning = true"\n      />\n\n      <ng-content></ng-content>\n\n      <svg:g class="clusters">\n        <svg:g\n          #clusterElement\n          *ngFor="let node of graph.clusters; trackBy: trackNodeBy"\n          class="node-group"\n          [class.old-node]="animate && oldClusters.has(node.id)"\n          [id]="node.id"\n          [attr.transform]="node.transform"\n          (click)="onClick(node)"\n        >\n          <ng-container\n            *ngIf="clusterTemplate && !node.hidden"\n            [ngTemplateOutlet]="clusterTemplate"\n            [ngTemplateOutletContext]="{ $implicit: node }"\n          ></ng-container>\n          <svg:g *ngIf="!clusterTemplate" class="node cluster">\n            <svg:rect\n              [attr.width]="node.dimension.width"\n              [attr.height]="node.dimension.height"\n              [attr.fill]="node.data?.color"\n            />\n            <svg:text alignment-baseline="central" [attr.x]="10" [attr.y]="node.dimension.height / 2">\n              {{ node.label }}\n            </svg:text>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n\n      <svg:g class="compound-nodes">\n        <svg:g\n          #nodeElement\n          *ngFor="let node of graph.compoundNodes; trackBy: trackNodeBy"\n          class="node-group"\n          [class.old-node]="animate && oldCompoundNodes.has(node.id)"\n          [id]="node.id"\n          [attr.transform]="node.transform"\n          (click)="onClick(node)"\n          (mousedown)="onNodeMouseDown($event, node)"\n        >\n          <ng-container\n            *ngIf="nodeTemplate && !node.hidden"\n            [ngTemplateOutlet]="nodeTemplate"\n            [ngTemplateOutletContext]="{ $implicit: node }"\n          ></ng-container>\n          <svg:g *ngIf="!nodeTemplate" class="node compound-node">\n            <svg:rect\n              [attr.width]="node.dimension.width"\n              [attr.height]="node.dimension.height"\n              [attr.fill]="node.data?.color"\n            />\n            <svg:text alignment-baseline="central" [attr.x]="10" [attr.y]="node.dimension.height / 2">\n              {{ node.label }}\n            </svg:text>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n\n      <svg:g class="links">\n        <svg:g #linkElement *ngFor="let link of graph.edges; trackBy: trackLinkBy" class="link-group" [id]="link.id">\n          <ng-container\n            *ngIf="linkTemplate"\n            [ngTemplateOutlet]="linkTemplate"\n            [ngTemplateOutletContext]="{ $implicit: link }"\n          ></ng-container>\n          <svg:path *ngIf="!linkTemplate" class="edge" [attr.d]="link.line" />\n        </svg:g>\n      </svg:g>\n\n      <svg:g class="nodes" #nodeGroup>\n        <svg:g\n          #nodeElement\n          *ngFor="let node of graph.nodes; trackBy: trackNodeBy"\n          class="node-group"\n          [class.old-node]="animate && oldNodes.has(node.id)"\n          [id]="node.id"\n          [attr.transform]="node.transform"\n          (click)="onClick(node)"\n          (mousedown)="onNodeMouseDown($event, node)"\n        >\n          <ng-container\n            *ngIf="nodeTemplate && !node.hidden"\n            [ngTemplateOutlet]="nodeTemplate"\n            [ngTemplateOutletContext]="{ $implicit: node }"\n          ></ng-container>\n          <svg:circle\n            *ngIf="!nodeTemplate"\n            r="10"\n            [attr.cx]="node.dimension.width / 2"\n            [attr.cy]="node.dimension.height / 2"\n            [attr.fill]="node.data?.color"\n          />\n        </svg:g>\n      </svg:g>\n    </svg:g>\n\n    <svg:clipPath [attr.id]="minimapClipPathId">\n      <svg:rect\n        [attr.width]="graphDims.width / minimapScaleCoefficient"\n        [attr.height]="graphDims.height / minimapScaleCoefficient"\n      ></svg:rect>\n    </svg:clipPath>\n\n    <svg:g\n      class="minimap"\n      *ngIf="showMiniMap"\n      [attr.transform]="minimapTransform"\n      [attr.clip-path]="\'url(#\' + minimapClipPathId + \')\'"\n    >\n      <svg:rect\n        class="minimap-background"\n        [attr.width]="graphDims.width / minimapScaleCoefficient"\n        [attr.height]="graphDims.height / minimapScaleCoefficient"\n        (mousedown)="onMinimapPanTo($event)"\n      ></svg:rect>\n\n      <svg:g\n        [style.transform]="\n          \'translate(\' +\n          -minimapOffsetX / minimapScaleCoefficient +\n          \'px,\' +\n          -minimapOffsetY / minimapScaleCoefficient +\n          \'px)\'\n        "\n      >\n        <svg:g class="minimap-nodes" [style.transform]="\'scale(\' + 1 / minimapScaleCoefficient + \')\'">\n          <svg:g\n            #nodeElement\n            *ngFor="let node of graph.nodes; trackBy: trackNodeBy"\n            class="node-group"\n            [class.old-node]="animate && oldNodes.has(node.id)"\n            [id]="node.id"\n            [attr.transform]="node.transform"\n          >\n            <ng-container\n              *ngIf="miniMapNodeTemplate"\n              [ngTemplateOutlet]="miniMapNodeTemplate"\n              [ngTemplateOutletContext]="{ $implicit: node }"\n            ></ng-container>\n            <ng-container\n              *ngIf="!miniMapNodeTemplate && nodeTemplate"\n              [ngTemplateOutlet]="nodeTemplate"\n              [ngTemplateOutletContext]="{ $implicit: node }"\n            ></ng-container>\n            <svg:circle\n              *ngIf="!nodeTemplate && !miniMapNodeTemplate"\n              r="10"\n              [attr.cx]="node.dimension.width / 2 / minimapScaleCoefficient"\n              [attr.cy]="node.dimension.height / 2 / minimapScaleCoefficient"\n              [attr.fill]="node.data?.color"\n            />\n          </svg:g>\n        </svg:g>\n\n        <svg:rect\n          [attr.transform]="\n            \'translate(\' +\n            panOffsetX / zoomLevel / -minimapScaleCoefficient +\n            \',\' +\n            panOffsetY / zoomLevel / -minimapScaleCoefficient +\n            \')\'\n          "\n          class="minimap-drag"\n          [class.panning]="isMinimapPanning"\n          [attr.width]="width / minimapScaleCoefficient / zoomLevel"\n          [attr.height]="height / minimapScaleCoefficient / zoomLevel"\n          (mousedown)="onMinimapDragMouseDown()"\n        ></svg:rect>\n      </svg:g>\n    </svg:g>\n  </svg:svg>\n</div>\n',encapsulation:debug_node_DTOmNMDH.gXe.None,changeDetection:debug_node_DTOmNMDH.Ngq.OnPush,animations:[(0,private_export_B_vy_9K7.hZ)("animationState",[(0,private_export_B_vy_9K7.kY)(":enter",[(0,private_export_B_vy_9K7.iF)({opacity:0}),(0,private_export_B_vy_9K7.i0)("500ms 100ms",(0,private_export_B_vy_9K7.iF)({opacity:1}))])])],standalone:!1,styles:[graph_componentngResource_default()]})],GraphComponent);let MouseWheelDirective=class MouseWheelDirective{mouseWheelUp=new debug_node_DTOmNMDH.bkB;mouseWheelDown=new debug_node_DTOmNMDH.bkB;onMouseWheelChrome(event){this.mouseWheelFunc(event)}onMouseWheelFirefox(event){this.mouseWheelFunc(event)}onWheel(event){this.mouseWheelFunc(event)}onMouseWheelIE(event){this.mouseWheelFunc(event)}mouseWheelFunc(event){window.event&&(event=window.event);const delta=Math.max(-1,Math.min(1,event.wheelDelta||-event.detail||event.deltaY||event.deltaX)),isWheelMouseUp=event.wheelDelta?delta>0:delta<0,isWheelMouseDown=event.wheelDelta?delta<0:delta>0;isWheelMouseUp?this.mouseWheelUp.emit(event):isWheelMouseDown&&this.mouseWheelDown.emit(event),event.returnValue=!1,event.preventDefault&&event.preventDefault()}static propDecorators={mouseWheelUp:[{type:debug_node_DTOmNMDH.k7i}],mouseWheelDown:[{type:debug_node_DTOmNMDH.k7i}],onMouseWheelChrome:[{type:debug_node_DTOmNMDH.Z$l,args:["mousewheel",["$event"]]}],onMouseWheelFirefox:[{type:debug_node_DTOmNMDH.Z$l,args:["DOMMouseScroll",["$event"]]}],onWheel:[{type:debug_node_DTOmNMDH.Z$l,args:["wheel",["$event"]]}],onMouseWheelIE:[{type:debug_node_DTOmNMDH.Z$l,args:["onmousewheel",["$event"]]}]}};MouseWheelDirective=(0,tslib_es6.Cg)([(0,debug_node_DTOmNMDH.WLR)({selector:"[mouseWheel]",standalone:!1})],MouseWheelDirective);let GraphModule=class GraphModule{};GraphModule=(0,tslib_es6.Cg)([(0,debug_node_DTOmNMDH.UQu)({imports:[common_module_D4mHDfs1.MD],declarations:[GraphComponent,MouseWheelDirective,VisibilityObserver],exports:[GraphComponent,MouseWheelDirective],providers:[LayoutService]})],GraphModule);let NgxGraphModule=class NgxGraphModule{};NgxGraphModule=(0,tslib_es6.Cg)([(0,debug_node_DTOmNMDH.UQu)({imports:[common_module_D4mHDfs1.MD],exports:[GraphModule]})],NgxGraphModule)}}]);